(() => {
  var __defProp = Object.defineProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };

  // src/api.js
  async function getStops() {
    const token = localStorage.getItem("sessionToken");
    const res = await fetch("/stops", { headers: { "Authorization": token } });
    if (!res.ok)
      throw new Error("Failed to fetch stops");
    return res.json();
  }
  async function createStop(location2) {
    const token = localStorage.getItem("sessionToken");
    const res = await fetch("/stops", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": token
      },
      body: JSON.stringify({ location: location2 })
    });
    if (!res.ok)
      throw new Error("Failed to create stop");
    return res.json();
  }
  async function removeStop(id) {
    const token = localStorage.getItem("sessionToken");
    const res = await fetch(`/stops/${id}`, {
      method: "DELETE",
      headers: {
        "Content-Type": "application/json",
        "Authorization": token
      }
    });
    if (!res.ok)
      throw new Error("Failed to delete stop");
    return res.json();
  }
  async function getRoutes() {
    const token = localStorage.getItem("sessionToken");
    const res = await fetch("/routes", { headers: { "Authorization": token } });
    if (!res.ok)
      throw new Error("Failed to fetch routes");
    return res.json();
  }
  async function createRoute(route_id, time, stop_id) {
    const token = localStorage.getItem("sessionToken");
    const res = await fetch("/routes", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": token
      },
      body: JSON.stringify({ route_id, time, stop_id })
    });
    if (!res.ok)
      throw new Error("Failed to create route");
    return res.json();
  }
  async function removeRoute(id) {
    const token = localStorage.getItem("sessionToken");
    const res = await fetch(`/routes/${id}`, {
      method: "DELETE",
      headers: {
        "Content-Type": "application/json",
        "Authorization": token
      }
    });
    if (!res.ok)
      throw new Error("Failed to delete route");
    return res.json();
  }
  async function getLines() {
    const token = localStorage.getItem("sessionToken");
    const res = await fetch("/lines", { headers: { "Authorization": token } });
    if (!res.ok)
      throw new Error("Failed to fetch lines");
    return res.json();
  }
  async function checkUser() {
    const token = localStorage.getItem("sessionToken");
    if (!token) {
      return { logged_in: false };
    }
    try {
      const res = await fetch("/me", {
        method: "GET",
        headers: { "Authorization": token }
      });
      if (!res.ok) {
        return { logged_in: false };
      }
      const data = await res.json();
      return { logged_in: data.logged_in, user: data.logged_in ? data : void 0 };
    } catch (err) {
      console.error("Error checking login:", err);
      return { logged_in: false };
    }
  }
  async function login(username, password) {
    const token = localStorage.getItem("sessionToken");
    const res = await fetch("/login", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": token
      },
      body: JSON.stringify({ username, password })
    });
    if (!res.ok)
      throw new Error("Failed to login");
    return res.json();
  }
  async function createUser(username, password) {
    const token = localStorage.getItem("sessionToken");
    const res = await fetch("/users", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ username, password })
    });
    if (!res.ok)
      throw new Error("Failed to register new user");
    return res.json();
  }
  async function getUsers() {
    const token = localStorage.getItem("sessionToken");
    const res = await fetch("/users", { headers: { "Authorization": token } });
    if (!res.ok)
      throw new Error("Failed to fetch users");
    return res.json();
  }
  async function getUserDuties(userId) {
    const token = localStorage.getItem("sessionToken");
    const users = await getUsers();
    const user = users.find((u6) => u6.id === userId);
    return user?.duties ?? [];
  }
  async function assignDuty(userId, routeId, method = "POST") {
    const token = localStorage.getItem("sessionToken");
    const res = await fetch(`/users/${userId}/duties`, {
      method: method.toUpperCase(),
      headers: {
        "Content-Type": "application/json",
        "Authorization": token
      },
      body: JSON.stringify({ route_id: routeId })
    });
    if (!res.ok)
      throw new Error(`Failed to ${method === "DELETE" ? "remove" : "assign"} duty`);
  }

  // node_modules/@moaqzdev/toast/dist/utils.mjs
  var o = "@moaqzdev/toast";
  var i = { _dispatchToast(s6, t7) {
    Object.assign(t7, { type: s6 });
    const a5 = new CustomEvent(o, { detail: t7 });
    document.dispatchEvent(a5);
  }, success(s6) {
    this._dispatchToast("success", s6);
  }, error(s6) {
    this._dispatchToast("error", s6);
  }, warning(s6) {
    this._dispatchToast("warning", s6);
  }, info(s6) {
    this._dispatchToast("info", s6);
  }, confirm(s6) {
    this._dispatchToast("confirm", s6);
  } };

  // node_modules/active-table/dist/activeTable.js
  var GenericElementUtils = class {
    static hideElements(...D) {
      D.forEach((w2) => w2.style.display = "none");
    }
    static getStyleWidth(D, w2) {
      return Number.parseFloat(D.style[w2]) || 0;
    }
    static doesElementExistInDom(D) {
      return !!D.parentElement;
    }
    static isFirstChildInParent(D) {
      var w2;
      return ((w2 = D.parentElement) == null ? void 0 : w2.firstChild) === D;
    }
  };
  GenericElementUtils.NOT_SELECTABLE_CLASS = "not-selectable";
  var SVGIconUtils = class {
    // REF-10
    static createSVGElement(D) {
      return new DOMParser().parseFromString(D, "image/svg+xml").documentElement;
    }
  };
  SVGIconUtils.WHITE_FILTER = `brightness(0) saturate(100%) invert(100%) sepia(1%) saturate(3877%)
    hue-rotate(184deg) brightness(103%) contrast(100%)`;
  SVGIconUtils.LIGHT_GREY_FILTER = `brightness(0) saturate(100%) invert(68%) sepia(0%) saturate(317%)
    hue-rotate(84deg) brightness(92%) contrast(93%)`;
  SVGIconUtils.HEADER_FILTER = `brightness(0) saturate(100%) invert(34%) sepia(0%) saturate(1075%)
    hue-rotate(211deg) brightness(96%) contrast(90%)`;
  SVGIconUtils.DROPDOWN_ITEM_FILTER = `brightness(0) saturate(100%) invert(7%) sepia(23%) saturate(258%)
    hue-rotate(63deg) brightness(99%) contrast(97%)`;
  var StaticDropdown = class {
  };
  StaticDropdown.DROPDOWN_CLASS = "static-dropdown";
  StaticDropdown.ITEM_CLASS = "static-dropdown-item";
  StaticDropdown.ACTIVE_ITEM_CLASS = "active-static-dropdown-item";
  var _DropdownItemHighlightUtils = class it {
    // Accepted behaviour - fadeFocused is triggered twice when moving to a different item
    static fadeCurrentlyHighlighted(D) {
      const w2 = D.dropdownItem;
      w2 && (w2.classList.contains(StaticDropdown.ACTIVE_ITEM_CLASS) && w2.classList.remove(StaticDropdown.ACTIVE_ITEM_CLASS), w2.style.backgroundColor = "", delete D.dropdownItem);
    }
    static highlightNew(D, w2) {
      it.fadeCurrentlyHighlighted(D), w2.focus(), D.dropdownItem = w2, w2.classList.contains(StaticDropdown.ITEM_CLASS) ? w2.classList.add(StaticDropdown.ACTIVE_ITEM_CLASS) : w2.classList.contains(DropdownItem.DROPDOWN_INPUT_CLASS) || (w2.style.backgroundColor = it.HOVER_BACKGROUND_COLOR);
    }
  };
  _DropdownItemHighlightUtils.HOVER_BACKGROUND_COLOR = "#eaeaea";
  var DropdownItemHighlightUtils = _DropdownItemHighlightUtils;
  var DropdownItemEvents = class {
    // prettier-ignore
    static addItemEvents(D, w2) {
      w2.addEventListener(
        "mouseenter",
        DropdownItemHighlightUtils.highlightNew.bind(this, D, w2)
      ), w2.addEventListener(
        "mouseleave",
        DropdownItemHighlightUtils.fadeCurrentlyHighlighted.bind(this, D)
      );
    }
  };
  var _DropdownItem = class ee {
    static toggleItem(D, w2) {
      D.style.display = w2 ? ee.DISPLAY : ee.HIDDEN;
    }
    static isDisplayed(D) {
      return D.style.display === ee.DISPLAY;
    }
    static createDropdownItemBaseElement(D) {
      const w2 = document.createElement(D);
      return w2.classList.add(ee.DROPDOWN_ITEM_IDENTIFIER), w2;
    }
    static createItem(D) {
      const w2 = ee.createDropdownItemBaseElement("div");
      return D && (w2.tabIndex = D.children.length), w2.classList.add(ee.DROPDOWN_ITEM_CLASS, GenericElementUtils.NOT_SELECTABLE_CLASS), w2;
    }
    // no need to sanitize paste as input element already does it
    static addInputItem(D, w2) {
      const O = ee.createItem(w2);
      O.classList.add(ee.DROPDOWN_INPUT_ITEM_CLASS);
      const x2 = ee.createDropdownItemBaseElement("input");
      x2.classList.add(ee.DROPDOWN_INPUT_CLASS), O.appendChild(x2), w2.appendChild(O), DropdownItemEvents.addItemEvents(D._activeOverlayElements, x2);
    }
    // REF-10
    static insertIcon(D, w2) {
      const { svgString: O, containerStyles: x2 } = w2, U = document.createElement("div");
      U.classList.add(ee.DROPDOWN_ITEM_ICON_CONTAINER_CLASS), Object.assign(U.style, x2 == null ? void 0 : x2.dropdown);
      const F = SVGIconUtils.createSVGElement(O);
      F.style.filter = SVGIconUtils.DROPDOWN_ITEM_FILTER, U.appendChild(F), D.insertBefore(U, D.children[0]);
    }
    static addPlaneButtonItem(D, w2, O) {
      const x2 = ee.createItem(D), U = ee.createDropdownItemBaseElement("div");
      return U.innerText = w2 || ee.DROPDOWN_ITEM_EMPTY_PLACEHOLDER_TEXT, w2.trim() === "" && U.classList.add(ee.DROPDOWN_ITEM_EMPTY_CLASS), x2.append(U), D && (O !== void 0 && D.children[O] ? D.insertBefore(x2, D.children[O]) : D.appendChild(x2)), x2;
    }
    // prettier-ignore
    static createButtonItemNoEvents(D, w2, ...O) {
      const x2 = ee.addPlaneButtonItem(D, w2.text);
      return w2.iconSettings && ee.insertIcon(x2, w2.iconSettings), O.length > 0 && x2.classList.add(...O), x2;
    }
    static addTitle(D, w2) {
      const O = ee.createDropdownItemBaseElement("div");
      O.classList.add(ee.DROPDOWN_ITEM_CLASS, ee.DROPDOWN_TITLE_ITEM_CLASS), O.innerText = w2, D.appendChild(O);
    }
    static addDivider(D) {
      const w2 = ee.createDropdownItemBaseElement("div");
      w2.classList.add(ee.DROPDOWN_ITEM_DIVIDER_CLASS), D.appendChild(w2);
    }
    // prettier-ignore
    static addButtonItem(D, w2, O, ...x2) {
      const U = ee.createButtonItemNoEvents(w2, O, ...x2);
      return DropdownItemEvents.addItemEvents(D._activeOverlayElements, U), U;
    }
    // prettier-ignore
    static addNewButtonItems(D, w2, O) {
      return O.map((x2) => ee.addButtonItem(D, w2, x2));
    }
    static addButtonItemElements(D, w2, O) {
      O.forEach((x2) => {
        x2.tabIndex = w2.children.length, w2.appendChild(x2), DropdownItemEvents.addItemEvents(D._activeOverlayElements, x2);
      });
    }
    static removeItems(D) {
      Array.from(D.children).forEach((w2) => w2.remove());
    }
    static doesElementContainItemClass(D) {
      return D.classList.contains(ee.DROPDOWN_ITEM_IDENTIFIER);
    }
    static doesElementContainInputClass(D) {
      return D.classList.contains(ee.DROPDOWN_INPUT_CLASS);
    }
    static getInputElement(D) {
      return D.getElementsByClassName(ee.DROPDOWN_INPUT_ITEM_CLASS)[0];
    }
    static toggleUsability(D, w2) {
      const O = D.children[0];
      w2 ? (D.classList.remove(ee.DISABLED_ITEM_CLASS), O.style.filter = "") : (D.classList.add(ee.DISABLED_ITEM_CLASS), O.style.filter = SVGIconUtils.LIGHT_GREY_FILTER);
    }
  };
  _DropdownItem.DROPDOWN_ITEM_CLASS = "dropdown-item";
  _DropdownItem.DISABLED_ITEM_CLASS = "dropdown-disabled-item";
  _DropdownItem.ACTIVE_ITEM_CLASS = "active-dropdown-item";
  _DropdownItem.DROPDOWN_INPUT_CLASS = "dropdown-input";
  _DropdownItem.DROPDOWN_ITEM_ICON_CONTAINER_CLASS = "dropdown-item-icon-container";
  _DropdownItem.DROPDOWN_INPUT_ITEM_CLASS = "dropdown-input-item";
  _DropdownItem.DROPDOWN_TITLE_ITEM_CLASS = "dropdown-title-item";
  _DropdownItem.DROPDOWN_ITEM_DIVIDER_CLASS = "dropdown-item-divider";
  _DropdownItem.DROPDOWN_ITEM_EMPTY_CLASS = "dropdown-item-empty";
  _DropdownItem.DROPDOWN_ITEM_EMPTY_PLACEHOLDER_TEXT = "...";
  _DropdownItem.DROPDOWN_ITEM_IDENTIFIER = "dropdown-item-identifier";
  _DropdownItem.HIDDEN = "none";
  _DropdownItem.DISPLAY = "";
  var DropdownItem = _DropdownItem;
  var OuterDropdownItem = class {
    static unsetHoverColors(D) {
      D.forEach((w2) => w2.style.backgroundColor = "");
    }
    static unsetActiveItem(D) {
      const w2 = D.getElementsByClassName(DropdownItem.ACTIVE_ITEM_CLASS)[0];
      w2 == null || w2.classList.remove(DropdownItem.ACTIVE_ITEM_CLASS);
    }
    static setActive(D, w2) {
      const O = D.find((x2) => x2.innerText === w2);
      O == null || O.classList.add(DropdownItem.ACTIVE_ITEM_CLASS);
    }
    static setActiveByIndex(D, w2) {
      D[w2].classList.add(DropdownItem.ACTIVE_ITEM_CLASS);
    }
  };
  var ElementStyle = class _ElementStyle {
    static setStyle(D, w2, O) {
      D.style[w2] = O;
    }
    // prettier-ignore
    static moveStyles(D, w2, ...O) {
      O.forEach((x2) => {
        D.style[x2] && _ElementStyle.setStyle(w2, x2, D.style[x2]);
      });
    }
    static unsetStyle(D, w2) {
      const O = Object.keys(w2).reduce((x2, U) => (x2[U] = "", x2), {});
      Object.assign(D.style, O);
    }
    static unsetAllCSSStates(D, w2) {
      w2.click && _ElementStyle.unsetStyle(D, w2.click), w2.hover && _ElementStyle.unsetStyle(D, w2.hover), w2.default && _ElementStyle.unsetStyle(D, w2.default);
    }
    static generateStatefulCSS(D, w2, O) {
      const x2 = D.default || {}, U = Object.assign(JSON.parse(JSON.stringify({ ...x2, ...w2 })), D == null ? void 0 : D.hover), F = Object.assign(JSON.parse(JSON.stringify({ ...U, ...O })), D == null ? void 0 : D.click);
      return { default: x2, hover: U, click: F };
    }
  };
  var _ToggleableElement = class Te {
    static set(D, w2) {
      D.classList.add(Te.ACTIVE_BUTTON_CLASS), Object.assign(D.style, w2);
    }
    static unset(D, w2) {
      D.classList.remove(Te.ACTIVE_BUTTON_CLASS), ElementStyle.unsetStyle(D, w2);
    }
    static toggleActive(D, w2) {
      const O = !!D.classList.contains(Te.ACTIVE_BUTTON_CLASS);
      return O ? (Te.unset(D, w2), D.dispatchEvent(new MouseEvent("mouseenter"))) : Te.set(D, w2), O;
    }
    static unsetActive(D, w2) {
      !!D.classList.contains(Te.ACTIVE_BUTTON_CLASS) && (Te.unset(D, w2), D.dispatchEvent(new MouseEvent("mouseleave")));
    }
    static setActive(D, w2) {
      !!D.classList.contains(Te.ACTIVE_BUTTON_CLASS) || Te.set(D, w2);
    }
  };
  _ToggleableElement.ACTIVE_BUTTON_CLASS = "toggleable-button-active";
  _ToggleableElement.AUTO_STYLING_CLASS = "toggleable-button-auto-styling";
  var ToggleableElement = _ToggleableElement;
  var _Dropdown = class ve {
    static createBase() {
      const D = document.createElement("div");
      return D.classList.add(ve.DROPDOWN_CLASS), D.style.width = `${ve.DROPDOWN_WIDTH}px`, D.style.paddingTop = ve.DROPDOWN_VERTICAL_PX, D.style.paddingBottom = ve.DROPDOWN_VERTICAL_PX, ve.hide(D), D;
    }
    static isDisplayed(D) {
      return (D == null ? void 0 : D.style.display) === ve.CSS_DISPLAY_VISIBLE;
    }
    static display(...D) {
      D.forEach((w2) => {
        w2.style.display = ve.CSS_DISPLAY_VISIBLE;
      });
    }
    static hide(...D) {
      GenericElementUtils.hideElements(...D);
    }
    static isPartOfDropdownElement(D) {
      return D.classList.contains(ve.DROPDOWN_CLASS) || DropdownItem.doesElementContainItemClass(D);
    }
  };
  _Dropdown.DROPDOWN_CLASS = "active-table-dropdown";
  _Dropdown.CSS_DISPLAY_VISIBLE = "grid";
  _Dropdown.DROPDOWN_WIDTH = 176;
  _Dropdown.DROPDOWN_VERTICAL_PX = "4px";
  var Dropdown = _Dropdown;
  var _OuterDropdownButtonEvents = class xe {
    static mouseClickButton(D, w2, O) {
      const { element: x2 } = w2;
      x2.classList.contains(xe.DO_NOT_DISPLAY_DROPDOWN_CLASS) ? x2.classList.remove(xe.DO_NOT_DISPLAY_DROPDOWN_CLASS) : O(D, w2);
    }
    static mouseDownButton(D) {
      const { element: w2, button: O, activeButtonStyle: x2 } = D;
      Dropdown.isDisplayed(w2) && (w2.classList.add(xe.DO_NOT_DISPLAY_DROPDOWN_CLASS), ToggleableElement.unsetActive(O, x2));
    }
    static getDisplayFunc(D) {
      return D.startsWith("top") ? OuterDropdownElement.display : OuterDropdownElement.displayReactToBottomVisibility;
    }
    // prettier-ignore
    static set(D, w2, O, x2, U) {
      const F = U || xe.getDisplayFunc(O);
      w2.addEventListener("mousedown", xe.mouseDownButton.bind(this, x2)), w2.addEventListener(
        "click",
        xe.mouseClickButton.bind(this, D, x2, F)
      );
    }
  };
  _OuterDropdownButtonEvents.DO_NOT_DISPLAY_DROPDOWN_CLASS = "do-not-display-class";
  var OuterDropdownButtonEvents = _OuterDropdownButtonEvents;
  var VH = "vh";
  var VW = "vw";
  var LITElementTypeConverters = class {
    static convertToBoolean(Y) {
      return typeof Y == "string" ? Y === "true" : !!Y;
    }
    static convertToFunction(value) {
      if (typeof value == "function")
        return value;
      if (typeof value == "string") {
        const evaluatedExpression = eval(value);
        if (typeof evaluatedExpression == "function")
          return evaluatedExpression;
      }
      return () => {
      };
    }
  };
  var ObjectUtils = class {
    static createTwoWayObject(D) {
      return Object.keys(D).forEach((w2) => {
        D[D[w2]] = w2;
      }), D;
    }
    static convertStringToFunction(D, w2) {
      typeof D[w2] == "string" && (D[w2] = LITElementTypeConverters.convertToFunction(
        D[w2]
      ));
    }
    // method to check if value is not nullish
    static areValuesFullyDefined(...D) {
      return D.findIndex((O) => O == null) === -1;
    }
    static removeProperties(D, ...w2) {
      w2.forEach((O) => {
        delete D[O];
      });
    }
  };
  var RegexUtils = class {
    static extractIntegerStrs(D) {
      return D.match(/\d+/g);
    }
    static extractFloatStrs(D) {
      return D.match(/-?\d+(\.\d+)?$/g);
    }
  };
  var StringDimensionUtils = class _StringDimensionUtils {
    static processDimension(D, w2) {
      return D < w2 ? w2 : D;
    }
    // prettier-ignore
    static processPercentageDimension(D, w2, O, x2) {
      w2 > 100 && (w2 = 100);
      const F = (O ? D.getBoundingClientRect().width : D.offsetHeight) * (w2 / 100);
      return { number: _StringDimensionUtils.processDimension(F, x2), isPercentage: true };
    }
    // can also parse numbers incase the client used that
    // if this returns a number 0 for a %, the likelyhood is that the parent element does not have that dimension set
    // prettier-ignore
    static generateNumberDimensionFromClientString(D, w2, O, x2, U = 0) {
      const F = w2[O], W = typeof F == "string";
      let G = W ? Number(RegexUtils.extractIntegerStrs(F)[0]) : F;
      if (W) {
        if (F.includes("%"))
          return _StringDimensionUtils.processPercentageDimension(D, G, x2, U);
        F.includes(VH) ? G = window.innerHeight * (G / 100) : F.includes(VW) && (G = window.innerWidth * (G / 100));
      }
      return { number: _StringDimensionUtils.processDimension(G, U), isPercentage: false };
    }
    static removeAllDimensions(D) {
      if (D)
        return ObjectUtils.removeProperties(D, "width", "minWidth", "maxWidth", "height", "minHeight", "maxHeight"), D;
    }
  };
  var PageButtonStyle = class _PageButtonStyle {
    // prettier-ignore
    static unsetAllCSSStates(D, w2, O) {
      ElementStyle.unsetAllCSSStates(D, w2[O]);
    }
    static unsetAll(D, w2, O) {
      D.classList.contains(w2.activeButtonClass) ? _PageButtonStyle.unsetAllCSSStates(D, w2, "activeButton") : D.classList.contains(PageButtonElement.DISABLED_PAGINATION_BUTTON_CLASS) ? ElementStyle.unsetStyle(D, w2.disabledButtons) : _PageButtonStyle.unsetAllCSSStates(D, w2, O ? "actionButtons" : "buttons");
    }
    static setDefault(D, w2, O) {
      _PageButtonStyle.unsetAll(D, w2, O), O ? Object.assign(D.style, w2.actionButtons.default) : Object.assign(D.style, w2.buttons.default);
    }
    // prettier-ignore
    static setActive(D, w2, O) {
      O && (_PageButtonStyle.unsetAllCSSStates(O, w2, "activeButton"), Object.assign(O.style, w2.buttons.default)), D.classList.contains(PageButtonElement.DISABLED_PAGINATION_BUTTON_CLASS) ? ElementStyle.unsetStyle(D, w2.disabledButtons) : _PageButtonStyle.unsetAllCSSStates(D, w2, "buttons"), Object.assign(D.style, w2.activeButton.default);
    }
    static setDisabled(D, w2, O) {
      _PageButtonStyle.setDefault(D, w2, O), Object.assign(D.style, w2.disabledButtons);
    }
    static mouseDown(D, w2, O) {
      D.classList.contains(w2.activeButtonClass) ? Object.assign(D.style, w2.activeButton.click) : O ? Object.assign(D.style, w2.actionButtons.click) : Object.assign(D.style, w2.buttons.click), PaginationVisibleButtonsUtils.overrideOnMouseEvent(D, w2);
    }
    static mouseEnter(D, w2, O) {
      D.classList.contains(PageButtonElement.DISABLED_PAGINATION_BUTTON_CLASS) || (D.classList.contains(w2.activeButtonClass) ? (_PageButtonStyle.unsetAllCSSStates(D, w2, "activeButton"), Object.assign(D.style, w2.activeButton.default), Object.assign(D.style, w2.activeButton.hover)) : (_PageButtonStyle.setDefault(D, w2, O), O ? Object.assign(D.style, w2.actionButtons.hover) : Object.assign(D.style, w2.buttons.hover)), PaginationVisibleButtonsUtils.overrideOnMouseEvent(D, w2));
    }
    static mouseLeave(D, w2, O) {
      D.classList.contains(PageButtonElement.DISABLED_PAGINATION_BUTTON_CLASS) || (D.classList.contains(w2.activeButtonClass) ? (_PageButtonStyle.unsetAll(D, w2, false), Object.assign(D.style, w2.activeButton.default)) : _PageButtonStyle.setDefault(D, w2, O), PaginationVisibleButtonsUtils.overrideOnMouseEvent(D, w2));
    }
  };
  var _FilterInputElement = class Pe {
    static setPlaceholder(D, w2, O) {
      if (w2 && w2 !== "") {
        const x2 = O || Pe.DEFAULT_PLACEHOLDER_TEMPLATE;
        D.placeholder = x2.replace(Pe.TEMPLATE_VARIABLE, w2);
      } else
        D.placeholder = Pe.DEFAULT_PLACEHOLDER;
    }
    static createElement(D, w2, O) {
      const x2 = document.createElement("input");
      x2.classList.add(Pe.INPUT_CLASS);
      const U = (O == null ? void 0 : O.placeholderColor) || "#656565";
      return x2.style.setProperty("--active-table-filter-placeholder-color", U), Object.assign(x2.style, O == null ? void 0 : O.input), Pe.setPlaceholder(x2, D, w2), x2;
    }
    static create(D, w2, O) {
      const x2 = FilterInternalUtils.generateDefaultHeaderName(O, D.defaultColumnHeaderName), U = Pe.createElement(x2, D.placeholderTemplate, w2.styles);
      return D.inputElement = U, U;
    }
  };
  _FilterInputElement.INPUT_CLASS = "filter-rows-input";
  _FilterInputElement.TEMPLATE_VARIABLE = "{headerName}";
  _FilterInputElement.DEFAULT_PLACEHOLDER = "Filter";
  _FilterInputElement.DEFAULT_PLACEHOLDER_TEMPLATE = `Filter ${_FilterInputElement.TEMPLATE_VARIABLE}...`;
  var FilterInputElement = _FilterInputElement;
  var FilterInputEvents = class _FilterInputEvents {
    static unsetEvents(D) {
      D && D.forEach((w2) => w2.inputElement.oninput = () => {
      });
    }
    static updateSameInputValues(D, w2) {
      D.forEach((O) => {
        O.elements === w2.elements && (O.inputElement.value = w2.inputElement.value);
      });
    }
    static getFilterData(D) {
      return D.map((w2) => ({
        filterText: w2.isCaseSensitive ? w2.inputElement.value : w2.inputElement.value.toLocaleLowerCase(),
        colCells: w2.elements.slice(1),
        isCaseSensitive: w2.isCaseSensitive
      }));
    }
    static splitChunksAndExecute(D, w2) {
      const O = D.filter((U) => U.filterText !== "");
      O.length === 0 && O.push(D[0]);
      const x2 = Math.ceil(O[0].colCells.length / FilterInternalUtils.CHUNK_SIZE);
      for (let U = 0; U < x2; U += 1) {
        const F = U * FilterInternalUtils.CHUNK_SIZE, W = O.map((G) => ({ ...G, chunk: G.colCells.slice(F, F + FilterInternalUtils.CHUNK_SIZE) }));
        w2(W);
      }
    }
    static setEvents(D, w2, O) {
      if (!w2.elements)
        return;
      const x2 = FilterInternalUtils.getFilterFunc(D), U = O.filter((F) => F !== w2);
      w2.inputElement.oninput = () => {
        _FilterInputEvents.updateSameInputValues(U, w2), _FilterInputEvents.splitChunksAndExecute(_FilterInputEvents.getFilterData(O), x2);
      };
    }
  };
  var ARROW_DOWN_SVG_STRING = `<?xml version="1.0" encoding="UTF-8"?>
<svg viewBox="0 0 24 24" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	<g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
		<g transform="translate(-288.000000, 0.000000)">
			<g transform="translate(288.000000, 0.000000)">
				<path d="M24,0 L24,24 L0,24 L0,0 L24,0 Z M12.5934901,23.257841 L12.5819402,23.2595131 L12.5108777,23.2950439 L12.4918791,23.2987469 L12.4918791,23.2987469 L12.4767152,23.2950439 L12.4056548,23.2595131 C12.3958229,23.2563662 12.3870493,23.2590235 12.3821421,23.2649074 L12.3780323,23.275831 L12.360941,23.7031097 L12.3658947,23.7234994 L12.3769048,23.7357139 L12.4804777,23.8096931 L12.4953491,23.8136134 L12.4953491,23.8136134 L12.5071152,23.8096931 L12.6106902,23.7357139 L12.6232938,23.7196733 L12.6232938,23.7196733 L12.6266527,23.7031097 L12.609561,23.275831 C12.6075724,23.2657013 12.6010112,23.2592993 12.5934901,23.257841 L12.5934901,23.257841 Z M12.8583906,23.1452862 L12.8445485,23.1473072 L12.6598443,23.2396597 L12.6498822,23.2499052 L12.6498822,23.2499052 L12.6471943,23.2611114 L12.6650943,23.6906389 L12.6699349,23.7034178 L12.6699349,23.7034178 L12.678386,23.7104931 L12.8793402,23.8032389 C12.8914285,23.8068999 12.9022333,23.8029875 12.9078286,23.7952264 L12.9118235,23.7811639 L12.8776777,23.1665331 C12.8752882,23.1545897 12.8674102,23.1470016 12.8583906,23.1452862 L12.8583906,23.1452862 Z M12.1430473,23.1473072 C12.1332178,23.1423925 12.1221763,23.1452606 12.1156365,23.1525954 L12.1099173,23.1665331 L12.0757714,23.7811639 C12.0751323,23.7926639 12.0828099,23.8018602 12.0926481,23.8045676 L12.108256,23.8032389 L12.3092106,23.7104931 L12.3186497,23.7024347 L12.3186497,23.7024347 L12.3225043,23.6906389 L12.340401,23.2611114 L12.337245,23.2485176 L12.337245,23.2485176 L12.3277531,23.2396597 L12.1430473,23.1473072 Z" fill-rule="nonzero"></path>
				<path d="M12.7071,15.7072 C12.3166,16.0977 11.6834,16.0977 11.2929,15.7072 L5.63604,10.0503 C5.24551,9.65982 5.24551,9.02666 5.63604,8.63613 C6.02656,8.24561 6.65973,8.24561 7.05025,8.63613 L12,13.5859 L16.9497,8.63613 C17.3403,8.24561 17.9734,8.24561 18.364,8.63613 C18.7545,9.02666 18.7545,9.65982 18.364,10.0503 L12.7071,15.7072 Z" fill="#09244B"></path>
			</g>
		</g>
	</g>
</svg>`;
  var _FilterButtonElement = class mt {
    static create(D = {}) {
      const w2 = document.createElement("div");
      w2.classList.add("filter-rows-dropdown-button", ToggleableElement.AUTO_STYLING_CLASS), FilterElements.applyStatefulStyles(w2, mt.HOVER_STYLE, D);
      const O = SVGIconUtils.createSVGElement(ARROW_DOWN_SVG_STRING);
      return w2.appendChild(O), w2;
    }
  };
  _FilterButtonElement.ACTIVE_STYLE = {
    filter: (
      // eslint-disable-next-line max-len
      "brightness(0) saturate(100%) invert(14%) sepia(59%) saturate(2970%) hue-rotate(219deg) brightness(98%) contrast(126%)"
    )
  };
  _FilterButtonElement.HOVER_STYLE = {
    filter: (
      // eslint-disable-next-line max-len
      "brightness(0) saturate(100%) invert(31%) sepia(1%) saturate(75%) hue-rotate(327deg) brightness(100%) contrast(99%)"
    )
  };
  var FilterButtonElement = _FilterButtonElement;
  var OuterDropdownItemEvents = class {
    // prettier-ignore
    static itemMouseDownCommon(D, w2, O) {
      const { _activeOverlayElements: { outerContainerDropdown: x2 } } = this, U = O.target.innerText;
      if (!x2)
        return;
      D == null || D(this, U, O);
      const F = Array.from(x2.element.children);
      w2 == null || w2(this._activeOverlayElements, F), x2.element.classList.contains(StaticDropdown.DROPDOWN_CLASS) || (OuterDropdownItem.unsetActiveItem(x2.element), OuterDropdownItem.setActive(F, U), DropdownItemHighlightUtils.fadeCurrentlyHighlighted(this._activeOverlayElements));
    }
  };
  var FilterDropdownItemEvents = class _FilterDropdownItemEvents {
    static resetInput(D, w2, O, x2) {
      const U = x2.target, F = U.tabIndex === -1 ? U.parentElement.tabIndex : U.tabIndex, W = w2._columnsDetails[F].elements;
      W !== D.elements && (D.elements = W, FilterInternalUtils.resetInput(w2, D), FilterInternalUtils.unsetFilter(D.inputElement));
    }
    static setEvents(D, w2, O, x2) {
      const U = _FilterDropdownItemEvents.resetInput.bind(this, O), F = FilterDropdownElement.hide.bind(this, x2);
      w2.onmousedown = OuterDropdownItemEvents.itemMouseDownCommon.bind(D, U, F);
    }
  };
  var FilterDropdownItem = class _FilterDropdownItem {
    static setActive(D, w2, O) {
      const x2 = D._columnsDetails.findIndex((U) => U.elements === O.elements);
      OuterDropdownItem.setActiveByIndex(Array.from(w2.children), x2);
    }
    static addItems(D, w2, O) {
      var U;
      const x2 = (U = D.data[0]) == null ? void 0 : U.map((F) => String(F));
      x2 == null || x2.forEach((F) => {
        const W = { text: F }, G = DropdownItem.addButtonItem(D, w2.element, W);
        FilterDropdownItemEvents.setEvents(D, G, O, w2.activeButtonStyle);
      });
    }
    static populate(D, w2, O) {
      w2.element.replaceChildren(), _FilterDropdownItem.addItems(D, w2, O), _FilterDropdownItem.setActive(D, w2.element, O);
    }
  };
  var FilterDropdownElement = class _FilterDropdownElement {
    static hide(D, w2) {
      OuterDropdownElement.hide(w2, D);
    }
    // prettier-ignore
    static display(D, w2, O, x2) {
      O.data[0] && (FilterDropdownItem.populate(O, x2, w2), D(O, x2));
    }
    // prettier-ignore
    static create(D, w2, O, x2, U) {
      const F = FilterButtonElement.create(U);
      w2.appendChild(F);
      const W = (U == null ? void 0 : U.active) || {}, G = { ...FilterButtonElement.ACTIVE_STYLE, ...W }, X = _FilterDropdownElement.hide.bind(this, G, D._activeOverlayElements), K = OuterDropdownButtonEvents.getDisplayFunc(O), q = _FilterDropdownElement.display.bind(this, K, x2), { element: Q } = OuterDropdownElement.create(
        D,
        F,
        O,
        G,
        ["filter-rows-dropdown"],
        X,
        q
      );
      return Q;
    }
  };
  var StatefulCSSEvents = class _StatefulCSSEvents {
    static apply(D, w2, O) {
      ElementStyle.unsetAllCSSStates(O, D), Object.assign(O.style, w2);
    }
    static mouseUp(D, w2, O) {
      w2 && O.classList.contains(w2) || (_StatefulCSSEvents.apply(D, D.default, O), Object.assign(O.style, D.hover));
    }
    static mouseDown(D, w2, O) {
      w2 && O.classList.contains(w2) || Object.assign(O.style, D.click);
    }
    static mouseLeave(D, w2, O) {
      w2 && O.classList.contains(w2) || _StatefulCSSEvents.apply(D, D.default, O);
    }
    static mouseEnter(D, w2, O) {
      w2 && O.classList.contains(w2) || Object.assign(O.style, D.hover);
    }
    // can change the styling on another element by using the otherElement argument
    static getEvents(D, w2, O, x2) {
      const U = x2 || D;
      return {
        mouseenter: _StatefulCSSEvents.mouseEnter.bind(this, w2, O, U),
        mouseleave: _StatefulCSSEvents.mouseLeave.bind(this, w2, O, U),
        mousedown: _StatefulCSSEvents.mouseDown.bind(this, w2, O, U),
        mouseup: _StatefulCSSEvents.mouseUp.bind(this, w2, O, U)
      };
    }
    static setEvents(D, w2, O, x2) {
      const U = _StatefulCSSEvents.getEvents(D, w2, O, x2);
      return D.addEventListener("mouseenter", U.mouseenter), D.addEventListener("mouseleave", U.mouseleave), D.addEventListener("mousedown", U.mousedown), D.addEventListener("mouseup", U.mouseup), U;
    }
  };
  var FilterInputCaseEvents = class _FilterInputCaseEvents {
    static clickButton(D, w2, O) {
      const x2 = O || {}, U = ToggleableElement.toggleActive(D, { color: "#000000", ...x2 });
      w2.isCaseSensitive = !U, FilterInternalUtils.resetInput(this, w2), w2.inputElement.dispatchEvent(new Event("input"));
    }
    static setEvents(D, w2, O, x2) {
      w2.onclick = _FilterInputCaseEvents.clickButton.bind(D, w2, O, x2);
    }
  };
  var FilterInputCaseElement = class _FilterInputCaseElement {
    static createButton(D = {}) {
      const w2 = document.createElement("div");
      return w2.classList.add("filter-rows-case-button"), w2.textContent = "Aa", FilterElements.applyStatefulStyles(w2, { color: "#626262" }, D), w2;
    }
    static create(D, w2, O, x2) {
      const U = _FilterInputCaseElement.createButton(x2 == null ? void 0 : x2.caseIcon);
      w2.appendChild(U), setTimeout(() => {
        var F;
        return FilterInputCaseEvents.setEvents(D, U, O, (F = x2 == null ? void 0 : x2.caseIcon) == null ? void 0 : F.active);
      });
    }
  };
  var _FilterElements = class He {
    static createContainerElement(D) {
      const w2 = document.createElement("div");
      return w2.classList.add("filter-rows-container"), w2.style.order = String(D || 0), w2;
    }
    // the order at which the elements are added is very important - please check the css selectors
    // prettier-ignore
    static createComponent(D, w2, O) {
      var G;
      const x2 = O.position || He.DEFAULT_INPUT_POSITION, U = He.createContainerElement(O.order), F = FilterInternalUtils.addConfig(D, O);
      if (O.dropdown !== false) {
        const X = FilterDropdownElement.create(
          D,
          U,
          x2,
          F,
          (G = O.styles) == null ? void 0 : G.dropdownIcon
        );
        setTimeout(() => U.appendChild(X));
      }
      O.caseButton !== false && FilterInputCaseElement.create(D, U, F, O.styles);
      const W = FilterInputElement.create(F, O, D.data);
      U.appendChild(W), OuterContainerElements.addToContainer(x2, w2, U);
    }
    static create(D, w2) {
      typeof D.filter == "boolean" ? He.createComponent(D, w2, {}) : Array.isArray(D.filter) ? D.filter.forEach((O) => {
        He.createComponent(D, w2, O);
      }) : D.filter && He.createComponent(D, w2, D.filter), setTimeout(() => FilterInternalUtils.resetAllInputs(D));
    }
    static applyStatefulStyles(D, w2, O = {}) {
      const x2 = ElementStyle.generateStatefulCSS(O, w2, { color: "#484848" });
      Object.assign(D.style, x2.default), setTimeout(() => StatefulCSSEvents.setEvents(D, x2, ToggleableElement.ACTIVE_BUTTON_CLASS));
    }
  };
  _FilterElements.DEFAULT_INPUT_POSITION = "top-right";
  var FilterElements = _FilterElements;
  var CALENDAR_ICON_SVG_STRING = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="10px" viewBox="0 0 10 10" version="1.1">
  <g id="surface1">
    <path style=" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;" d="M 1.070312 9.285156 L 8.929688 9.285156 L 8.929688 3.570312 L 1.070312 3.570312 Z M 3.214844 2.5 L 3.214844 0.894531 C 3.214844 0.839844 3.199219 0.796875 3.164062 0.765625 C 3.128906 0.730469 3.085938 0.714844 3.035156 0.714844 L 2.679688 0.714844 C 2.625 0.714844 2.582031 0.730469 2.550781 0.765625 C 2.515625 0.796875 2.5 0.839844 2.5 0.894531 L 2.5 2.5 C 2.5 2.550781 2.515625 2.59375 2.550781 2.628906 C 2.582031 2.660156 2.625 2.679688 2.679688 2.679688 L 3.035156 2.679688 C 3.085938 2.679688 3.128906 2.660156 3.164062 2.628906 C 3.199219 2.59375 3.214844 2.550781 3.214844 2.5 Z M 7.5 2.5 L 7.5 0.894531 C 7.5 0.839844 7.484375 0.796875 7.449219 0.765625 C 7.417969 0.730469 7.375 0.714844 7.320312 0.714844 L 6.964844 0.714844 C 6.914062 0.714844 6.871094 0.730469 6.835938 0.765625 C 6.800781 0.796875 6.785156 0.839844 6.785156 0.894531 L 6.785156 2.5 C 6.785156 2.550781 6.800781 2.59375 6.835938 2.628906 C 6.871094 2.660156 6.914062 2.679688 6.964844 2.679688 L 7.320312 2.679688 C 7.375 2.679688 7.417969 2.660156 7.449219 2.628906 C 7.484375 2.59375 7.5 2.550781 7.5 2.5 Z M 9.644531 2.144531 L 9.644531 9.285156 C 9.644531 9.480469 9.570312 9.648438 9.429688 9.789062 C 9.289062 9.929688 9.121094 10 8.929688 10 L 1.070312 10 C 0.878906 10 0.710938 9.929688 0.570312 9.789062 C 0.429688 9.648438 0.355469 9.480469 0.355469 9.285156 L 0.355469 2.144531 C 0.355469 1.949219 0.429688 1.78125 0.570312 1.640625 C 0.710938 1.5 0.878906 1.429688 1.070312 1.429688 L 1.785156 1.429688 L 1.785156 0.894531 C 1.785156 0.648438 1.875 0.4375 2.046875 0.261719 C 2.222656 0.0859375 2.433594 0 2.679688 0 L 3.035156 0 C 3.28125 0 3.492188 0.0859375 3.667969 0.261719 C 3.839844 0.4375 3.929688 0.648438 3.929688 0.894531 L 3.929688 1.429688 L 6.070312 1.429688 L 6.070312 0.894531 C 6.070312 0.648438 6.160156 0.4375 6.332031 0.261719 C 6.507812 0.0859375 6.71875 0 6.964844 0 L 7.320312 0 C 7.566406 0 7.777344 0.0859375 7.953125 0.261719 C 8.125 0.4375 8.214844 0.648438 8.214844 0.894531 L 8.214844 1.429688 L 8.929688 1.429688 C 9.121094 1.429688 9.289062 1.5 9.429688 1.640625 C 9.570312 1.78125 9.644531 1.949219 9.644531 2.144531 Z M 9.644531 2.144531 "/>
  </g>
</svg>`;
  var _DateCellCalendarIconElement = class je {
    // need a container as mousedown target kept being different parts of svg
    // hence svgIcon has no pointer events
    static createContainer() {
      const D = document.createElement("div");
      return D.classList.add(je.CALENDAR_ICON_CONTAINER_CLASS), D;
    }
    // REF-10
    static createSVGElement() {
      const D = SVGIconUtils.createSVGElement(CALENDAR_ICON_SVG_STRING);
      return D.style.pointerEvents = "none", D.style.height = "25px", D;
    }
    static createSVG() {
      const D = je.createSVGElement(), w2 = je.createContainer();
      return w2.appendChild(D), w2;
    }
    static get() {
      return je.CALENDAR_ICON_ELEMENT.cloneNode(true);
    }
  };
  _DateCellCalendarIconElement.CALENDAR_ICON_CONTAINER_CLASS = "calender-icon-container";
  _DateCellCalendarIconElement.CALENDAR_ICON_ELEMENT = _DateCellCalendarIconElement.createSVG();
  var DateCellCalendarIconElement = _DateCellCalendarIconElement;
  var ColumnDetailsUtils = class _ColumnDetailsUtils {
    static getColumnsByWidth(D) {
      var x2;
      const w2 = [], O = [];
      for (let U = 0; U < D.length; U += 1) {
        const F = D[U];
        ((x2 = F.settings.widths) == null ? void 0 : x2.staticWidth) !== void 0 ? O.push(F) : w2.push(F);
      }
      return { dynamicWidth: w2, staticWidth: O };
    }
    static aggregateItems(D) {
      return D.labelDetails ? Object.keys(D.itemsDetails).map((w2) => ({ name: w2, backgroundColor: D.itemsDetails[w2].backgroundColor })) : Object.keys(D.itemsDetails).map((w2) => ({ name: w2 }));
    }
    static getDetails(D) {
      const w2 = {
        width: D.elements[0].offsetWidth,
        typeName: D.activeType.name
      };
      return D.activeType.cellDropdownProps && (w2.cellDropdownItems = _ColumnDetailsUtils.aggregateItems(D.cellDropdown)), w2;
    }
    static getAllColumnsDetails(D) {
      return D.map((w2) => _ColumnDetailsUtils.getDetails(w2));
    }
  };
  var FireEvents = class {
    // prettier-ignore
    static onCellUpdate(D, w2, O, x2, U) {
      const F = { text: String(w2), rowIndex: O, columnIndex: x2, updateType: U };
      D.onCellUpdate(F), D.dispatchEvent(new CustomEvent("cell-update", { detail: F }));
    }
    static onDataUpdate(D) {
      const w2 = JSON.parse(JSON.stringify(D.data));
      D.onDataUpdate(w2), D.dispatchEvent(new CustomEvent("data-update", { detail: w2 }));
    }
    static onColumnsUpdate(D) {
      const w2 = ColumnDetailsUtils.getAllColumnsDetails(D._columnsDetails);
      D.onColumnsUpdate(w2), D.dispatchEvent(new CustomEvent("columns-update", { detail: w2 }));
    }
    static onRender(D) {
      D.onRender(), D.dispatchEvent(new CustomEvent("render"));
    }
  };
  var StaticTable = class _StaticTable {
    // because we don't set the table width for maxWidth property, its width is made up of columns widths -
    // they don't always add up to a precise expected value, e.g. if expected 500, they can add up to a 498
    // and 499. Hence instead of doing === tableElement.offsetWidth, we do <= tableElement.offsetWidth + 2
    // number 2 seems enough but can increase if this method is returning false in valid scenarios
    static isTableAtMaxWidth(D, w2) {
      return w2.maxWidth !== void 0 && w2.maxWidth <= D.offsetWidth + 2;
    }
    static isStaticTableWidth(D, w2) {
      return w2.width !== void 0 || _StaticTable.isTableAtMaxWidth(D, w2);
    }
  };
  var StaticTableWidthUtils = class _StaticTableWidthUtils {
    // REF-11
    static togglePreserveNarrowColumns(D, w2, O) {
      O || (w2.style.display = D ? "block" : "");
    }
    // when the client has not provided the 'width' value for the table, but a 'maxWidth' is present, need to
    // temporarily set the width at the start in order to help the MaximumColumns class to determine what columns fit
    // prettier-ignore
    static toggleWidthUsingMaxWidth(D, w2) {
      const { _tableElementRef: O, _tableDimensions: { maxWidth: x2, preserveNarrowColumns: U } } = D;
      O && x2 !== void 0 && (O.style.width = w2 ? `${x2}px` : "", _StaticTableWidthUtils.togglePreserveNarrowColumns(w2, O, U));
    }
    // prettier-ignore
    static setTableWidth(D) {
      const { _tableDimensions: { preserveNarrowColumns: w2, width: O }, _tableElementRef: x2 } = D;
      x2 && O !== void 0 && (x2.style.width = `${O}px`, _StaticTableWidthUtils.togglePreserveNarrowColumns(true, x2, w2));
    }
    // This only runs when the table width is set
    // prettier-ignore
    static changeTableWidthForNonDynamicColumns(D, w2, O, x2, U) {
      D.length === 0 || w2.dynamicWidth.length > 0 ? O.offsetWidth !== x2 && (O.style.width = `${x2}px`) : O.style.width = `${U}px`;
    }
    static resetDynamicWidthColumns(D, w2) {
      D.forEach((O) => {
        O.elements[0].style.width = `${w2.newColumnWidth}px`;
      });
    }
    static setNewColumnWidth(D, w2, O) {
      if (w2 > 0) {
        const x2 = D - O.staticWidth;
        O.newColumnWidth = x2 / w2;
      }
    }
    static resetColumnSizes(D, w2, O) {
      const x2 = ColumnDetailsUtils.getColumnsByWidth(D);
      return _StaticTableWidthUtils.setNewColumnWidth(w2, x2.dynamicWidth.length, O), _StaticTableWidthUtils.resetDynamicWidthColumns(x2.dynamicWidth, O), x2;
    }
    static changeWidthsBasedOnColumnInsertRemove(D, w2) {
      const { _tableElementRef: O, _tableDimensions: x2, _columnsDetails: U } = D;
      if (!O)
        return;
      const { width: F, maxWidth: W, staticWidth: G } = x2;
      if (F !== void 0) {
        const X = _StaticTableWidthUtils.resetColumnSizes(U, F, x2);
        _StaticTableWidthUtils.changeTableWidthForNonDynamicColumns(U, X, O, F, G);
      } else
        w2 && StaticTable.isTableAtMaxWidth(O, x2) && _StaticTableWidthUtils.resetColumnSizes(U, W, x2);
      setTimeout(() => FireEvents.onColumnsUpdate(D));
    }
  };
  var ConvertCellTypeUtils = class {
    static preprocessCell(D) {
      D.style.cursor = "";
    }
  };
  var CellStructureUtils = class {
    static setColumn(D, w2, O, x2) {
      const { elements: U } = D._columnsDetails[w2];
      U.slice(1).forEach((F, W) => {
        const G = W + 1;
        O(D, F, w2, G), D._columnsDetails[w2].settings.isCellTextEditable && x2(D, F, G, w2);
      });
    }
  };
  var FocusedCellUtils = class {
    static createEmpty() {
      return {};
    }
    static setHeaderCell(D, w2, O) {
      D.element = w2, D.rowIndex = 0, D.columnIndex = O;
    }
    static setIndexCell(D, w2, O) {
      D.element = w2, D.rowIndex = O, delete D.columnIndex;
    }
    static set(D, w2, O, x2) {
      D.element = w2, D.rowIndex = O, D.columnIndex = x2;
    }
    static incrementColumnIndex(D, w2) {
      D.columnIndex !== void 0 && w2 <= D.columnIndex && (D.columnIndex += 1);
    }
    static purge(D) {
      delete D.columnIndex, delete D.element, delete D.rowIndex;
    }
  };
  var KEYBOARD_KEY = /* @__PURE__ */ ((Y) => (Y.ESCAPE = "Escape", Y.ENTER = "Enter", Y.TAB = "Tab", Y.ARROW_UP = "ArrowUp", Y.ARROW_DOWN = "ArrowDown", Y.ARROW_RIGHT = "ArrowRight", Y.ARROW_LEFT = "ArrowLeft", Y))(KEYBOARD_KEY || {});
  var _Browser = class {
    // can't use DateCellInputElement class as this is called before CellElement class can be used
    static createDateInput() {
      const D = document.createElement("input");
      return D.type = "date", D;
    }
    static createColorInput() {
      const D = document.createElement("input");
      return D.type = "color", D;
    }
  };
  _Browser.IS_FIREFOX = navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
  _Browser.IS_SAFARI = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  _Browser.IS_CHROMIUM = window.chrome;
  _Browser.IS_INPUT_DATE_SUPPORTED = _Browser.createDateInput().type === "date" && "showPicker" in HTMLInputElement.prototype;
  _Browser.IS_COLOR_PICKER_SUPPORTED = _Browser.createColorInput().type === "color" && "showPicker" in HTMLInputElement.prototype;
  var Browser = _Browser;
  var ColumnSettingsStyleUtils = class _ColumnSettingsStyleUtils {
    static applySettingsStyleOnCell(D, w2, O) {
      var x2;
      Object.assign(w2.style, D.cellStyle || {}, O ? ((x2 = D.headerStyles) == null ? void 0 : x2.default) || {} : {});
    }
    // prettier-ignore
    static setNewHeaderStyle(D, w2) {
      var W;
      const { settings: O, elements: x2 } = w2, U = O.cellStyle || ((W = O.headerStyles) == null ? void 0 : W.default);
      U && _ColumnSettingsStyleUtils.applySettingsStyleOnCell(O, x2[0], true);
      const F = U ? O : void 0;
      w2.headerStateColors = ColumnDetails.createHeaderStateColors(
        D._defaultColumnsSettings,
        F,
        D._defaultCellHoverColors
      ), ColumnSettingsBorderUtils.overwriteSideBorderIfSiblingsHaveSettings(w2, [x2[0]]);
    }
    static unsetHeaderSettingStyle(D, w2) {
      Object.keys(w2).forEach((O) => {
        ElementStyle.setStyle(D, O, "");
      });
    }
    // prettier-ignore
    static resetHeaderStyleToDefault(D, w2, O) {
      var F;
      (F = w2.headerStyles) != null && F.default && _ColumnSettingsStyleUtils.unsetHeaderSettingStyle(D[0], w2.headerStyles.default), w2.cellStyle && ElementStyle.unsetStyle(D[0], w2.cellStyle);
      const { cellStyle: x2, headerStyles: U } = O;
      CellElement.setDefaultCellStyle(D[0], x2, U == null ? void 0 : U.default);
    }
    // prettier-ignore
    static changeHeaderStyleFunc(D, w2) {
      var G, X, K;
      const O = this._columnsDetails[D], { elements: x2, settings: { isHeaderTextEditable: U } } = O;
      _ColumnSettingsStyleUtils.resetHeaderStyleToDefault(x2, w2, this._defaultColumnsSettings), _ColumnSettingsStyleUtils.setNewHeaderStyle(this, O);
      const F = (K = (X = (G = this._defaultColumnsSettings.columnDropdown) == null ? void 0 : G.displaySettings) == null ? void 0 : X.openMethod) == null ? void 0 : K.cellClick, W = !F && U;
      CellElement.prepContentEditable(
        CellElement.getTextElement(x2[0]),
        !!W,
        F
      );
    }
    // prettier-ignore
    static changeStyleFunc(D, w2, O) {
      ProcessedDataTextStyle.resetDataCellsStyle(
        D,
        w2,
        _ColumnSettingsStyleUtils.changeHeaderStyleFunc.bind(D, w2, O),
        O.cellStyle
      );
    }
    static doStylesHaveVisibleDimension(D, w2) {
      for (let O = 0; O < w2.length; O += 1) {
        const x2 = D[w2[O]];
        if (x2) {
          const U = RegexUtils.extractIntegerStrs(String(x2));
          if (U.length > 0 && Number(U[0]) > 0)
            return true;
        }
      }
      return false;
    }
    // REF-23
    // prettier-ignore
    static doesSettingHaveSideBorderStyle(D) {
      var O;
      const w2 = D.cellStyle || ((O = D.headerStyles) == null ? void 0 : O.default);
      return w2 ? _ColumnSettingsStyleUtils.doStylesHaveVisibleDimension(
        w2,
        ["border", "borderLeft", "borderLeftWidth", "borderRight", "borderRightWidth"]
      ) : false;
    }
  };
  var ResetColumnStyles = class _ResetColumnStyles {
    static applyDefaultStyles(D, w2) {
      const { cellStyle: O, headerStyles: x2 } = w2;
      CellElement.setDefaultCellStyle(D[0], O, x2 == null ? void 0 : x2.default), D.slice(1).forEach((U) => {
        CellElement.setDefaultCellStyle(U, O);
      });
    }
    static unsetLastAppliedStyle(D, w2) {
      Object.keys(D.lastAppliedStyle).forEach((O) => {
        ElementStyle.setStyle(w2, O, "");
      });
    }
    // if this operation turns out to be expensive - try to save and reuse the default style
    // prettier-ignore
    static setDefaultStyle(D, w2, O, x2, U) {
      _ResetColumnStyles.unsetLastAppliedStyle(w2, O), U && ElementStyle.unsetStyle(O, U), CellElement.setDefaultCellStyle(O, x2.cellStyle), ColumnSettingsStyleUtils.applySettingsStyleOnCell(D.settings, O, false);
    }
  };
  var _ProcessedDataTextStyle = class Ae {
    // prettier-ignore
    static setCustomStyle(D, w2, O, x2, U, F, W) {
      if (D) {
        ResetColumnStyles.setDefaultStyle(O, U, F, W);
        const G = D(String(w2), x2);
        Object.assign(F.style, G), U.lastAppliedStyle = G, ColumnSettingsBorderUtils.overwriteSideBorderIfSiblingsHaveSettings(O, [F]);
      }
    }
    // prettier-ignore
    static setFailedValidationStyle(D, w2, O) {
      const { textValidation: x2 } = D.activeType, U = x2.failedStyle || Ae.DEFAULT_FAILED_VALIDATION_STYLE;
      Object.assign(O.style, U), w2.lastAppliedStyle = U;
    }
    // prettier-ignore
    static setStyle(D, w2, O, x2, U, F) {
      let W = false;
      return D ? x2 != null && x2.changeStyleFunc || (ResetColumnStyles.setDefaultStyle(w2, O, U, F), O.lastAppliedStyle = {}, W = true) : (x2 != null && x2.changeStyleFunc && ResetColumnStyles.setDefaultStyle(w2, O, U, F), Ae.setFailedValidationStyle(w2, O, U), W = true), W && ColumnSettingsBorderUtils.overwriteSideBorderIfSiblingsHaveSettings(w2, [U]), W;
    }
    // prettier-ignore
    static setCellStyle(D, w2, O, x2 = false) {
      const U = D._columnsDetails[O], F = U.elements[w2], W = U.processedStyle[w2], G = CellElement.getText(F), { textValidation: { func: X }, customTextProcessing: K } = U.activeType;
      let q = false;
      if (X) {
        const Q = X(G);
        (x2 || W.isValid !== Q) && (q = Ae.setStyle(
          Q,
          U,
          W,
          K,
          F,
          D._defaultColumnsSettings
        ), W.isValid = Q);
      }
      !q && (K != null && K.changeStyleFunc) && Ae.setCustomStyle(
        K.changeStyleFunc,
        G,
        U,
        w2,
        W,
        F,
        D._defaultColumnsSettings
      );
    }
    static setStyleOnColumn(D, w2) {
      const O = D._columnsDetails[w2];
      O.elements.slice(1).forEach((x2, U) => {
        const F = U + 1;
        Ae.setCellStyle(D, F, w2, true), ColumnSettingsBorderUtils.overwriteSideBorderIfSiblingsHaveSettings(O, [x2]);
      });
    }
    static unsetStyleOnColumn(D, w2, O) {
      const x2 = D._columnsDetails[w2];
      x2.elements.slice(1).forEach((U, F) => {
        const W = F + 1, G = x2.processedStyle[W];
        ResetColumnStyles.setDefaultStyle(x2, G, U, D._defaultColumnsSettings, O);
      });
    }
    // using this to first unset the previous processed style, allow new settings/type to be applied and then set
    // new style
    // prettier-ignore
    static resetDataCellsStyle(D, w2, O, x2) {
      Ae.unsetStyleOnColumn(D, w2, x2), O(), Ae.setStyleOnColumn(D, w2);
    }
    // prettier-ignore
    // this is used for a case where the default style has been set and need to reapply the processed style
    // without having to rerun the validation/changeStyleFunc functions
    static reapplyCellsStyle(D, w2) {
      const O = D._columnsDetails[w2], { textValidation: { func: x2 }, customTextProcessing: U } = O.activeType;
      (x2 || U != null && U.changeStyleFunc) && O.elements.slice(1).forEach((F, W) => {
        const G = W + 1;
        Object.assign(F.style, O.processedStyle[G].lastAppliedStyle);
      });
    }
    static getDefaultProcessedTextStyle() {
      return { isValid: true, lastAppliedStyle: {} };
    }
  };
  _ProcessedDataTextStyle.DEFAULT_FAILED_VALIDATION_STYLE = { color: "grey" };
  var ProcessedDataTextStyle = _ProcessedDataTextStyle;
  var NumberOfIdenticalCells = class {
    // columnsDetails instead of row from data because during startup - data is already be populated and
    // not yet added to the table, hence we are automatically marking headers as duplicate and setting them
    // to default, however the end headers that are not duplicate may not be displayed due to max columns,
    // hence using columnsDetails to mark duplicates as headers are added instead
    // prettier-ignore
    static get(D, w2) {
      return w2.map((O) => O.elements.length > 0 ? CellElement.getText(O.elements[0]) : "").filter((O) => O === D).length;
    }
  };
  var EMPTY_STRING = "";
  var DataUtils = class _DataUtils {
    static createEmptyStringDataArray(D) {
      return new Array(D).fill(EMPTY_STRING);
    }
    static isTextEmpty(D, w2) {
      return D !== EMPTY_STRING ? (typeof w2 == "string" ? w2.trim() : w2) === EMPTY_STRING : false;
    }
    // note that NumberOfIdenticalCells.get uses the at.data top row, so it needs to be up-to-date
    // prettier-ignore
    static shouldBeSetToDefault(D, w2, O, x2, U) {
      const { allowDuplicateHeaders: F, _columnsDetails: W } = D;
      return _DataUtils.isTextEmpty(O, w2) || x2 === 0 && !F && NumberOfIdenticalCells.get(w2, W) > 1 || x2 > 0 && !(U.func === void 0 || U.func(String(w2)));
    }
    // prettier-ignore
    static processCellText(D, w2, O, x2) {
      let U = typeof x2 == "string" ? x2.trim() : x2;
      const F = D._columnsDetails[O];
      if (!F)
        return U;
      const { activeType: { textValidation: W, customTextProcessing: G }, settings: { defaultText: X } } = F;
      return w2 > 0 && (G != null && G.changeTextFunc && (U = G.changeTextFunc(String(U), w2)), !W.setTextToDefaultOnFail && U !== EMPTY_STRING) ? U : _DataUtils.shouldBeSetToDefault(D, U, X, w2, W) ? X : U;
    }
  };
  var CELL_UPDATE_TYPE = /* @__PURE__ */ ((Y) => (Y.UPDATE = "Update", Y.ADD = "Add", Y.REMOVED = "Removed", Y))(CELL_UPDATE_TYPE || {});
  var CellEvents = class _CellEvents {
    static executeUpdateOperation(D, w2) {
      return (w2 == null ? void 0 : w2[D]) === void 0 || w2[D] === true;
    }
    // this is directly handled by operations that do not insert new cells as those handle the instructions below
    // in a different order asynchronously for maximum efficiency
    // prettier-ignore
    static updateCell(D, w2, O, x2, U) {
      return _CellEvents.executeUpdateOperation("processText", U) && (w2 = DataUtils.processCellText(D, O, x2, w2)), _CellEvents.executeUpdateOperation("updateData", U) && (D.data[O][x2] = w2), U != null && U.element && CellElement.setNewText(D, U.element, w2, false, false), _CellEvents.executeUpdateOperation("updateTableEvent", U) && D.onDataUpdate(D.data), O > 0 && ProcessedDataTextStyle.setCellStyle(D, O, x2), _CellEvents.executeUpdateOperation("updateCellEvent", U) && FireEvents.onCellUpdate(D, w2, O, x2, CELL_UPDATE_TYPE.UPDATE), w2;
    }
    // this is used for cases where updateCell should only be called if it has to be set to default
    // prettier-ignore
    static setCellToDefaultIfNeeded(D, w2, O, x2, U = true) {
      const F = CellElement.getText(x2), W = DataUtils.processCellText(D, w2, O, F);
      return W !== F ? (_CellEvents.updateCell(
        D,
        W,
        w2,
        O,
        { element: x2, processText: false, updateTableEvent: U }
      ), true) : false;
    }
    // prettier-ignore
    static removeTextIfDefault(D, w2, O, x2) {
      const { isDefaultTextRemovable: U, defaultText: F } = D._columnsDetails[O].settings;
      U && F !== EMPTY_STRING && F === CellElement.getText(x2) && _CellEvents.updateCell(
        D,
        EMPTY_STRING,
        w2,
        O,
        { element: x2, processText: false }
      );
    }
  };
  var CheckboxEvents = class _CheckboxEvents {
    // REF-29
    static focusCheckbox(D, w2, O) {
      Browser.IS_SAFARI || FocusedCellUtils.set(this._focusedElements.cell, D, w2, O);
    }
    // REF-29
    static blurCheckbox() {
      Browser.IS_SAFARI || FocusedCellUtils.purge(this._focusedElements.cell);
    }
    static changeValueCheckbox(D, w2, O) {
      const x2 = O.target;
      CellEvents.updateCell(this, String(x2.checked), D, w2, { processText: false });
    }
    static keyDownCheckbox(D) {
      D.key === KEYBOARD_KEY.ENTER && D.target.click();
    }
    static setEvents(D, w2, O, x2) {
      w2.onkeydown = _CheckboxEvents.keyDownCheckbox, w2.onchange = _CheckboxEvents.changeValueCheckbox.bind(D, O, x2), w2.onfocus = _CheckboxEvents.focusCheckbox.bind(D, w2, O, x2), w2.onblur = _CheckboxEvents.blurCheckbox.bind(D);
    }
  };
  var CheckboxCellEvents = class _CheckboxCellEvents {
    static mouseDownCell(D) {
      const w2 = D.target;
      w2.classList.contains(CellElement.CELL_CLASS) && w2.children[0].click();
    }
    // REF-29
    static focusCell(D) {
      D.target.children[0].focus();
    }
    static setEvents(D, w2, O, x2) {
      if (!D._columnsDetails[x2].settings.isCellTextEditable)
        return;
      w2.onblur = () => {
      }, w2.onfocus = _CheckboxCellEvents.focusCell, w2.onmouseenter = () => {
      }, w2.onmouseleave = () => {
      }, w2.oninput = () => {
      }, w2.onmousedown = _CheckboxCellEvents.mouseDownCell.bind(D);
      const U = CheckboxCellElement.getCheckboxElement(w2);
      CheckboxEvents.setEvents(D, U, O, x2);
    }
  };
  var CheckboxElement = class _CheckboxElement {
    static createCheckbox(D) {
      const w2 = document.createElement("input");
      return w2.type = "checkbox", w2.style.cursor = D ? "pointer" : "auto", w2.style.pointerEvents = D ? "" : "none", w2;
    }
    static setCellTextAsCheckbox(D, w2) {
      const O = _CheckboxElement.createCheckbox(w2);
      D.replaceChildren(O);
    }
  };
  var CheckboxCellElement = class _CheckboxCellElement {
    static isCheckbox(D) {
      return (D == null ? void 0 : D.type) === "checkbox";
    }
    static isCheckboxCell(D) {
      return _CheckboxCellElement.isCheckbox(D.children[0]);
    }
    static getCheckboxElement(D) {
      if (_CheckboxCellElement.isCheckboxCell(D))
        return D.children[0];
      if (_CheckboxCellElement.isCheckbox(D))
        return D;
    }
    static getValue(D) {
      const w2 = _CheckboxCellElement.getCheckboxElement(D);
      if (w2)
        return String(w2.checked);
    }
    static setValue(D, w2) {
      const O = _CheckboxCellElement.getCheckboxElement(D);
      return O ? (O.checked = w2 === "true", true) : false;
    }
    // prettier-ignore
    static setCellTextAsAnElement(D, w2, O, x2) {
      const { settings: { isCellTextEditable: U } } = D._columnsDetails[x2], F = CellElement.getText(w2);
      CheckboxElement.setCellTextAsCheckbox(w2, U), w2.contentEditable = "false", w2.style.cursor = U ? "pointer" : "default", CellEvents.updateCell(D, F, O, x2, { element: w2 });
    }
    // prettier-ignore
    static setCellCheckboxStructure(D, w2, O, x2) {
      ConvertCellTypeUtils.preprocessCell(w2), _CheckboxCellElement.setCellTextAsAnElement(D, w2, x2, O);
    }
    // prettier-ignore
    static setColumnCheckboxStructure(D, w2) {
      CellStructureUtils.setColumn(
        D,
        w2,
        _CheckboxCellElement.setCellCheckboxStructure,
        CheckboxCellEvents.setEvents
      );
    }
  };
  var CaretPosition = class _CaretPosition {
    static setSelectionToEndOfText(D, w2) {
      const O = CellElement.getTextElement(D), x2 = document.createRange();
      x2.setStart(O.childNodes[0], CellElement.getText(O).length || 0), x2.collapse(true), w2.removeAllRanges(), w2.addRange(x2);
    }
    static getSelection(D) {
      var x2;
      const w2 = D.shadowRoot;
      return w2.getSelection ? w2.getSelection() : ((x2 = window.document.activeElement) == null ? void 0 : x2.shadowRoot) === w2 ? window.document.getSelection() : null;
    }
    static setToEndOfText(D, w2) {
      if (CheckboxCellElement.isCheckboxCell(w2))
        return;
      let O = _CaretPosition.getSelection(D);
      Browser.IS_SAFARI && !O && (w2.focus(), O = _CaretPosition.getSelection(D)), O && _CaretPosition.setSelectionToEndOfText(w2, O);
    }
  };
  var ArrayUtils = class {
    static transpose(D) {
      if (D.length === 0)
        return D;
      const w2 = [], O = Math.max(D.length, D[0].length);
      e:
        for (let x2 = 0; x2 < O; x2 += 1) {
          const U = [];
          for (let F = 0; F < O && D[F] !== void 0; F += 1) {
            if (D[F][x2] === void 0)
              break e;
            U.push(D[F][x2]);
          }
          w2.push(U);
        }
      return w2;
    }
    static shuffle(D) {
      return D.sort(() => Math.random() - 0.5);
    }
    static swap(D, w2, O) {
      const x2 = D[w2];
      D[w2] = D[O], D[O] = x2;
    }
  };
  var _LabelColorUtils = class Be {
    static generateNewPasteleColor() {
      return `hsl(${Math.floor(Math.random() * 360)}, 95%, 90%)`;
    }
    static setNewLatestPasteleColor() {
      Be.LATEST_PASTELE_COLOR = Be.generateNewPasteleColor();
    }
    static getLatestPasteleColor() {
      return Be.LATEST_PASTELE_COLOR;
    }
    static getLatestPasteleColorAndSetNew() {
      const D = Be.getLatestPasteleColor();
      return Be.setNewLatestPasteleColor(), D;
    }
    // REF-34
    // these colors are used before the above
    static generateDefaultColors() {
      return ArrayUtils.shuffle([
        "hsl(154deg 96% 90%)",
        "hsl(50deg 96% 90%)",
        "hsl(171deg 96% 90%)",
        "hsl(76deg 96% 90%)",
        "hsl(315deg 96% 90%)",
        "hsl(251deg 96% 90%)",
        "hsl(209deg 84% 92%)",
        "hsl(0deg 100% 81%)",
        "hsl(29deg 100% 79%)",
        "hsl(31deg 73% 75%)",
        "hsl(137deg 80% 80%)",
        "hsl(60deg 100% 82%)",
        "hsl(219deg 100% 84%)",
        "hsl(93deg 62% 74%)",
        "hsl(54deg 93% 84%)",
        "hsl(146deg 100% 90%)",
        "hsl(334deg 100% 87%)",
        "hsl(19deg 95% 84%)",
        "hsl(203deg 95% 84%)",
        "hsl(76deg 100% 78%)",
        "hsl(0deg 100% 86%)",
        "hsl(42deg 82% 82%)",
        "hsl(97deg 100% 87%)"
      ]);
    }
    // this is a solution for same label text across different columns to have the same colors
    static generateGlobalItemColors() {
      return {
        newColors: Be.generateDefaultColors(),
        existingColors: {}
      };
    }
  };
  _LabelColorUtils.LATEST_PASTELE_COLOR = _LabelColorUtils.generateNewPasteleColor();
  var LabelColorUtils = _LabelColorUtils;
  var ScrollbarUtils = class {
    static isVerticalPresent(D) {
      return D.scrollHeight > D.clientHeight;
    }
    static isHorizontalPresent(D) {
      return D.scrollWidth > D.clientWidth;
    }
  };
  var _CellDropdownHorizontalScrollFix = class lt {
    static setPropertiesIfHorizontalScrollPresent(D) {
      const { element: w2, scrollbarPresence: O, customDropdownStyle: x2 } = D;
      ScrollbarUtils.isHorizontalPresent(w2) && ScrollbarUtils.isVerticalPresent(w2) ? (O.horizontal = true, w2.style.paddingBottom = lt.NEW_BOTTOM_PADDING_IF_PRESENT) : (O.horizontal = false, w2.style.paddingBottom = (x2 == null ? void 0 : x2.paddingBottom) || Dropdown.DROPDOWN_VERTICAL_PX);
    }
    static scrollDownFurther(D) {
      D.scrollTop += lt.SCROLL_FURTHER_BOTTOM_PX;
    }
  };
  _CellDropdownHorizontalScrollFix.NEW_BOTTOM_PADDING_IF_PRESENT = "8px";
  _CellDropdownHorizontalScrollFix.SCROLL_FURTHER_BOTTOM_PX = 14;
  var CellDropdownHorizontalScrollFix = _CellDropdownHorizontalScrollFix;
  var _RGBAToHex = class rt {
    static extractIndividualNumbers(D) {
      return D.match(rt.REGEX);
    }
    static convert(D) {
      return `#${rt.extractIndividualNumbers(D).slice(1).map(
        (w2, O) => (O === 3 ? Math.round(parseFloat(w2) * 255) : parseFloat(w2)).toString(16).padStart(2, "0").replace("NaN", "")
      ).join("")}`;
    }
  };
  _RGBAToHex.REGEX = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+\.{0,1}\d*))?\)$/;
  var RGBAToHex = _RGBAToHex;
  var _OptionColorButton = class we {
    // buttonLevelElement is either input or button
    static extractRelativeParentElements(D) {
      var U;
      const w2 = D.parentElement, O = (U = w2.previousSibling) == null ? void 0 : U.previousSibling, x2 = w2.parentElement;
      return { containerElement: w2, textElement: O, dropdownItemElement: x2 };
    }
    static changeVisibility(D, w2, O) {
      const x2 = D.children[2];
      if (x2.style.display = O ? "block" : "none", O) {
        const U = x2.children[0], F = Browser.IS_SAFARI ? 9 : 5;
        U.style.left = `${O.offsetWidth - w2 + F}px`;
        const W = x2.children[1];
        W.style.left = `${O.offsetWidth - w2}px`;
      }
    }
    static createIcon() {
      const D = document.createElement("div");
      return D.innerText = we.COLOR_ICON_TEXT, D.classList.add(we.COLOR_BUTTON_ICON_CLASS), D;
    }
    static createButton() {
      const D = document.createElement("div");
      D.classList.add(OptionButton.BUTTON_CLASS, we.COLOR_BUTTON_CLASS);
      const w2 = we.createIcon();
      return D.appendChild(w2), D;
    }
    static createInput() {
      const D = document.createElement("input");
      return D.type = "color", D.style.top = Browser.IS_SAFARI ? "0px" : "14px", D.classList.add(we.COLOR_INPUT_CLASS), D;
    }
    static createContainer() {
      const D = document.createElement("div");
      return D.classList.add(OptionButton.BUTTON_CONTAINER_CLASS), D;
    }
    static create(D, w2) {
      const O = we.createContainer(), x2 = we.createInput();
      O.appendChild(x2);
      const U = we.createButton();
      return O.appendChild(U), OptionColorButtonEvents.setEvents(O, x2, D, w2), O;
    }
  };
  _OptionColorButton.COLOR_INPUT_CLASS = "color-input";
  _OptionColorButton.COLOR_BUTTON_CLASS = "option-color-button";
  _OptionColorButton.COLOR_BUTTON_ICON_CLASS = "cell-dropdown-option-color-button-icon";
  _OptionColorButton.COLOR_ICON_TEXT = "c";
  var OptionColorButton = _OptionColorButton;
  var OptionColorButtonEvents = class _OptionColorButtonEvents {
    static updateCellElements(D, w2) {
      const { itemText: O, backgroundColor: x2 } = w2;
      D.elements.slice(1).forEach((U) => {
        const F = U.children[0];
        F.innerText === O && (F.style.backgroundColor = x2);
      });
    }
    // prettier-ignore
    static updateIfUpdatable(D, w2, O) {
      const { itemText: x2, backgroundColor: U } = O, F = D.cellDropdown.itemsDetails[x2];
      F && (!F.isCustomBackgroundColor || w2 === D.activeType.name) && (F.backgroundColor = U, _OptionColorButtonEvents.updateCellElements(D, O));
    }
    // prettier-ignore
    static updateElements(D, w2, O) {
      D.forEach((x2) => {
        x2.cellDropdown.labelDetails && _OptionColorButtonEvents.updateIfUpdatable(x2, w2, O);
      });
    }
    static updateColorStates(D, w2) {
      var F, W, G;
      const { itemText: O, backgroundColor: x2 } = w2;
      (W = (F = D.activeType.cellDropdownProps) == null ? void 0 : F.options) == null || W.forEach((X) => {
        X.text === O && (X.backgroundColor = x2);
      });
      const U = (G = D.cellDropdown.labelDetails) == null ? void 0 : G.globalItemColors.existingColors;
      U != null && U[O] && (U[O] = x2);
    }
    // prettier-ignore
    static updateColumnLabelColors(D, w2) {
      const { cellDropdown: { labelDetails: O }, activeType: x2 } = w2;
      !O || !O.colorPickerNewValue || (_OptionColorButtonEvents.updateColorStates(w2, O.colorPickerNewValue), _OptionColorButtonEvents.updateElements(D, x2.name, O.colorPickerNewValue), delete O.colorPickerNewValue, setTimeout(() => w2.fireColumnsUpdate()));
    }
    // important to note that mouse/key down events are not fired when clicked on picker
    static windowEventClosePicker(D, w2) {
      if (w2.cellDropdown) {
        const O = w2.cell.columnIndex;
        OptionButton.hideAfterColorPickerContainerClose(D, D[O]);
      }
    }
    // bug fix comments are for code that fixes a firefox bug where color picker is still open after closing the dropdown
    static inputEvent(D, w2) {
      if (!Dropdown.isDisplayed(D.element))
        return;
      const O = w2.target, { containerElement: x2, textElement: U, dropdownItemElement: F } = OptionColorButton.extractRelativeParentElements(O), W = U.textContent, G = O.value;
      F.style.backgroundColor = G;
      const X = D.itemsDetails[W];
      X.backgroundColor !== G && (X.backgroundColor = G, D.labelDetails.colorPickerNewValue = { backgroundColor: G, itemText: W }, setTimeout(() => {
        var K;
        (K = D.labelDetails).colorPickerContainer ?? (K.colorPickerContainer = x2);
      }));
    }
    // prettier-ignore
    static mouseDownContainer(D, w2, O) {
      const { cellDropdown: { labelDetails: x2 } } = w2;
      if (!x2)
        return;
      if (x2.colorPickerContainer) {
        delete x2.colorPickerContainer, _OptionColorButtonEvents.updateColumnLabelColors(D, w2);
        return;
      }
      const U = O.target, { containerElement: F, dropdownItemElement: W } = OptionColorButton.extractRelativeParentElements(U), G = U.previousSibling;
      G.value = RGBAToHex.convert(getComputedStyle(W).backgroundColor), G.showPicker(), setTimeout(() => x2.colorPickerContainer = F);
    }
    // prettier-ignore
    static setEvents(D, w2, O, x2) {
      D.onmousedown = _OptionColorButtonEvents.mouseDownContainer.bind(this, O, x2), w2.oninput = _OptionColorButtonEvents.inputEvent.bind(this, x2.cellDropdown);
    }
  };
  var FocusNextRowCell = class {
    // does not work in Safari
    static focus(D, w2, O, x2) {
      x2.preventDefault();
      const U = O[w2 + 1];
      U && (U.focus(), CaretPosition.setToEndOfText(D, U));
    }
    static focusOrBlurSelect(D, w2) {
      const O = D[w2 + 1];
      if (O)
        return O.dispatchEvent(new Event("mousedown")), O.scrollIntoView({ block: "nearest" }), O;
      D[w2].children[0].blur();
    }
  };
  var ARROW_DOWN_ICON_SVG_STRING = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="12" height="12">
  <g style="pointer-events: none" transform="matrix(0.6315789 0 0 0.6315789 0 0)">
    <g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
      <path d="M0 87.5L350 507.5L700 87.5L0 87.5z" stroke="none" fill="#3e3e3e" fill-rule="nonzero" />
    </g>
  </g>
</svg>
`;
  var _ArrowDownIconElement = class Ve {
    static toggle(D, w2) {
      if (!D)
        return;
      const O = D.children[1];
      O.style.display = w2 ? "block" : "none";
      const x2 = O.children[0];
      !w2 && x2.style.filter && (x2.style.filter = "");
    }
    static setActive(D) {
      const w2 = D.children[1].children[0];
      w2.style.filter = `brightness(0) saturate(100%) invert(24%) sepia(73%) saturate(631%)
      hue-rotate(171deg) brightness(98%) contrast(98%)`;
    }
    // need a container to allow absolute positioning for the icon
    static createContainer() {
      const D = document.createElement("div");
      return D.classList.add(Ve.ARROW_ICON_CONTAINER_CLASS), D.style.display = "none", D;
    }
    // REF-10
    static createSVGElement() {
      const D = SVGIconUtils.createSVGElement(ARROW_DOWN_ICON_SVG_STRING);
      return D.classList.add(Ve.ARROW_ICON_CLASS), D;
    }
    static createSVG() {
      const D = Ve.createSVGElement(), w2 = Ve.createContainer();
      return w2.appendChild(D), w2;
    }
    static get() {
      return Ve.ARROW_ICON_ELEMENT.cloneNode(true);
    }
  };
  _ArrowDownIconElement.ARROW_ICON_CLASS = "arrow-down-icon";
  _ArrowDownIconElement.ARROW_ICON_CONTAINER_CLASS = "arrow-down-icon-container";
  _ArrowDownIconElement.ARROW_ICON_ELEMENT = _ArrowDownIconElement.createSVG();
  var ArrowDownIconElement = _ArrowDownIconElement;
  var TableBorderDimensionsUtils = class _TableBorderDimensionsUtils {
    static generateDefault() {
      return {
        leftWidth: 0,
        rightWidth: 0,
        topWidth: 0,
        bottomWidth: 0
      };
    }
    static getWidth(D, w2) {
      return D.style[w2] === "" ? 1 : Number.parseFloat(D.style[w2]) || 0;
    }
    static generateUsingElement(D) {
      return {
        leftWidth: _TableBorderDimensionsUtils.getWidth(D, "borderLeftWidth"),
        rightWidth: _TableBorderDimensionsUtils.getWidth(D, "borderRightWidth"),
        topWidth: _TableBorderDimensionsUtils.getWidth(D, "borderTopWidth"),
        bottomWidth: _TableBorderDimensionsUtils.getWidth(D, "borderBottomWidth")
      };
    }
  };
  var _UpdateIndexColumnWidth = class te {
    static wrapColumnTextAndGetDefaultWidth(D) {
      const { _tableBodyElementRef: w2, data: O, _tableDimensions: x2 } = D;
      return ExtractElements.textRowsArrFromTBody(w2, O).forEach((U) => {
        U.children[0].classList.remove(IndexColumn.INDEX_CELL_OVERFLOW_CLASS);
      }), x2.isColumnIndexCellTextWrapped = true, ToggleAdditionElements.update(D, true, AddNewColumnElement.toggle), IndexColumn.DEFAULT_WIDTH;
    }
    static changeTableWidths(D, w2) {
      const O = w2 - D._tableDimensions.indexColumnWidth;
      D._tableDimensions.indexColumnWidth = w2, TableElement.changeStaticWidthTotal(D._tableDimensions, O), StaticTableWidthUtils.changeWidthsBasedOnColumnInsertRemove(D, true);
    }
    static changeCellAndTableWidths(D, w2, O) {
      const x2 = w2.children[0];
      te.changeTableWidths(D, O), x2.style.width = `${O}px`;
    }
    static forceWrap(D, w2) {
      const O = te.wrapColumnTextAndGetDefaultWidth(D);
      te.changeCellAndTableWidths(D, w2, O);
    }
    static shouldTextBeWrapped(D) {
      return !D._tableDimensions.isColumnIndexCellTextWrapped && TableDimensionsUtils.hasSetTableWidthBeenBreached(D);
    }
    static changeWidth(D, w2, O) {
      te.changeCellAndTableWidths(D, w2, O), te.shouldTextBeWrapped(D) && te.forceWrap(D, w2);
    }
    // important to note that on initial render if the font library has not been downloaded
    // scrollWidth will give the wrong number. This is usually not a problem when using
    // small numbers or cache
    static getCellWidth(D) {
      return D.scrollWidth + (Number.parseInt(getComputedStyle(D).borderRightWidth) || 0);
    }
    // need to keep track of first cell because upon using pagination and uploading a new file, drag and droping a new file,
    // or using updateData method with a lot of data does not refresh the cell with original value
    // to reproduce the error, simply set the code in timeout to: firstCell.textContent = firstCellContent
    static temporarilySetFirstRowCellWithLastNumber(D, w2, O) {
      const x2 = D.textContent;
      D.id || (D.id = w2 ? te.TEMPORARY_INDEX_NUMBER : te.TEMPORARY_INVISIBLE_INDEX_NUMBER), D.textContent = O.textContent, setTimeout(() => {
        D.id !== "" && (D.textContent = x2, D.removeAttribute("id"));
      });
    }
    static getIndexColumnWidthWithAsyncFix(D, w2, O) {
      if (O.scrollWidth === 0) {
        const x2 = D.children[0];
        return te.temporarilySetFirstRowCellWithLastNumber(x2, w2, O), te.getCellWidth(x2);
      }
      return te.getCellWidth(O);
    }
    // this works because the 'block' display style is not set on the table
    // checking if the cells width is overflown and if so - increase its width (cannot decrease the width)
    static updateColumnWidthWhenOverflow(D, w2, O) {
      const x2 = !!D.dataStartsAtHeader, U = te.getIndexColumnWidthWithAsyncFix(w2, x2, O);
      if (D._tableDimensions.indexColumnWidth !== U && U !== 0) {
        const F = U + (Browser.IS_FIREFOX ? 4 : 0);
        Browser.IS_SAFARI ? setTimeout(() => te.changeWidth(D, w2, F)) : te.changeWidth(D, w2, F);
      }
    }
    // when the table element display property is 'block', the 'overflow: hidden;' property does not actually work
    // and instead the lastCell width is changed automatically, all we do here is check if the expected width
    // (at.tableDimensions.indexColumnWidth) is different to the actual one and if so, we change it to actual
    static checkAutoColumnWidthUpdate(D, w2) {
      if (w2.offsetWidth !== D._tableDimensions.indexColumnWidth) {
        let O = w2.offsetWidth;
        D.offsetWidth !== D.scrollWidth && (O = te.wrapColumnTextAndGetDefaultWidth(D)), te.changeTableWidths(D, O);
      }
    }
    static updatedBasedOnTableStyle(D, w2, O, x2 = false) {
      x2 ? te.forceWrap(D, w2) : D._tableDimensions.preserveNarrowColumns || D._tableDimensions.maxWidth !== void 0 ? te.updateColumnWidthWhenOverflow(D, w2, O) : D._tableDimensions.width !== void 0 && te.checkAutoColumnWidthUpdate(D, O);
    }
    static getFirstVisibleRow(D) {
      const { _pagination: w2, _tableBodyElementRef: O, dataStartsAtHeader: x2 } = D;
      return x2 && w2 ? w2.visibleRows[0] : O == null ? void 0 : O.children[0];
    }
    static updatedBasedOnVisiblity(D, w2, O = false) {
      const x2 = te.getFirstVisibleRow(D);
      D._pagination && D.filter ? x2 ? te.updatedBasedOnTableStyle(D, x2, w2, O) : setTimeout(() => {
        const U = te.getFirstVisibleRow(D);
        U && te.updatedBasedOnTableStyle(D, U, w2, O);
      }) : x2 && te.updatedBasedOnTableStyle(D, x2, w2, O);
    }
    // used when a new row is added
    // forceWrap - REF-19
    static update(D, w2, O = false) {
      var U;
      if (D._tableDimensions.isColumnIndexCellTextWrapped)
        return;
      if (!w2) {
        const { _tableBodyElementRef: F, data: W } = D;
        w2 = ExtractElements.textRowsArrFromTBody(F, W);
      }
      const x2 = (U = w2[w2.length - 1]) == null ? void 0 : U.children[0];
      x2 && te.updatedBasedOnVisiblity(D, x2, O);
    }
    // used when a new column is added to see if wrapping is needed
    // CAUTION-2 - this runs before re-render but stay cautions
    static wrapTextWhenNarrowColumnsBreached(D) {
      D._frameComponents.displayIndexColumn && te.shouldTextBeWrapped(D) && te.update(D, void 0, true);
    }
  };
  _UpdateIndexColumnWidth.TEMPORARY_INDEX_NUMBER = "temp-index-number";
  _UpdateIndexColumnWidth.TEMPORARY_INVISIBLE_INDEX_NUMBER = "temp-invisible-index-number";
  var UpdateIndexColumnWidth = _UpdateIndexColumnWidth;
  var _IndexColumn = class be {
    static updateIndexes(D, w2) {
      const { _tableBodyElementRef: O, data: x2, dataStartsAtHeader: U } = D, F = ExtractElements.textRowsArrFromTBody(O, x2, w2), W = Number(U);
      F.forEach((G, X) => {
        const K = G.children[0], q = w2 + X + W;
        K.innerText = String(q);
      }), UpdateIndexColumnWidth.update(D, F.length === 0 ? void 0 : F);
    }
    // prettier-ignore
    static createCell(D, w2) {
      var q, Q;
      const { _tableDimensions: O, _defaultColumnsSettings: x2, _frameComponents: { styles: U, cellColors: F, inheritHeaderColors: W } } = D, G = CellElement.createBaseCell(w2);
      G.classList.add(be.INDEX_CELL_CLASS, GenericElementUtils.NOT_SELECTABLE_CLASS);
      const { displaySettings: X, canEditHeaderRow: K } = D.rowDropdown;
      return G.style.cursor = (q = X.openMethod) != null && q.cellClick && (!w2 || K) ? "pointer" : "default", O.isColumnIndexCellTextWrapped || G.classList.add(be.INDEX_CELL_OVERFLOW_CLASS), Object.assign(G.style, x2.cellStyle, (U == null ? void 0 : U.default) || {}), w2 && Object.assign(
        G.style,
        W ? (Q = x2.headerStyles) == null ? void 0 : Q.default : {},
        F.header.default
      ), G;
    }
    static createHeaderCell(D) {
      const w2 = be.createCell(D, true);
      return D.dataStartsAtHeader && (w2.innerText = "1"), w2.style.width = be.DEFAULT_WIDTH_PX, Browser.IS_SAFARI && setTimeout(() => w2.style.width = be.DEFAULT_WIDTH_PX), w2;
    }
    static createDataCell(D, w2) {
      const O = be.createCell(D, false), x2 = D.dataStartsAtHeader ? w2 + 1 : w2;
      return O.innerText = String(x2), O;
    }
    static createAndPrependToRow(D, w2, O) {
      const x2 = O === 0 ? be.createHeaderCell(D) : be.createDataCell(D, O);
      D._columnsDetails[0] && ColumnSettingsBorderUtils.unsetSubjectBorder([x2], D._columnsDetails[0].elements, "right", 0), w2.appendChild(x2);
    }
  };
  _IndexColumn.INDEX_CELL_CLASS = "index-cell";
  _IndexColumn.INDEX_CELL_OVERFLOW_CLASS = "index-cell-overflow";
  _IndexColumn.DEFAULT_WIDTH = 30;
  _IndexColumn.DEFAULT_WIDTH_PX = `${_IndexColumn.DEFAULT_WIDTH}px`;
  var IndexColumn = _IndexColumn;
  var UNSET_NUMBER_IDENTIFIER = -1;
  var _TableDimensionsUtils = class $e {
    // REF-19
    static setIsColumnIndexCellTextWrapped(D, w2) {
      w2 && (typeof w2 == "object" && w2.wrapIndexCellText ? D.isColumnIndexCellTextWrapped = true : D.isColumnIndexCellTextWrapped === void 0 && (D.isColumnIndexCellTextWrapped = false));
    }
    static setPreserveNarrowColumnsProp(D, w2) {
      w2.preserveNarrowColumns = D.preserveNarrowColumns;
    }
    // prettier-ignore
    static setDimension(D, w2) {
      const { tableStyle: O, _tableDimensions: x2, _tableElementRef: U, parentElement: F } = D;
      if (!U || !F)
        return;
      const W = StringDimensionUtils.generateNumberDimensionFromClientString(
        F,
        O,
        w2,
        true,
        $e.MINIMAL_TABLE_WIDTH
      );
      W.number > 0 && (D.overflow && OverflowUtils.processNumberDimension(x2, W), x2[w2] = W.number, x2.isPercentage = W.isPercentage);
    }
    // CAUTION-3
    // prettier-ignore
    static setTableDimensions(D) {
      const { tableStyle: w2, _tableDimensions: O, _frameComponents: { displayIndexColumn: x2 } } = D;
      w2.width !== void 0 ? $e.setDimension(D, "width") : w2.maxWidth !== void 0 && $e.setDimension(D, "maxWidth"), $e.setPreserveNarrowColumnsProp(D, O), $e.setIsColumnIndexCellTextWrapped(O, x2);
    }
    static hasSetTableWidthBeenBreached(D) {
      const { width: w2, maxWidth: O } = D._tableDimensions, x2 = D.offsetWidth, U = w2 || O;
      return U ? Math.ceil(U) < x2 : false;
    }
    static record(D) {
      D._tableDimensions.recordedParentWidth = D.parentElement.offsetWidth, D._tableDimensions.recordedParentHeight = D.parentElement.offsetHeight, D._tableDimensions.recordedWindowWidth = window.innerWidth, D._tableDimensions.recordedWindowHeight = window.innerHeight;
    }
    static getDefault() {
      return {
        recordedParentWidth: 0,
        recordedParentHeight: 0,
        recordedWindowWidth: 0,
        recordedWindowHeight: 0,
        border: TableBorderDimensionsUtils.generateDefault(),
        staticWidth: UNSET_NUMBER_IDENTIFIER,
        newColumnWidth: 140,
        indexColumnWidth: IndexColumn.DEFAULT_WIDTH
      };
    }
  };
  _TableDimensionsUtils.MINIMAL_TABLE_WIDTH = 70;
  var TableDimensionsUtils = _TableDimensionsUtils;
  var MaximumRows = class {
    static canAddMore(D) {
      var U;
      const { _columnsDetails: w2, maxRows: O } = D, x2 = (U = w2[0]) == null ? void 0 : U.elements.length;
      return !(x2 !== void 0 && O !== void 0 && O > 0 && O <= x2);
    }
  };
  var FrameComponentsColors = class _FrameComponentsColors {
    // prettier-ignore
    static getInheritedHeaderColors(D) {
      var x2, U, F, W, G, X;
      const { _defaultColumnsSettings: { headerStyles: w2, cellStyle: O } } = D;
      return {
        default: {
          backgroundColor: ((x2 = w2 == null ? void 0 : w2.default) == null ? void 0 : x2.backgroundColor) || (O == null ? void 0 : O.backgroundColor) || "",
          color: ((U = w2 == null ? void 0 : w2.default) == null ? void 0 : U.color) || (O == null ? void 0 : O.color) || ""
        },
        hover: {
          backgroundColor: ((F = w2 == null ? void 0 : w2.hoverColors) == null ? void 0 : F.backgroundColor) || ((W = w2 == null ? void 0 : w2.default) == null ? void 0 : W.backgroundColor) || (O == null ? void 0 : O.backgroundColor) || D._defaultCellHoverColors.backgroundColor,
          color: ((G = w2 == null ? void 0 : w2.hoverColors) == null ? void 0 : G.color) || ((X = w2 == null ? void 0 : w2.default) == null ? void 0 : X.color) || (O == null ? void 0 : O.color) || D._defaultCellHoverColors.color
        }
      };
    }
    // prettier-ignore
    static getHoverColorValue(D, w2) {
      var U, F, W;
      const { _frameComponents: { styles: O }, _defaultCellHoverColors: x2 } = D;
      return ((U = O == null ? void 0 : O.hoverColors) == null ? void 0 : U[w2]) || ((F = O == null ? void 0 : O.default) == null ? void 0 : F[w2]) || ((W = D._defaultColumnsSettings.cellStyle) == null ? void 0 : W[w2]) || x2[w2];
    }
    static getDefaultColorValue(D, w2) {
      var O, x2, U;
      return ((x2 = (O = D._frameComponents.styles) == null ? void 0 : O.default) == null ? void 0 : x2[w2]) || ((U = D._defaultColumnsSettings.cellStyle) == null ? void 0 : U[w2]) || "";
    }
    // prettier-ignore
    static setEventColors(D) {
      const w2 = {
        default: {
          backgroundColor: _FrameComponentsColors.getDefaultColorValue(D, "backgroundColor"),
          color: _FrameComponentsColors.getDefaultColorValue(D, "color")
        },
        hover: {
          backgroundColor: _FrameComponentsColors.getHoverColorValue(D, "backgroundColor"),
          color: _FrameComponentsColors.getHoverColorValue(D, "color")
        }
      }, { _frameComponents: { cellColors: O, inheritHeaderColors: x2 } } = D;
      O.data = w2, O.header = x2 ? _FrameComponentsColors.getInheritedHeaderColors(D) : w2;
    }
    static getColorsBasedOnParam(D, w2) {
      const { data: O, header: x2 } = D;
      return w2 === 0 ? x2 : O;
    }
    static getDefaultCellColors() {
      return {
        data: {
          default: { backgroundColor: "", color: "" },
          hover: { backgroundColor: "", color: "" }
        },
        header: {
          default: { backgroundColor: "", color: "" },
          hover: { backgroundColor: "", color: "" }
        }
      };
    }
  };
  var CellHighlightUtils = class {
    static fade(D, w2) {
      D.style.backgroundColor = (w2 == null ? void 0 : w2.backgroundColor) || "", D.style.color = (w2 == null ? void 0 : w2.color) || "";
    }
    static highlight(D, w2) {
      w2 != null && w2.backgroundColor && (D.style.backgroundColor = w2.backgroundColor), w2 != null && w2.color && (D.style.color = w2.color);
    }
    static unsetDefaultHoverProperties(D) {
      D.backgroundColor = "", D.color = "";
    }
    static getDefaultHoverProperties() {
      return { backgroundColor: "#f7f7f7", color: "" };
    }
  };
  var ElementOffset = class {
    static processLeft(D, w2) {
      return Browser.IS_FIREFOX ? D += w2.leftWidth : Browser.IS_SAFARI && (D -= w2.leftWidth), D;
    }
    static processTop(D, w2) {
      return Browser.IS_FIREFOX ? D += w2.topWidth : Browser.IS_SAFARI && (D -= w2.topWidth), D;
    }
    static processWidth(D, w2) {
      return Browser.IS_FIREFOX && (D += w2.leftWidth), D;
    }
  };
  var VisibilityUtils = class {
    static headerChanged(D) {
      setTimeout(() => {
        D._visiblityInternal.filters && FilterInternalUtils.resetAllInputs(D);
      });
    }
    static completeReset(D) {
      D._visiblityInternal.filters && FilterInternalUtils.completeReset(D);
    }
  };
  var _CaretDisplayFix = class _e {
    static removeContentEditable(D) {
      D.removeAttribute(_e.CONTENT_EDITABLE);
    }
    // THIS HAS TO BE CALLED IN A FOCUS EVENT!!!!!!!!!!!!!!!!!
    static setContentEditable(D) {
      D.setAttribute(_e.CONTENT_EDITABLE, "true");
    }
    static removeTabIndex(D) {
      D.removeAttribute(_e.TAB_INDEX);
    }
    static setTabIndex(D) {
      D.setAttribute(_e.TAB_INDEX, "0");
    }
    static removeBRPadding(D, w2) {
      const x2 = CellElement.getTextElement(w2).childNodes[0];
      x2.tagName === _e.BR_TAG_NAME && (x2.remove(), CaretPosition.setToEndOfText(D, w2));
    }
    static addBRPaddingToEmptyCell(D, w2) {
      const O = CellElement.getTextElement(D);
      w2 === EMPTY_STRING && O.childNodes.length === 0 && O.appendChild(document.createElement(_e.BR_TAG_NAME));
    }
    // caret is placed too far on top left
    // this happens when cell text is programmatically set to empty or when the user doubeclicks text and clicks backspace
    // natively firefox adds a 'br' element to replace the text when the user deletes it when clicking backspace for each
    // letter however it does not for the cases outlined previously, hence this is needed
    static toggleCellTextBRPadding(D, w2, O) {
      const x2 = CellElement.getText(w2);
      O && x2 !== EMPTY_STRING ? _e.removeBRPadding(D, w2) : _e.addBRPaddingToEmptyCell(w2, x2);
    }
    static isIssueBrowser() {
      return Browser.IS_FIREFOX || Browser.IS_SAFARI;
    }
  };
  _CaretDisplayFix.CONTENT_EDITABLE = "contenteditable";
  _CaretDisplayFix.TAB_INDEX = "tabindex";
  _CaretDisplayFix.BR_TAG_NAME = "BR";
  var CaretDisplayFix = _CaretDisplayFix;
  var _CellTextElement = class et {
    static set(D, w2) {
      D.innerText = "", D.contentEditable = "false", CaretDisplayFix.isIssueBrowser() && CaretDisplayFix.removeTabIndex(D), D.appendChild(w2);
    }
    static createTextElement(D, w2) {
      const O = document.createElement("div");
      return O.innerText = D, D === "" && CaretDisplayFix.addBRPaddingToEmptyCell(O, ""), O.classList.add(et.CELL_TEXT_DIV_CLASS), CellElement.prepContentEditable(O, w2), O;
    }
    static setCellTextAsAnElement(D, w2) {
      const O = CellElement.getText(D), x2 = et.createTextElement(O, w2);
      return et.set(D, x2), x2;
    }
  };
  _CellTextElement.CELL_TEXT_DIV_CLASS = "cell-text-div";
  var CellTextElement = _CellTextElement;
  var _HeaderIconCellElement = class ye {
    static createTextElement(D, w2) {
      const O = CellTextElement.setCellTextAsAnElement(D, w2);
      return O.classList.add(ye.TEXT_CLASS), O.style.pointerEvents = w2 ? "" : "none", O;
    }
    static setScale(D, w2) {
      const O = (w2 == null ? void 0 : w2.x) || 1.2, x2 = (w2 == null ? void 0 : w2.y) || 1.2, U = `scale(${O}, ${x2})`;
      D.style.transform = U, D.style.webkitTransform = U;
    }
    static createSvgIcon(D, w2) {
      var x2, U;
      const O = SVGIconUtils.createSVGElement(D.svgString);
      return ye.setScale(O, (x2 = w2.headerIconStyle) == null ? void 0 : x2.scale), O.style.filter = ((U = w2.headerIconStyle) == null ? void 0 : U.filterColor) || SVGIconUtils.HEADER_FILTER, O;
    }
    static createSVGContainer(D) {
      const w2 = document.createElement("div"), { containerStyles: O } = D;
      return O != null && O.dropdown && Object.assign(w2.style, O == null ? void 0 : O.dropdown), O != null && O.headerCorrections && Object.assign(w2.style, O == null ? void 0 : O.headerCorrections), w2.classList.add(ye.ICON_CONTAINER_CLASS), w2;
    }
    static createSVG(D, w2) {
      const O = ye.createSVGContainer(D), x2 = ye.createSvgIcon(D, w2);
      return O.appendChild(x2), O;
    }
    static changeHeaderIcon(D) {
      const { elements: w2, activeType: O, settings: x2 } = D, U = ye.createSVG(O.dropdownItem.settings.iconSettings, x2), F = w2[0];
      F.replaceChild(U, F.children[0]);
    }
    static setHeaderIconStructure(D, w2, O) {
      var K, q, Q;
      const { activeType: x2, settings: U } = D._columnsDetails[O], F = ye.createSVG(x2.dropdownItem.settings.iconSettings, U), W = (Q = (q = (K = D._defaultColumnsSettings.columnDropdown) == null ? void 0 : K.displaySettings) == null ? void 0 : q.openMethod) == null ? void 0 : Q.cellClick, G = U.isHeaderTextEditable && !W, X = ye.createTextElement(w2, G);
      w2.insertBefore(F, X);
    }
  };
  _HeaderIconCellElement.TEXT_CLASS = "header-icon-side-text";
  _HeaderIconCellElement.ICON_CONTAINER_CLASS = "header-icon-container";
  var HeaderIconCellElement = _HeaderIconCellElement;
  var _DateCellInputElement = class Se {
    static isInputElement(D) {
      return (D == null ? void 0 : D.type) === Se.ELEMENT_TYPE;
    }
    static toggle(D, w2) {
      if (!D)
        return;
      const O = D.children[1];
      O.style.display = w2 ? "block" : "none";
    }
    static extractInputElementFromCell(D) {
      return D.children[1].children[0];
    }
    static convertTextToInputValue(D, w2) {
      if (w2.calendar && (w2.textValidation.func === void 0 || w2.textValidation.func(D))) {
        const x2 = w2.calendar.toYMDFunc(D);
        return [x2[0], x2[1].padStart(2, "0"), x2[2].padStart(2, "0")].join("-");
      }
      return "-";
    }
    static updateInputBasedOnTextDiv(D, w2) {
      const O = Se.convertTextToInputValue(CellElement.getText(D), w2);
      Se.extractInputElementFromCell(D).value = O;
    }
    static createInputElement(D, w2) {
      const O = document.createElement("input");
      return O.type = Se.ELEMENT_TYPE, O.classList.add(Se.DATE_INPUT_CLASS), O.value = Se.convertTextToInputValue(D, w2), O;
    }
    static createInputElementContainer() {
      const D = document.createElement("div");
      return D.classList.add(Se.DATE_INPUT_CONTAINER_CLASS), D.style.display = "none", D;
    }
    static addDateInputElement(D, w2, O) {
      const x2 = Se.createInputElementContainer(), U = Se.createInputElement(CellElement.getText(w2), O);
      x2.appendChild(U);
      const F = DateCellCalendarIconElement.get();
      x2.appendChild(F), D.appendChild(x2);
    }
  };
  _DateCellInputElement.ELEMENT_TYPE = "date";
  _DateCellInputElement.DATE_INPUT_CLASS = "date-input";
  _DateCellInputElement.DATE_INPUT_CONTAINER_CLASS = "date-input-container";
  var DateCellInputElement = _DateCellInputElement;
  var DateCellTextElement = class {
    static convertInputValueToText(D, w2, O) {
      const x2 = RegexUtils.extractIntegerStrs(D);
      return x2 ? O.fromYMDFunc(x2) : w2;
    }
    static setCellTextAsAnElement(D, w2) {
      const O = CellTextElement.setCellTextAsAnElement(D, w2);
      return O.style.float = "left", O;
    }
  };
  var _DateCellCalendarIconEvents = class at {
    static mouseDownIcon(D, w2, O) {
      const { _focusedElements: x2, _activeOverlayElements: U } = this, W = O.target.previousSibling, G = CellElement.getCellElement(W);
      setTimeout(() => {
        FocusedCellUtils.set(x2.cell, G, D, w2), U.datePickerCell = G, Browser.IS_SAFARI ? W.dispatchEvent(new MouseEvent("click")) : W.showPicker();
      }, at.PICKER_DISPLAY_DELAY_ML);
    }
    static setEvents(D, w2, O, x2) {
      w2.onmousedown = at.mouseDownIcon.bind(D, O, x2);
    }
  };
  _DateCellCalendarIconEvents.PICKER_DISPLAY_DELAY_ML = Browser.IS_FIREFOX ? 190 : 0;
  var DateCellCalendarIconEvents = _DateCellCalendarIconEvents;
  var MOUSE_EVENT = /* @__PURE__ */ ((Y) => (Y.DOWN = "Down", Y))(MOUSE_EVENT || {});
  var DateCellInputEvents = class _DateCellInputEvents {
    // outstanding bug is when the user opens picker and moves with arrow keys, then clicks escape
    // the picker fires a clear event and does not actually close itself and instead goes to the
    // initially opened up date. The key up event for the escape button is also not fired.
    static escapeKeyInput(D) {
      if (D._activeOverlayElements.datePickerCell) {
        const w2 = D._focusedElements.cell.element;
        D._hoveredElements.dateCell !== w2 && DateCellInputElement.toggle(w2, false), delete D._activeOverlayElements.datePickerCell;
      }
    }
    // this is triggered when a date is selected via the date picker
    // prettier-ignore
    static inputInput(D, w2, O) {
      const { elements: x2, settings: { defaultText: U }, activeType: { calendar: F } } = this._columnsDetails[w2];
      if (!F)
        return;
      const W = O.target.value, G = DateCellTextElement.convertInputValueToText(W, U, F), X = x2[D];
      CellEvents.updateCell(this, G, D, w2, { element: X });
    }
    // this is triggered when the user clicks on picker buttons
    static changeInput() {
      const D = this._focusedElements.cell.element;
      !this._userKeyEventsState[MOUSE_EVENT.DOWN] && // do not hide icon when currently hovered
      this._hoveredElements.dateCell !== D && DateCellInputElement.toggle(D, false), delete this._activeOverlayElements.datePickerCell;
    }
    // the user does not use the actual input element and the events are triggered via the date picker
    static setEvents(D, w2, O, x2) {
      w2.onchange = _DateCellInputEvents.changeInput.bind(D), w2.oninput = _DateCellInputEvents.inputInput.bind(D, O, x2);
    }
  };
  var FocusNextColumnCellFromTextDiv = class _FocusNextColumnCellFromTextDiv {
    static focusDifferentColumnCell(D, w2, O) {
      const { elements: x2, activeType: U, settings: F } = D._columnsDetails[w2], W = x2[O];
      if (!F.isCellTextEditable || O === 0 && !F.isHeaderTextEditable || // REF-29
      Browser.IS_SAFARI && CheckboxCellElement.isCheckboxCell(W))
        return _FocusNextColumnCellFromTextDiv.focusOrBlurNext(D, w2, O);
      U.cellDropdownProps ? W.dispatchEvent(new Event("mousedown")) : (CellWithTextEvents.programmaticBlur(D), CellElement.getTextElement(W).focus()), W.scrollIntoView({ block: "nearest" });
    }
    static focusOrBlurNextRowFirstCell(D, w2) {
      const O = D._columnsDetails[0], x2 = w2 + 1;
      O.elements[x2] ? _FocusNextColumnCellFromTextDiv.focusDifferentColumnCell(D, 0, x2) : D._focusedElements.cell.element.children[0].blur();
    }
    static focusOrBlurNext(D, w2, O) {
      D._columnsDetails[w2 + 1] ? _FocusNextColumnCellFromTextDiv.focusDifferentColumnCell(D, w2 + 1, O) : _FocusNextColumnCellFromTextDiv.focusOrBlurNextRowFirstCell(D, O);
    }
  };
  var CellTextEvents = class {
    static tabOutOfCell(D, w2, O, x2) {
      x2.preventDefault(), DataCellEvents.keyDownCell.bind(D, w2, O)(x2), FocusNextColumnCellFromTextDiv.focusOrBlurNext(D, O, w2);
    }
  };
  var DateCellTextEvents = class _DateCellTextEvents {
    static keyDownOnText(D, w2, O) {
      O.key === KEYBOARD_KEY.TAB && CellTextEvents.tabOutOfCell(this, D, w2, O);
    }
    static inputText(D, w2) {
      if (Browser.IS_INPUT_DATE_SUPPORTED) {
        const { activeType: O } = this._columnsDetails[D], x2 = CellElement.getCellElement(w2.target);
        DateCellInputElement.updateInputBasedOnTextDiv(x2, O);
      }
    }
    static blurText(D, w2, O) {
      const x2 = O.target;
      DataCellEvents.blur(this, D, w2, x2);
    }
    static setEvents(D, w2, O, x2) {
      D._columnsDetails[x2].settings.isCellTextEditable && (w2.onfocus = CellWithTextEvents.focusText.bind(D, O, x2, null), w2.onblur = _DateCellTextEvents.blurText.bind(D, O, x2), w2.oninput = _DateCellTextEvents.inputText.bind(D, x2), w2.onkeydown = _DateCellTextEvents.keyDownOnText.bind(D, O, x2));
    }
  };
  var DateCellEvents = class _DateCellEvents {
    static mouseLeaveCell(D) {
      if (delete this._hoveredElements.dateCell, Browser.IS_INPUT_DATE_SUPPORTED) {
        const w2 = D.target;
        if (this._activeOverlayElements.datePickerCell === w2)
          return;
        DateCellInputElement.toggle(w2, false);
      }
    }
    static mouseEnterCell(D) {
      this._hoveredElements.dateCell = D.target, Browser.IS_INPUT_DATE_SUPPORTED && DateCellInputElement.toggle(this._hoveredElements.dateCell, true);
    }
    static setEvents(D, w2, O, x2) {
      if (!D._columnsDetails[x2].settings.isCellTextEditable)
        return;
      w2.onblur = () => {
      }, w2.onfocus = () => {
      }, w2.onmouseenter = _DateCellEvents.mouseEnterCell.bind(D), w2.onmouseleave = _DateCellEvents.mouseLeaveCell.bind(D), w2.onmousedown = CellWithTextEvents.mouseDown.bind(D, null);
      const U = w2.children[0];
      if (DateCellTextEvents.setEvents(D, U, O, x2), Browser.IS_INPUT_DATE_SUPPORTED) {
        const F = w2.children[1];
        DateCellInputEvents.setEvents(D, F, O, x2);
        const W = F.children[1];
        DateCellCalendarIconEvents.setEvents(D, W, O, x2);
      }
    }
  };
  var DateCellElement = class _DateCellElement {
    // prettier-ignore
    static setCellDateStructure(D, w2, O) {
      ConvertCellTypeUtils.preprocessCell(w2), w2.style.cursor = "text";
      const { isCellTextEditable: x2 } = D._columnsDetails[O].settings, U = DateCellTextElement.setCellTextAsAnElement(w2, x2);
      Browser.IS_INPUT_DATE_SUPPORTED && DateCellInputElement.addDateInputElement(
        w2,
        U,
        D._columnsDetails[O].activeType
      );
    }
    static setColumnDateStructure(D, w2) {
      CellStructureUtils.setColumn(D, w2, _DateCellElement.setCellDateStructure, DateCellEvents.setEvents);
    }
  };
  var _SelectCellTextElement = class Ct {
    static setCellTextAsAnElement(D, w2, O) {
      const { isCellTextEditable: x2 } = D._columnsDetails[O].settings;
      CellTextElement.setCellTextAsAnElement(w2, x2).classList.add(Ct.TEXT_CLASS);
    }
    // prettier-ignore
    static finaliseEditedText(D, w2, O) {
      var K, q;
      const x2 = D._columnsDetails[O], { cellDropdown: U, activeType: F, settings: W } = x2, G = CellElement.getText(w2), X = !!((K = U.itemsDetails[G]) != null && K.backgroundColor);
      (q = F.cellDropdownProps) != null && q.canAddMoreOptions && G !== EMPTY_STRING && !X && (!W.isDefaultTextRemovable || G !== W.defaultText) && CellDropdownItem.addNewItem(D, w2, x2, w2.style.backgroundColor);
    }
  };
  _SelectCellTextElement.TEXT_CLASS = "select-cell-text";
  var SelectCellTextElement = _SelectCellTextElement;
  var SelectCellBaseEvents = class {
    static blurIfDropdownFocused(D) {
      D._focusedElements.cellDropdown && CellWithTextEvents.programmaticBlur(D);
    }
  };
  var SelectCellEvents = class _SelectCellEvents {
    static mouseLeaveCell(D, w2) {
      delete this._hoveredElements.selectCell;
      const O = w2.target, { cellDropdown: x2 } = this._columnsDetails[D];
      (!Dropdown.isDisplayed(x2.element) || x2.displayedCellElement !== O) && ArrowDownIconElement.toggle(O, false);
    }
    static mouseEnterCell(D) {
      this._hoveredElements.selectCell = D.target, ArrowDownIconElement.toggle(this._hoveredElements.selectCell, true);
    }
    static mouseDownCell(D) {
      var O;
      const w2 = D.target;
      if (w2.classList.contains(CellElement.CELL_CLASS))
        CellWithTextEvents.mouseDownCell(this, SelectCellBaseEvents.blurIfDropdownFocused, w2, D);
      else if (w2.classList.contains(ArrowDownIconElement.ARROW_ICON_CLASS)) {
        const x2 = (O = w2.parentElement) == null ? void 0 : O.parentElement;
        CellWithTextEvents.mouseDownCell(this, SelectCellBaseEvents.blurIfDropdownFocused, x2, D);
      }
    }
    static setEvents(D, w2, O, x2) {
      if (!D._columnsDetails[x2].settings.isCellTextEditable)
        return;
      w2.onblur = () => {
      }, w2.onfocus = () => {
      }, w2.onmouseenter = _SelectCellEvents.mouseEnterCell.bind(D), w2.onmouseleave = _SelectCellEvents.mouseLeaveCell.bind(D, x2), w2.onmousedown = _SelectCellEvents.mouseDownCell.bind(D);
      const U = w2.children[0];
      SelectCellTextBaseEvents.setEvents(D, U, O, x2);
    }
  };
  var SelectCellElement = class _SelectCellElement {
    static setCellSelectStructure(D, w2, O) {
      ConvertCellTypeUtils.preprocessCell(w2), SelectCellTextElement.setCellTextAsAnElement(D, w2, O), w2.appendChild(ArrowDownIconElement.get()), SelectCell.setPointerCursorIfCantAdd(w2, D._columnsDetails[O].activeType);
    }
    static setColumnSelectStructure(D, w2) {
      CellStructureUtils.setColumn(D, w2, _SelectCellElement.setCellSelectStructure, SelectCellEvents.setEvents);
    }
  };
  var LabelCellEvents = class {
    static setEvents(D, w2, O, x2) {
      if (!D._columnsDetails[x2].settings.isCellTextEditable)
        return;
      w2.onblur = () => {
      }, w2.onfocus = () => {
      }, w2.onmouseenter = () => {
      }, w2.onmouseleave = () => {
      }, w2.onmousedown = CellWithTextEvents.mouseDown.bind(D, SelectCellBaseEvents.blurIfDropdownFocused);
      const U = w2.children[0];
      SelectCellTextBaseEvents.setEvents(D, U, O, x2);
    }
  };
  var LabelCellElement = class _LabelCellElement {
    // prettier-ignore
    static setCellLabelStructure(D, w2, O) {
      var W;
      ConvertCellTypeUtils.preprocessCell(w2);
      const { cellDropdown: { itemsDetails: x2 }, settings: { isCellTextEditable: U } } = D._columnsDetails[O], F = ((W = x2[CellElement.getText(w2)]) == null ? void 0 : W.backgroundColor) || "";
      LabelCellTextElement.setCellTextAsAnElement(w2, F, U), SelectCell.setPointerCursorIfCantAdd(w2, D._columnsDetails[O].activeType);
    }
    static setColumnLabelStructure(D, w2) {
      CellStructureUtils.setColumn(D, w2, _LabelCellElement.setCellLabelStructure, LabelCellEvents.setEvents);
    }
  };
  var SelectCell = class {
    static convertCell(D, w2, O) {
      var U;
      (U = D._columnsDetails[w2].activeType.cellDropdownProps) != null && U.isBasicSelect ? SelectCellElement.setCellSelectStructure(D, O, w2) : LabelCellElement.setCellLabelStructure(D, O, w2);
    }
    static convertColumn(D, w2, O) {
      var x2;
      (x2 = O.cellDropdownProps) != null && x2.isBasicSelect ? SelectCellElement.setColumnSelectStructure(D, w2) : LabelCellElement.setColumnLabelStructure(D, w2);
    }
    static setEvents(D, w2, O, x2) {
      var F;
      const { activeType: U } = D._columnsDetails[x2];
      (F = U.cellDropdownProps) != null && F.isBasicSelect ? SelectCellEvents.setEvents(D, w2, O, x2) : LabelCellEvents.setEvents(D, w2, O, x2);
    }
    // prettier-ignore
    static finaliseEditedText(D, w2, O, x2 = false) {
      var F;
      const { activeType: U } = D._columnsDetails[O];
      (F = U.cellDropdownProps) != null && F.isBasicSelect ? SelectCellTextElement.finaliseEditedText(D, w2, O) : LabelCellTextElement.finaliseEditedText(D, w2, O, x2);
    }
    static setPointerCursorIfCantAdd(D, w2) {
      var O;
      if (D.style.cursor = "pointer", !((O = w2.cellDropdownProps) != null && O.canAddMoreOptions)) {
        const x2 = D.children[0];
        x2.style.caretColor = "transparent", x2.style.cursor = "pointer";
      }
    }
  };
  var DataCellElement = class _DataCellElement {
    static setCellDataStructure(D, w2, O) {
      w2.innerText = CellElement.getTextElement(w2).innerText;
      const { isCellTextEditable: x2 } = D._columnsDetails[O].settings;
      CellElement.prepContentEditable(w2, x2);
    }
    static setColumnDataStructure(D, w2) {
      CellStructureUtils.setColumn(D, w2, _DataCellElement.setCellDataStructure, DataCellEvents.setEvents);
    }
  };
  var ChangeColumnType = class _ChangeColumnType {
    static setInvalidCellToDefault(D, w2, O) {
      const x2 = w2 + 1, U = D._columnsDetails[O].elements[x2];
      return CellEvents.setCellToDefaultIfNeeded(D, x2, O, U, false);
    }
    static setInvalidCellsToDefault(D, w2) {
      let O = false;
      D.data.slice(1).forEach((x2, U) => {
        _ChangeColumnType.setInvalidCellToDefault(D, U, w2) && !O && (O = true);
      }), O && setTimeout(() => FireEvents.onDataUpdate(D));
    }
    static setNew(D, w2, O) {
      const x2 = D._columnsDetails[O];
      return x2.activeType = x2.settings.types.find((U) => U.name === w2), x2.activeType;
    }
    static setNewStructureBasedOnType(D, w2, O) {
      delete D._columnsDetails[w2].cellDropdown.labelDetails, O.cellDropdownProps ? (CellDropdown.setUpDropdown(D, w2), SelectCell.convertColumn(D, w2, O)) : O.calendar ? DateCellElement.setColumnDateStructure(D, w2) : O.checkbox ? CheckboxCellElement.setColumnCheckboxStructure(D, w2) : DataCellElement.setColumnDataStructure(D, w2);
    }
    // this is required as switching to another type makes it difficult to overwrite text element (as there isn't one) for
    // checkboxes when validation fails
    static resetCheckboxElements(D) {
      D.elements.slice(1).forEach((w2) => {
        w2.innerText = CellElement.getText(w2);
      });
    }
    static resetAndChangeFunc(D, w2, O) {
      const x2 = D._columnsDetails[O];
      x2.activeType.checkbox && _ChangeColumnType.resetCheckboxElements(x2);
      const U = _ChangeColumnType.setNew(D, w2, O);
      U.textValidation.func && U.textValidation.setTextToDefaultOnFail && _ChangeColumnType.setInvalidCellsToDefault(D, O), _ChangeColumnType.setNewStructureBasedOnType(D, O, U), D.displayHeaderIcons && HeaderIconCellElement.changeHeaderIcon(D._columnsDetails[O]), setTimeout(() => FireEvents.onColumnsUpdate(D));
    }
    // prettier-ignore
    static change(D, w2) {
      const O = this._columnsDetails[w2].activeType;
      D !== O.name && ProcessedDataTextStyle.resetDataCellsStyle(
        this,
        w2,
        _ChangeColumnType.resetAndChangeFunc.bind(this, this, D, w2)
      );
    }
  };
  var CheckboxValidationFunc = class {
    // cannot place this inside the CheckboxCellElement class as certain dependencies are not imported in time
    static getDefault() {
      return (D) => {
        const w2 = String(D).trim().toLocaleLowerCase();
        return w2 === "" || w2 === "0" || w2 === "00" || w2 === "false" ? "false" : "true";
      };
    }
  };
  var CURRENCY_ICON_SVG_STRING = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16">
	<g transform="matrix(0.84210527 0 0 0.84210527 0 0)">
		<g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
			<g>
				<path d="M441.1 297.29C 422.358 282.915 397.057 271.728 364.155 263.138L364.155 263.138L364.155 113.058C 378.792 114.1439 405.382 119.14 452.362 140.058C 458.8308 142.9291 466.339 142.1322 472.061 137.97209C 477.7837 133.81189 480.854 126.91709 480.1157 119.87809C 479.38132 112.84289 474.9477 106.73009 468.4867 103.843094C 413.2097 79.230095 381.8067 74.17909 364.15668 73.300095L364.15668 73.300095L364.15668 42.152092C 364.15668 34.335693 357.82077 27.996092 350.00067 27.996092C 342.18057 27.996092 335.84467 34.33589 335.84467 42.152092L335.84467 42.152092L335.84467 73.93709C 307.65366 76.28479 280.86768 87.23009 259.09866 105.29208C 234.52066 125.13208 220.09067 154.91309 219.75467 186.49509C 219.5242 216.7761 234.14967 245.24908 258.89966 262.7021C 277.64166 277.0771 302.94266 288.2641 335.84467 296.8541L335.84467 296.8541L335.84467 446.93408C 321.20767 445.84818 294.60666 440.84818 247.63766 419.93408L247.63766 419.93408L247.63766 419.93018C 241.16887 417.05908 233.66066 417.856 227.93866 422.01608C 222.21596 426.17627 219.14566 433.07108 219.88396 440.11008C 220.61833 447.14526 225.05196 453.2581 231.51295 456.14508C 286.72797 480.73108 318.18097 485.80908 335.84296 486.69608L335.84296 486.69608L335.84296 517.8371C 335.84296 525.6535 342.17886 531.9931 349.99896 531.9931C 357.81906 531.9931 364.15497 525.6533 364.15497 517.8371L364.15497 517.8371L364.15497 486.0521C 392.34598 483.7044 419.13196 472.7591 440.90097 454.69708C 465.47897 434.8571 479.90897 405.07608 480.24496 373.49408C 480.47543 343.21307 465.84998 314.74008 441.09998 297.28708L441.09998 297.28708L441.1 297.29zM282.99 231.22801C 268.099 221.23581 259.232 204.42702 259.392 186.49802C 259.81778 166.59201 269.1029 147.90802 284.712 135.54501C 299.302 123.52501 317.06 115.99001 335.841 113.85401L335.841 113.85401L335.841 255.71402C 316.907 250.75702 299.013 242.46402 282.989 231.22601zM415.27997 424.448L415.28387 424.448C 400.69388 436.468 382.93588 444.003 364.15488 446.139L364.15488 446.139L364.15488 304.279C 383.08887 309.236 400.98288 317.529 417.00687 328.767C 431.89786 338.7592 440.76486 355.568 440.60486 373.497C 440.17908 393.403 430.89395 412.087 415.28485 424.45z" stroke="none" fill="#000000" fill-rule="nonzero" />
			</g>
		</g>
	</g>
</svg>`;
  var CHECKBOX_ICON_SVG_STRING = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="13" height="13">
  <g transform="matrix(0.68421054 0 0 0.68421054 0 0)">
    <g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
      <g>
        <path d="M521.77 0L178.24002 0C 119.416016 0 70.01002 49.41 70.01002 108.23L70.01002 108.23L70.01002 454.11002C 70.01002 512.934 119.42001 562.34 178.24002 562.34L178.24002 562.34L524.12 562.34C 582.944 562.34 632.35 512.93005 632.35 454.11002L632.35 454.11002L632.35 108.23001C 629.99835 49.40601 582.94 7.6293945E-06 521.76 7.6293945E-06L521.76 7.6293945E-06L521.77 0zM587.653 451.77C 587.653 487.063 559.419 515.30096 524.122 515.30096L524.122 515.30096L178.242 515.29706C 142.949 515.29706 114.711006 487.06305 114.711006 451.76605L114.711006 451.76605L114.71491 108.23605C 114.71491 72.943054 142.94891 44.705055 178.24591 44.705055L178.24591 44.705055L524.1259 44.705055C 559.41895 44.705055 587.6569 72.93906 587.6569 108.23605z" stroke="none" fill="#010101" fill-rule="nonzero" />
        <path d="M479.41 164.71L293.53 350.59003L222.94 280.00003C 213.5298 270.58984 201.764 270.58984 192.35 280.00003C 182.9398 289.41022 182.9398 301.17603 192.35 310.59003L192.35 310.59003L279.409 397.64902C 281.7684 400.0006 286.4715 402.3521 293.534 402.3521C 300.5926 402.3521 305.3 400.00052 307.651 395.29352L307.651 395.29352L510.001 192.94351C 517.05963 185.88492 517.05963 171.76752 510.001 164.70952C 500.59082 155.29543 486.47 155.29543 479.411 164.70952L479.411 164.70952L479.41 164.71z" stroke="none" fill="#010101" fill-rule="nonzero" />
      </g>
    </g>
  </g>
</svg>`;
  var SELECT_ICON_SVG_STRING = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="14">
	<g transform="matrix(0.9 0 0 0.93333334 0 0)">
		<g transform="matrix(0.03 0 0 0.03 2.5000005 -0)">
			<g transform="matrix(1 0 0 1 -86.77152 -33.81399)">
				<g transform="matrix(1 0 0 1 -13.737094 17.33647)">
					<path d="M399.537 218.885L277.33 218.885C 262.315 218.885 254.544 236.996 265.421 247.859L265.421 247.859L328.596 310.981C 335.328 317.708 346.201 317.708 352.933 310.466L352.933 310.466L411.966 247.343C 421.805 236.476 414.555 218.885 399.537 218.885z" stroke="none" fill="#000000" fill-rule="nonzero" />
					<path d="M340.559 56.069C 226.133 56.069 128.026 151.307 128.026 265.753C 128.026 380.198 224.339 475.408 338.765 475.408C 453.191 475.408 547.665 380.561 547.665 266.116C 547.665 151.67 454.985 56.069 340.559 56.069zM338.765 452.542C 235.73 452.542 152.37 369.168 152.37 266.116C 152.37 163.063 235.73 79.689 338.765 79.689C 441.8 79.689 525.16 163.063 525.16 266.116C 525.157 369.168 441.797 452.542 338.765 452.542z" stroke="none" fill="#000000" fill-rule="nonzero" />
				</g>
			</g>
		</g>
	</g>
</svg>`;
  var NUMBER_ICON_SVG_STRING = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14">
	<g transform="matrix(0.7368421 0 0 0.7368421 0 0)">
		<g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
			<path d="M577.5 175L471.36 175L489.78598 55.160004C 490.4813 49.101402 487.96957 43.117004 483.15707 39.367004C 478.34848 35.620903 471.93008 34.644302 466.22308 36.796703C 460.51608 38.949005 456.34418 43.917805 455.2071 49.909702L455.2071 49.909702L435.9371 174.9997L296.35712 174.9997L314.7831 55.1597C 315.66983 50.4917 314.61905 45.6597 311.87292 41.7807C 309.12292 37.901802 304.91592 35.308 300.21692 34.5971C 295.51773 33.88226 290.7325 35.11272 286.95493 37.999397C 283.18152 40.886097 280.74402 45.186897 280.20493 49.909397L280.20493 49.909397L260.93494 174.99939L157.49493 174.99939C 151.24103 174.99939 145.46393 178.3353 142.33893 183.74939C 139.21393 189.16348 139.21393 195.83539 142.33893 201.24939C 145.46393 206.66339 151.24123 209.99939 157.49493 209.99939L157.49493 209.99939L255.49493 209.99939L234.02194 349.9994L122.49194 349.9994C 116.238045 349.9994 110.460945 353.3353 107.335945 358.7494C 104.210945 364.16348 104.210945 370.8354 107.335945 376.2494C 110.460945 381.6634 116.23824 384.9994 122.49194 384.9994L122.49194 384.9994L228.63194 384.9994L210.20595 504.8394C 209.31923 509.5074 210.37001 514.33936 213.11615 518.2184C 215.86615 522.0973 220.07315 524.6911 224.77216 525.402C 229.47136 526.1168 234.25656 524.88635 238.03415 521.9997C 241.80756 519.113 244.24506 514.8122 244.78415 510.0897L244.78415 510.0897L264.05414 384.9997L403.63416 384.9997L385.20816 504.8397C 384.32144 509.5077 385.37222 514.3397 388.11835 518.2187C 390.86835 522.0976 395.07535 524.6914 399.77435 525.4023C 404.47354 526.1171 409.25876 524.88666 413.03635 522C 416.80975 519.1133 419.24725 514.8125 419.78635 510.09L419.78635 510.09L439.05634 385L542.49634 385C 548.75024 385 554.52734 381.6641 557.65234 376.25C 560.77734 370.8359 560.77734 364.164 557.65234 358.75C 554.52734 353.336 548.75006 350 542.49634 350L542.49634 350L444.49634 350L466.03934 210L577.4993 210C 583.75323 210 589.53033 206.6641 592.65533 201.25C 595.78033 195.8359 595.78033 189.164 592.65533 183.75C 589.53033 178.336 583.75305 175 577.4993 175L577.4993 175L577.5 175zM430.5 210L408.957 350L269.497 350L291.04 210z" stroke="none" fill="#000000" fill-rule="nonzero" />
		</g>
	</g>
</svg>`;
  var LABEL_ICON_SVG_STRING = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14">
	<g transform="matrix(0.7368421 0 0 0.7368421 0 0)">
		<g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
			<g>
				<path d="M279.16 122.86L470.53 122.86L470.53 95.829C 470.53 82.16901 464.9362 69.755005 455.913 60.735C 446.8896 51.7116 434.475 46.118 420.835 46.118L420.835 46.118L165.825 46.118C 152.165 46.118 139.75099 51.7118 130.73099 60.735C 121.70759 69.7584 116.11399 82.173004 116.11399 95.829L116.11399 95.829L116.11399 350.839C 116.11399 364.47998 121.707794 376.913 130.73099 385.917C 139.7544 394.9404 152.16899 400.534 165.82498 400.534L165.82498 400.534L192.85599 400.534L192.85599 209.164C 192.85599 185.41 202.5669 163.836 218.19199 148.195C 233.81708 132.55402 255.40298 122.85901 279.16098 122.85901L279.16098 122.85901L279.16 122.86zM507.14 122.86L534.171 122.86C 557.92505 122.86 579.499 132.5709 595.14 148.196C 610.765 163.821 620.476 185.407 620.476 209.16501L620.476 209.16501L620.476 464.175C 620.476 487.929 610.76514 509.503 595.14 525.144C 579.499 540.785 557.929 550.48 534.171 550.48L534.171 550.48L279.161 550.48C 255.40701 550.48 233.83301 540.7691 218.19202 525.144C 202.55103 509.51886 192.85602 487.93298 192.85602 464.175L192.85602 464.175L192.85602 437.14398L165.82501 437.14398C 142.07101 437.14398 120.49701 427.43307 104.85601 411.80798C 89.23101 396.18298 79.52001 374.597 79.52001 350.839L79.52001 350.839L79.52001 95.828995C 79.52001 72.075 89.23091 50.500996 104.85601 34.859993C 120.49701 19.234993 142.06702 9.523993 165.82501 9.523993L165.82501 9.523993L420.83502 9.523993C 444.58902 9.523993 466.16302 19.234894 481.80402 34.859993C 497.445 50.50099 507.14 72.07099 507.14 95.828995zM534.171 159.469L279.161 159.469C 265.52002 159.469 253.087 165.06279 244.08301 174.086C 235.0596 183.1094 229.466 195.524 229.466 209.18L229.466 209.18L229.466 464.19C 229.466 477.831 235.0598 490.264 244.08301 499.284C 253.10641 508.3074 265.521 513.901 279.161 513.901L279.161 513.901L534.171 513.901C 547.831 513.901 560.245 508.3072 569.265 499.284C 578.2884 490.2606 583.882 477.846 583.882 464.19L583.882 464.19L583.882 209.18001C 583.882 195.539 578.2882 183.106 569.265 174.086C 560.24164 165.06259 547.827 159.469 534.171 159.469z" stroke="none" fill="#000000" fill-rule="nonzero" />
			</g>
		</g>
	</g>
</svg>`;
  var TEXT_ICON_SVG_STRING = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="12" height="12">
  <g transform="matrix(0.6315789 0 0 0.6315789 0 0)">
    <g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
      <g>
        <path d="M84 32.48L616 32.48L616 92.96L84 92.96L84 32.48z" stroke="none" fill="#000000" fill-rule="nonzero" />
        <path d="M84 177.52L470.4 177.52L470.4 238L84 238L84 177.52z" stroke="none" fill="#000000" fill-rule="nonzero" />
        <path d="M84 322.56L616 322.56L616 383.04L84 383.04L84 322.56z" stroke="none" fill="#000000" fill-rule="nonzero" />
        <path d="M84 467.6L470.4 467.6L470.4 528.08L84 528.08L84 467.6z" stroke="none" fill="#000000" fill-rule="nonzero" />
      </g>
    </g>
  </g>
</svg>`;
  var DEFAULT_COLUMN_TYPES = /* @__PURE__ */ ((Y) => (Y.TEXT = "Text", Y.NUMBER = "Number", Y.CURRENCY = "Currency", Y.DATE_DMY = "Date d-m-y", Y.DATE_MDY = "Date m-d-y", Y.CHECKBOX = "Checkbox", Y.SELECT = "Select", Y.LABEL = "Label", Y))(DEFAULT_COLUMN_TYPES || {});
  var _CalendarFunctionalityUtils = class {
    static mdYCellTextToYMD(D) {
      const w2 = RegexUtils.extractIntegerStrs(D);
      return [w2[2], w2[0], w2[1]];
    }
    static yMDToMDYCellText(D) {
      return [D[1], D[2], D[0]].join("-");
    }
    static dMYCellTextToYMD(D) {
      const w2 = RegexUtils.extractIntegerStrs(D);
      return [w2[2], w2[1], w2[0]];
    }
    static yMDToDMYCellText(D) {
      return [D[2], D[1], D[0]].join("-");
    }
  };
  _CalendarFunctionalityUtils.DEFAULT_TYPES_FUNCTIONALITY = {
    [DEFAULT_COLUMN_TYPES.DATE_DMY]: {
      toYMDFunc: (Y) => _CalendarFunctionalityUtils.dMYCellTextToYMD(Y),
      fromYMDFunc: (Y) => _CalendarFunctionalityUtils.yMDToDMYCellText(Y)
    },
    [DEFAULT_COLUMN_TYPES.DATE_MDY]: {
      toYMDFunc: (Y) => _CalendarFunctionalityUtils.mdYCellTextToYMD(Y),
      fromYMDFunc: (Y) => _CalendarFunctionalityUtils.yMDToMDYCellText(Y)
    }
  };
  var CalendarFunctionalityUtils = _CalendarFunctionalityUtils;
  var _Validation = class {
    static setSelectValidation(D, w2, O) {
      var U, F;
      if (!((U = D.cellDropdownProps) != null && U.options) || (F = D.cellDropdownProps) != null && F.canAddMoreOptions)
        return;
      const x2 = new Set(D.cellDropdownProps.options.map((W) => W.text));
      D.textValidation ?? (D.textValidation = {}), D.textValidation.func = (W) => !!x2.has(W) || !w2 && W === O;
    }
  };
  _Validation.DEFAULT_TYPES_REGEX = {
    [DEFAULT_COLUMN_TYPES.CURRENCY]: new RegExp(
      // eslint-disable-next-line max-len
      /^(([$]\s*?-?(([1-9]\d{0,2}(,\d{3})*)|\d+)?(\.\d{1,2})?)|(-?(([1-9]\d{0,2}(,\d{3})*)|\d+)?(\.\d{1,2})?\s*?[$]))$/
    ),
    // \s*? is used to allow spaces between symbols
    [DEFAULT_COLUMN_TYPES.DATE_DMY]: new RegExp(
      /^(0?[1-9]|[12][0-9]|3[01])\s*?[/-]\s*?(0?[1-9]|1[012])\s*?[/-]\s*?\d{4}$/
    ),
    [DEFAULT_COLUMN_TYPES.DATE_MDY]: new RegExp(
      /^(0?[1-9]|1[012])\s*?[/-]\s*?(0?[1-9]|[12][0-9]|3[01])\s*?[/-]\s*?\d{4}$/
    )
  };
  _Validation.DEFAULT_TYPES_FUNCTIONALITY = {
    [DEFAULT_COLUMN_TYPES.NUMBER]: (Y) => Y !== EMPTY_STRING && !isNaN(Y),
    [DEFAULT_COLUMN_TYPES.CURRENCY]: (Y) => _Validation.DEFAULT_TYPES_REGEX[DEFAULT_COLUMN_TYPES.CURRENCY].test(Y),
    [DEFAULT_COLUMN_TYPES.DATE_DMY]: (Y) => _Validation.DEFAULT_TYPES_REGEX[DEFAULT_COLUMN_TYPES.DATE_DMY].test(Y),
    [DEFAULT_COLUMN_TYPES.DATE_MDY]: (Y) => _Validation.DEFAULT_TYPES_REGEX[DEFAULT_COLUMN_TYPES.DATE_MDY].test(Y)
  };
  var Validation = _Validation;
  var CellElementIndex = class {
    static getViaColumnIndex(D, w2) {
      const O = Number(w2);
      return D * 2 + O;
    }
  };
  var _Sort = class me {
    static extractNumberFromString(D) {
      const w2 = RegexUtils.extractFloatStrs(D);
      return w2 && w2.length > 0 ? Number(w2[0]) : 0;
    }
    // cannot safely identify if nothing has been changed, hence need to send out an update for all cells
    // prettier-ignore
    static update(D, w2) {
      const { _tableBodyElementRef: O, _frameComponents: { displayIndexColumn: x2 }, data: U } = D, F = O.children;
      w2.forEach((W, G) => {
        const X = G + 1, K = F[X].children;
        W.forEach((q, Q) => {
          const le = CellElementIndex.getViaColumnIndex(Q, !!x2), re = K[le];
          CellEvents.updateCell(
            D,
            q,
            X,
            Q,
            { processText: false, element: re, updateTableEvent: false, updateData: false }
          ), ColumnTypesUtils.updateDataElements(D, G, Q, re);
        });
      }), U.splice(1, w2.length, ...w2), setTimeout(() => FireEvents.onDataUpdate(D));
    }
    static sortStringsColumnAscending(D, w2) {
      D.sort((O, x2) => String(O[w2]).localeCompare(String(x2[w2])));
    }
    static sortStringsColumnDescending(D, w2) {
      D.sort((O, x2) => String(x2[w2]).localeCompare(String(O[w2])));
    }
    static sortStrings(D, w2, O) {
      O ? me.sortStringsColumnAscending(D, w2) : me.sortStringsColumnDescending(D, w2);
    }
    // prettier-ignore
    static parseComparedText(D, w2, O, x2) {
      const U = x2(D);
      if (U === void 0)
        return O ? 1 : -1;
      const F = x2(w2);
      return F === void 0 ? O ? -1 : 1 : [U, F];
    }
    static validateType(D, w2) {
      return D === void 0 || D(w2) ? w2 : void 0;
    }
    // prettier-ignore
    static validateAndSort(D, w2, O, x2, U) {
      const F = me.parseComparedText(D, w2, U, me.validateType.bind(this, x2));
      return typeof F == "number" ? F : (U ? O.ascendingFunc : O.descendingFunc)(F[0], F[1]);
    }
    static sortViaSortFuncs(D, w2, O, x2) {
      const { sorting: U, textValidation: F } = D;
      U && w2.sort(
        (W, G) => me.validateAndSort(W[O], G[O], U, F.func, x2)
      );
    }
    static compareDates(D, w2) {
      return new Date(...D) - new Date(...w2);
    }
    static parseYMDFormat(D, w2, O) {
      return me.validateType(D, O) ? w2.toYMDFunc(O) : void 0;
    }
    // prettier-ignore
    static sortDates(D, w2, O, x2) {
      const { calendar: U, textValidation: F } = D;
      U && w2.sort((W, G) => {
        const X = me.parseComparedText(
          W[O],
          G[O],
          true,
          me.parseYMDFormat.bind(this, F.func, U)
        );
        return typeof X == "number" ? X : x2 ? me.compareDates(X[0], X[1]) : me.compareDates(X[1], X[0]);
      });
    }
    static sortColumn(D, w2, O) {
      const x2 = D.data.slice(1), { activeType: U } = D._columnsDetails[w2];
      U.calendar ? me.sortDates(U, x2, w2, O) : U.sorting ? me.sortViaSortFuncs(U, x2, w2, O) : me.sortStrings(x2, w2, O), me.update(D, x2);
    }
  };
  _Sort.DEFAULT_TYPES_SORT_FUNCS = {
    [DEFAULT_COLUMN_TYPES.NUMBER]: {
      ascendingFunc: (Y, D) => Number(Y) - Number(D),
      descendingFunc: (Y, D) => Number(D) - Number(Y)
    },
    [DEFAULT_COLUMN_TYPES.CURRENCY]: {
      ascendingFunc: (Y, D) => _Sort.extractNumberFromString(Y) - _Sort.extractNumberFromString(D),
      descendingFunc: (Y, D) => _Sort.extractNumberFromString(D) - _Sort.extractNumberFromString(Y)
    }
  };
  var Sort = _Sort;
  var _DefaultColumnTypes = class Et {
    // REF-28
    static createDropdownItemsForDefaultTypes() {
      Et.DEFAULT_TYPES.forEach((D) => {
        const w2 = {
          text: D.name,
          iconSettings: D.iconSettings || DropdownButtonItemConf.DEFAULT_ITEM.iconSettings
        };
        D.dropdownItem = {
          element: DropdownItem.createButtonItemNoEvents(void 0, w2),
          settings: w2
        };
      });
    }
  };
  _DefaultColumnTypes.FALLBACK_TYPE = {
    name: DEFAULT_COLUMN_TYPES.TEXT,
    iconSettings: {
      svgString: TEXT_ICON_SVG_STRING,
      containerStyles: {
        dropdown: { marginLeft: "-0.25px", marginRight: "6px", marginTop: "2.5px" },
        headerCorrections: { marginTop: "2.5px" }
      }
    }
  };
  _DefaultColumnTypes.DEFAULT_TYPES = [
    _DefaultColumnTypes.FALLBACK_TYPE,
    {
      name: DEFAULT_COLUMN_TYPES.NUMBER,
      textValidation: { func: Validation.DEFAULT_TYPES_FUNCTIONALITY[DEFAULT_COLUMN_TYPES.NUMBER] },
      sorting: Sort.DEFAULT_TYPES_SORT_FUNCS[DEFAULT_COLUMN_TYPES.NUMBER],
      iconSettings: {
        svgString: NUMBER_ICON_SVG_STRING,
        containerStyles: {
          dropdown: { marginLeft: "-1px", marginRight: "4.5px", marginTop: "2px" },
          headerCorrections: { marginTop: "2.5px" }
        }
      }
    },
    {
      name: DEFAULT_COLUMN_TYPES.CURRENCY,
      textValidation: { func: Validation.DEFAULT_TYPES_FUNCTIONALITY[DEFAULT_COLUMN_TYPES.CURRENCY] },
      sorting: Sort.DEFAULT_TYPES_SORT_FUNCS[DEFAULT_COLUMN_TYPES.CURRENCY],
      iconSettings: {
        svgString: CURRENCY_ICON_SVG_STRING,
        containerStyles: {
          dropdown: { marginLeft: "-2px", marginRight: "4px", marginTop: "1px" },
          headerCorrections: { marginRight: "3px", marginTop: "2px" }
        }
      }
    },
    {
      name: DEFAULT_COLUMN_TYPES.SELECT,
      select: {},
      iconSettings: {
        svgString: SELECT_ICON_SVG_STRING,
        containerStyles: {
          dropdown: { marginTop: "0px", marginRight: "3px", marginLeft: "-2.75px" },
          headerCorrections: { marginTop: "1px" }
        }
      }
    },
    {
      name: DEFAULT_COLUMN_TYPES.LABEL,
      label: {},
      iconSettings: {
        svgString: LABEL_ICON_SVG_STRING,
        containerStyles: {
          dropdown: { marginTop: "1.5px", marginRight: "5.5px", marginLeft: "-1px" },
          headerCorrections: { marginTop: "2.5px", marginRight: "5.5px", marginLeft: "0px" }
        }
      }
    },
    {
      name: DEFAULT_COLUMN_TYPES.CHECKBOX,
      iconSettings: {
        svgString: CHECKBOX_ICON_SVG_STRING,
        containerStyles: {
          dropdown: { marginRight: "6px", marginTop: "2px" },
          headerCorrections: { marginRight: "5px", marginLeft: "1px", marginTop: "3px" }
        }
      },
      checkbox: true,
      customTextProcessing: {
        changeTextFunc: CheckboxValidationFunc.getDefault()
      }
    },
    {
      name: DEFAULT_COLUMN_TYPES.DATE_DMY,
      textValidation: { func: Validation.DEFAULT_TYPES_FUNCTIONALITY[DEFAULT_COLUMN_TYPES.DATE_DMY] },
      calendar: CalendarFunctionalityUtils.DEFAULT_TYPES_FUNCTIONALITY[DEFAULT_COLUMN_TYPES.DATE_DMY],
      iconSettings: {
        svgString: CALENDAR_ICON_SVG_STRING,
        containerStyles: {
          dropdown: { marginLeft: "1.25px", marginRight: "8px", marginTop: "-1.5px" },
          headerCorrections: { marginTop: "0px" }
        }
      }
    },
    {
      name: DEFAULT_COLUMN_TYPES.DATE_MDY,
      textValidation: { func: Validation.DEFAULT_TYPES_FUNCTIONALITY[DEFAULT_COLUMN_TYPES.DATE_MDY] },
      calendar: CalendarFunctionalityUtils.DEFAULT_TYPES_FUNCTIONALITY[DEFAULT_COLUMN_TYPES.DATE_MDY],
      iconSettings: {
        svgString: CALENDAR_ICON_SVG_STRING,
        containerStyles: {
          dropdown: { marginLeft: "1.25px", marginRight: "8px", marginTop: "-1.5px" },
          headerCorrections: { marginTop: "0px" }
        }
      }
    }
  ];
  var DefaultColumnTypes = _DefaultColumnTypes;
  var DropdownButtonItemConf = class {
  };
  DropdownButtonItemConf.DEFAULT_ITEM = {
    text: DefaultColumnTypes.FALLBACK_TYPE.name,
    iconSettings: DefaultColumnTypes.FALLBACK_TYPE.iconSettings
  };
  var ColumnTypesUtils = class _ColumnTypesUtils {
    static getTypeByName(D, w2) {
      return D.find((O) => O.name.toLocaleLowerCase() === (w2 == null ? void 0 : w2.toLocaleLowerCase()));
    }
    static getTypeBasedOnProperties(D, w2) {
      if (w2) {
        const O = _ColumnTypesUtils.getTypeByName(D.types, w2);
        if (O)
          return O;
      }
      if (D.defaultColumnTypeName) {
        const O = _ColumnTypesUtils.getTypeByName(D.types, D.defaultColumnTypeName);
        if (O)
          return O;
      }
    }
    static getActiveType(D, w2) {
      const O = _ColumnTypesUtils.getTypeBasedOnProperties(D, w2);
      if (O)
        return O;
      const x2 = D.types.find((F) => !F.textValidation.func);
      if (x2)
        return x2;
      const U = D.types[0];
      return U || DefaultColumnTypes.FALLBACK_TYPE;
    }
    // prettier-ignore
    static getReusableDefaultIcon(D) {
      var x2;
      const w2 = (x2 = D.reusableIconName) == null ? void 0 : x2.toLocaleLowerCase(), O = DefaultColumnTypes.DEFAULT_TYPES.find((U) => U.name.toLocaleLowerCase() === w2);
      return O != null && O.iconSettings ? O.iconSettings : DropdownButtonItemConf.DEFAULT_ITEM.iconSettings;
    }
    static processDropdownItemSettings(D) {
      const { name: w2, iconSettings: O } = D;
      let x2;
      O ? O.reusableIconName ? x2 = _ColumnTypesUtils.getReusableDefaultIcon(O) : (x2 = O, Object.keys(O).length === 0 ? x2 = DropdownButtonItemConf.DEFAULT_ITEM.iconSettings : O.svgString || (x2.svgString ?? (x2.svgString = DropdownButtonItemConf.DEFAULT_ITEM.iconSettings.svgString), x2.containerStyles ?? (x2.containerStyles = DropdownButtonItemConf.DEFAULT_ITEM.iconSettings.containerStyles))) : x2 = DropdownButtonItemConf.DEFAULT_ITEM.iconSettings;
      const U = { text: w2, iconSettings: x2 }, F = D;
      F.dropdownItem ?? (F.dropdownItem = { element: null, settings: U }), setTimeout(() => {
        var W;
        (W = F.dropdownItem).element ?? (W.element = DropdownItem.createButtonItemNoEvents(void 0, U));
      });
    }
    static processTextValidationProps(D) {
      var w2;
      D.textValidation ?? (D.textValidation = {}), (w2 = D.textValidation).setTextToDefaultOnFail ?? (w2.setTextToDefaultOnFail = true);
    }
    static processCheckbox(D) {
      var w2;
      D.checkbox && !((w2 = D.customTextProcessing) != null && w2.changeTextFunc) && (D.customTextProcessing ?? (D.customTextProcessing = {}), D.customTextProcessing.changeTextFunc = CheckboxValidationFunc.getDefault());
    }
    static processSelectOptions(D) {
      if (typeof D.select == "object" && D.select.options) {
        const w2 = D.select;
        w2.options = D.select.options.map((O) => ({ text: O }));
      } else if (typeof D.label == "object" && D.label.options) {
        const w2 = D.label;
        w2.options = JSON.parse(JSON.stringify(D.label.options));
      }
    }
    static processSelect(D, w2, O) {
      var U;
      const x2 = D;
      D.select === true || D.label === true ? x2.cellDropdownProps = { isBasicSelect: !D.label } : (typeof D.select == "object" || typeof D.label == "object") && (x2.cellDropdownProps = D.select || D.label, x2.cellDropdownProps.isBasicSelect = !D.label, _ColumnTypesUtils.processSelectOptions(D), Validation.setSelectValidation(x2, w2, O)), x2.cellDropdownProps && x2.cellDropdownProps.canAddMoreOptions === void 0 && (x2.cellDropdownProps.canAddMoreOptions = !((U = x2.cellDropdownProps) != null && U.options));
    }
    // the reason why this is needed is when the argument is JSON stringified, properties that hold functions are removed,
    // hence they can only be applied to the component as strings
    static convertStringFunctionsToRealFunctions(D) {
      D.textValidation && ObjectUtils.convertStringToFunction(D.textValidation, "func"), D.customTextProcessing && (ObjectUtils.convertStringToFunction(D.customTextProcessing, "changeTextFunc"), ObjectUtils.convertStringToFunction(D.customTextProcessing, "changeStyleFunc")), D.sorting && (ObjectUtils.convertStringToFunction(D.sorting, "ascendingFunc"), ObjectUtils.convertStringToFunction(D.sorting, "descendingFunc")), D.calendar && (ObjectUtils.convertStringToFunction(D.calendar, "toYMDFunc"), ObjectUtils.convertStringToFunction(D.calendar, "fromYMDFunc"));
    }
    // this is important because when types get processed - their resultant structure is not be the same, hence if
    // the same one is used in different settings (e.g. defaultColumnTypes set in default and custom settings),
    // the processing of the same type again would not work
    // JSON.stringify loses element and function references, hence they need to be manually reassigned
    static createTypeDeepCopy(D) {
      const w2 = JSON.parse(JSON.stringify(D));
      return D.dropdownItem && (w2.dropdownItem = D.dropdownItem), D.textValidation && (w2.textValidation = D.textValidation), D.customTextProcessing && (w2.customTextProcessing = D.customTextProcessing), D.sorting && (w2.sorting = D.sorting), D.calendar && (w2.calendar = D.calendar), w2;
    }
    static process(D, w2, O) {
      return D.map((x2) => {
        const U = _ColumnTypesUtils.createTypeDeepCopy(x2);
        return _ColumnTypesUtils.convertStringFunctionsToRealFunctions(U), _ColumnTypesUtils.processSelect(U, w2, O), _ColumnTypesUtils.processCheckbox(U), _ColumnTypesUtils.processTextValidationProps(U), _ColumnTypesUtils.processDropdownItemSettings(U), U;
      });
    }
    static getAvailableTypes(D) {
      let w2 = [...DefaultColumnTypes.DEFAULT_TYPES];
      const { availableDefaultColumnTypes: O, customColumnTypes: x2 } = D;
      if (O) {
        const U = O.map((F) => F.toLocaleLowerCase());
        w2 = w2.filter((F) => U.indexOf(F.name.toLocaleLowerCase()) > -1);
      }
      return x2 && w2.push(...x2), w2.length === 0 && w2.push(DefaultColumnTypes.FALLBACK_TYPE), w2;
    }
    static getProcessedTypes(D) {
      const { isDefaultTextRemovable: w2, defaultText: O } = D, x2 = _ColumnTypesUtils.getAvailableTypes(D);
      return _ColumnTypesUtils.process(x2, w2, O);
    }
    // updates label color, date input etc.
    // prettier-ignore
    static updateDataElements(D, w2, O, x2) {
      const { _columnsDetails: U, _tableDimensions: F } = D, W = U[O];
      w2 !== 0 && (W.activeType.cellDropdownProps ? (CellDropdown.updateCellDropdown(
        x2,
        W.cellDropdown,
        F.border,
        W.settings.defaultText,
        true
      ), SelectCell.finaliseEditedText(D, x2.children[0], O, true)) : Browser.IS_INPUT_DATE_SUPPORTED && W.activeType.calendar && DateCellInputElement.updateInputBasedOnTextDiv(x2, W.activeType));
    }
  };
  var MoveUtils = class {
    // prettier-ignore
    static setNewElementText(D, w2, O, x2, U) {
      const F = CellElement.getText(O);
      return CellEvents.updateCell(D, w2, U, x2, { element: O, processText: false }), ColumnTypesUtils.updateDataElements(D, U, x2, O), F;
    }
  };
  var MoveColumn = class _MoveColumn {
    // prettier-ignore
    static overwriteDataElements(D, w2, O, x2) {
      w2.slice(1).forEach((U, F) => {
        const W = F + 1, G = x2[W];
        MoveUtils.setNewElementText(D, G, U, O, W);
      });
    }
    // prettier-ignore
    static changeSettings(D, w2, O, x2, U) {
      HeaderText.onAttemptChange(D, O, w2, { colMove: true }), U !== x2.activeType && ChangeColumnType.change.bind(D)(U.name, w2);
    }
    // prettier-ignore
    static overwrite(D, w2, O, x2, U, F) {
      const { elements: W, activeType: G } = w2;
      MoveUtils.setNewElementText(D, x2[0], W[0], O, 0), _MoveColumn.changeSettings(D, O, W[0], w2, U), _MoveColumn.overwriteDataElements(D, W, O, x2);
      const X = W[0].style.width;
      return W[0].style.width = F, { overwrittenType: G, overwrittenWidth: X };
    }
    static firstChangeSettingsIfSettingsChanged(D, w2) {
      const { areSettingsDifferent: O } = ColumnSettingsUtils.parseSettingsChange(D);
      if (O) {
        const x2 = D._columnsDetails[w2];
        HeaderText.onAttemptChange(D, x2.elements[0], w2);
      }
    }
    // prettier-ignore
    static move(D, w2, O) {
      _MoveColumn.firstChangeSettingsIfSettingsChanged(D, w2);
      const x2 = D._columnsDetails[w2], U = D._columnsDetails[w2].elements.map((q) => CellElement.getText(q));
      CellHighlightUtils.fade(x2.elements[0], x2 == null ? void 0 : x2.headerStateColors.default);
      const F = O ? w2 + 1 : w2 - 1, W = D._columnsDetails[F], G = W.elements.map((q) => CellElement.getText(q)), X = W.elements[0].style.width, K = _MoveColumn.overwrite(
        D,
        x2,
        w2,
        G,
        W.activeType,
        X
      );
      FocusedCellUtils.set(D._focusedElements.cell, W.elements[0], 0, F), _MoveColumn.overwrite(
        D,
        W,
        F,
        U,
        K.overwrittenType,
        K.overwrittenWidth
      ), setTimeout(() => FireEvents.onColumnsUpdate(D));
    }
  };
  var ColumnSizerGenericUtils = class {
    // the current solution for using first row position as 'relative' with divider having 100% height only works for
    // these browsers
    static canHeightBeInherited() {
      return Browser.IS_CHROMIUM || Browser.IS_FIREFOX;
    }
    static getSizerDetailsViaElementId(D, w2) {
      const O = Number(RegexUtils.extractIntegerStrs(D)[0]), x2 = w2[O];
      return { columnSizer: x2.columnSizer, headerCell: x2.elements[0], sizerNumber: O };
    }
    static findNextResizableColumnHeader(D, w2) {
      const O = D.slice(w2 + 1).find((x2) => {
        var U;
        return !((U = x2.settings.widths) != null && U.staticWidth);
      });
      return O == null ? void 0 : O.elements[0];
    }
  };
  var _UpdateRowElement = class Ke {
    // required to allow the divider and all its elements to inherit its height (in non chrome or firefox browsers)
    static updateHeaderRowHeight(D) {
      ColumnSizerGenericUtils.canHeightBeInherited() || (D.style.height = Ke.UNSET, D.style.height = getComputedStyle(D).height);
    }
    // if this does not capture all events - use in HeaderText.onAttemptChange method instead
    static updateHeadRowHeightOnKeyDown(D) {
      var w2;
      if (!ColumnSizerGenericUtils.canHeightBeInherited()) {
        const O = (w2 = D.children) == null ? void 0 : w2[0];
        O && O.style.height !== Ke.UNSET && (O.style.height = Ke.UNSET, setTimeout(() => {
          O.style.height = `${O.offsetHeight}px`;
        }));
      }
    }
    static getUnsetHeightFunc(D, w2) {
      if (!ColumnSizerGenericUtils.canHeightBeInherited() && w2 === 0)
        return () => D.style.height = Ke.UNSET;
    }
  };
  _UpdateRowElement.UNSET = "unset";
  var UpdateRowElement = _UpdateRowElement;
  var RowHoverEvents = class _RowHoverEvents {
    static canStyleBeApplied(D, w2, O) {
      return (O > 0 || D.header) && (!AddNewRowElement.isAddNewRowRow(w2) || D.addNewRowButton);
    }
    static getRemoveColorFunc(D, w2, O, x2) {
      const U = D.rowHoverStyles;
      if (U != null && U.style && _RowHoverEvents.canStyleBeApplied(U, w2, O))
        return () => {
          ElementStyle.unsetStyle(w2, U.style), Object.assign(w2.style, x2);
        };
    }
    static addMouseLeaveEvent(D, w2, O, x2) {
      const U = _RowHoverEvents.getRemoveColorFunc(D, w2, O, x2), F = UpdateRowElement.getUnsetHeightFunc(w2, O);
      w2.onmouseleave = () => {
        U == null || U(), F == null || F();
      };
    }
    // prettier-ignore
    static addMouseEnterEvent(D, w2, O) {
      const { rowHoverStyles: x2, _focusedElements: { rowDragEl: U } } = D, F = x2 != null && x2.style && _RowHoverEvents.canStyleBeApplied(x2, w2, O) ? () => Object.assign(w2.style, x2 == null ? void 0 : x2.style) : void 0;
      w2.onmouseenter = () => {
        U || F == null || F();
      };
    }
    static addEvents(D, w2, O, x2) {
      _RowHoverEvents.addMouseEnterEvent(D, w2, O), _RowHoverEvents.addMouseLeaveEvent(D, w2, O, x2);
    }
    static process(D, w2) {
      D != null && D.style && (D.header ?? (D.header = true), D.addNewRowButton ?? (D.addNewRowButton = true), CellHighlightUtils.unsetDefaultHoverProperties(w2));
    }
  };
  var _StripedRows = class tt {
    static setRowStyle(D, w2, O) {
      const x2 = w2 % 2 ? O.even : O.odd;
      return Object.assign(D.style, x2), x2;
    }
    static process(D) {
      const { stripedRows: w2, _defaultCellHoverColors: O } = D;
      w2 && (typeof w2 == "boolean" ? D._stripedRows = tt.DEFAULT_PROPERTIES : D._stripedRows = {
        even: w2.even || tt.DEFAULT_PROPERTIES.even,
        odd: w2.odd || tt.DEFAULT_PROPERTIES.odd
      }, CellHighlightUtils.unsetDefaultHoverProperties(O));
    }
  };
  _StripedRows.DEFAULT_PROPERTIES = {
    odd: { backgroundColor: "" },
    even: { backgroundColor: "#dcdcdc7a" }
  };
  var StripedRows = _StripedRows;
  var CustomRowProperties = class _CustomRowProperties {
    static setStyle(D, w2, O, x2) {
      if (D._stripedRows)
        return x2 && AddNewRowElement.isAddNewRowRow(w2) && (O = +!D.dataStartsAtHeader), StripedRows.setRowStyle(w2, O, D._stripedRows);
    }
    // prettier-ignore
    static updateRow(D, w2, O, x2, U) {
      const F = _CustomRowProperties.setStyle(D, w2, O, x2);
      O === U ? RowHoverEvents.addEvents(D, w2, O, F) : setTimeout(() => {
        RowHoverEvents.addEvents(D, w2, O, F);
      });
    }
    // REF-32
    static isAddRowRowSame(D) {
      return !!(D.pagination && D._frameComponents.displayAddNewRow && PaginationUtils.getLastPossiblePageNumber(D) !== D._pagination.activePageNumber);
    }
    // this can be considered to be wasteful if no striped rows are used and we are resetting the same row events
    // every time this is called, however we are still traversing all rows from startIndex for code simplicity
    static update(D, w2 = 0) {
      if (!D._tableBodyElementRef)
        return;
      const O = Array.from(D._tableBodyElementRef.children), x2 = _CustomRowProperties.isAddRowRowSame(D), U = O.length - 1;
      O.slice(w2).forEach((F, W) => {
        const G = W + w2;
        _CustomRowProperties.updateRow(D, F, G, x2, U);
      });
    }
  };
  var MoveRow = class _MoveRow {
    // prettier-ignore
    static overwrite(D, w2, O) {
      const x2 = [];
      return D._columnsDetails.forEach((U, F) => {
        const W = MoveUtils.setNewElementText(
          D,
          w2[F],
          U.elements[O],
          F,
          O
        );
        x2.push(W);
      }), x2;
    }
    static moveDataRows(D, w2, O) {
      const x2 = D._columnsDetails.map(({ elements: F }) => CellElement.getText(F[O])), U = _MoveRow.overwrite(D, x2, w2);
      _MoveRow.overwrite(D, U, O);
    }
    static resetFocusedCell(D, w2) {
      const { _frameComponents: O, _focusedElements: x2 } = D, { element: U, rowIndex: F, columnIndex: W } = w2;
      O.displayIndexColumn ? FocusedCellUtils.setIndexCell(x2.cell, U, F) : FocusedCellUtils.set(x2.cell, U, F, W);
    }
    static moveHeaderToDataRow(D) {
      const { _columnsDetails: w2, _focusedElements: O } = D, x2 = { ...O.cell }, U = w2.map(({ elements: W }) => CellElement.getText(W[1])), F = _MoveRow.overwrite(D, U, 0);
      w2.forEach((W, G) => {
        FocusedCellUtils.set(O.cell, W.elements[0], 0, G), HeaderText.onAttemptChange(D, W.elements[0], G);
      }), _MoveRow.overwrite(D, F, 1), _MoveRow.resetFocusedCell(D, x2);
    }
    static move(D, w2, O) {
      const x2 = O ? w2 + 1 : w2 - 1;
      w2 === 0 || x2 === 0 ? _MoveRow.moveHeaderToDataRow(D) : _MoveRow.moveDataRows(D, w2, x2), CustomRowProperties.update(D, w2), D.pagination && PaginationUtils.updateOnRowMove(D, x2);
    }
  };
  var _Drag = class gt {
    static move(D, w2, O) {
      if (w2 === 0)
        return;
      const x2 = w2 > 0, U = x2 ? 1 : -1;
      for (let F = 0; F < Math.abs(w2); F += 1)
        O(D, gt.ORIGINAL_INDEX + F * U, x2);
      setTimeout(() => FocusedCellUtils.purge(D._focusedElements.cell), 5);
    }
  };
  _Drag.CELL_HIDDEN_CLASS = "cell-hidden";
  _Drag.DRAG_PX_TO_MOVE = 10;
  _Drag.ORIGINAL_INDEX = 0;
  var Drag = _Drag;
  var _DragRow = class J extends Drag {
    static resetElements(D) {
      var O, x2;
      (O = J.CLONE_ROW) == null || O.remove(), Array.from(D.children || []).forEach((U) => {
        U.classList.remove(Drag.CELL_HIDDEN_CLASS);
      }), (x2 = J.TARGET_LINE) == null || x2.remove();
    }
    static appendTargetLine(D) {
      J.TARGET_LINE = document.createElement("div"), J.TARGET_LINE.classList.add("row-drag-target-line"), J.TARGET_LINE.style.opacity = "0", D.appendChild(J.TARGET_LINE);
    }
    static prepareElements(D, w2, O) {
      w2.classList.add(J.ROW_CLONE_CLASS), w2.style.top = `${O.offsetTop}px`;
      const x2 = `${O.children[0].offsetHeight}px`, U = Array.from(O.children || []);
      Array.from(w2.children).forEach((F, W) => {
        F.style.width = `${U[W].offsetWidth}px`, F.style.height = x2;
      }), U.forEach((F) => {
        F.classList.add(Drag.CELL_HIDDEN_CLASS);
      }), J.appendTargetLine(D);
    }
    static calculateThresholdDown(D) {
      J.TARGET_DOWN_ROW && D && (J.THRESHOLD_DOWN = J.TARGET_DOWN_ROW.offsetTop + J.TARGET_DOWN_ROW.offsetHeight / 2 - D.offsetHeight);
    }
    static calculateThresholdUp() {
      J.TARGET_UP_ROW && (J.THRESHOLD_UP = J.TARGET_UP_ROW.offsetTop + J.TARGET_UP_ROW.offsetHeight / 2);
    }
    static initiateDragState(D, w2, O) {
      var F;
      if (J.TARGET_UP_ROW = O.previousSibling, J.TARGET_DOWN_ROW = (F = O.nextSibling) == null ? void 0 : F.nextSibling, !J.TARGET_UP_ROW && AddNewRowElement.isAddNewRowRow(J.TARGET_DOWN_ROW.children[0]))
        return;
      J.CLONE_ROW = w2, J.ACTIVE_ROW_TOP_PX = O.offsetTop, J.ACTIVE_INDEX = 0, J.calculateThresholdUp(), J.calculateThresholdDown(O);
      const x2 = Array.from(D.children);
      Drag.ORIGINAL_INDEX = x2.findIndex((W) => W === O);
      const U = x2[x2.length - 2].offsetHeight;
      J.MAX_DOWN = D.offsetHeight - O.offsetHeight - U;
    }
    static processRowCellsToDrag(D, w2) {
      const O = w2.parentElement;
      O.dispatchEvent(new MouseEvent("mouseleave"));
      const x2 = O.cloneNode(true);
      return O == null || O.insertAdjacentElement("afterend", x2), J.prepareElements(D, x2, O), J.initiateDragState(D, x2, O), O;
    }
    static applyEventsToElement(D, w2, O) {
      J.isDisabled(D) || (w2.onmousedown = () => {
        J.IS_MOUSE_DOWN = true;
      }, w2.onmousemove = () => {
        J.IS_MOUSE_DOWN && !D._focusedElements.rowDragEl && D._tableBodyElementRef && (J.INITIALISING_DRAG_PX += 1, J.INITIALISING_DRAG_PX > Drag.DRAG_PX_TO_MOVE && (D._focusedElements.rowDragEl = J.processRowCellsToDrag(D._tableBodyElementRef, O), FocusedCellUtils.set(D._focusedElements.cell, O, 0, Drag.ORIGINAL_INDEX)));
      });
    }
    static moveTargetLine(D, w2) {
      D.style.opacity = "1", D.style.top = `${w2}px`;
    }
    // Upon approaching the original row the target line is hidden
    static removeLineOnMoveDown(D) {
      D.style.opacity = "0", J.ACTIVE_INDEX = 0, J.THRESHOLD_TO_NO_LINE_DOWN = -1, J.calculateThresholdUp();
    }
    static attemptSwitchUp(D, w2) {
      var O;
      J.TARGET_UP_ROW && w2 && (((O = J.TARGET_UP_ROW.previousSibling) == null ? void 0 : O.previousSibling) === w2 ? (J.THRESHOLD_TO_NO_LINE_UP = w2.offsetTop + w2.offsetHeight / 2, J.THRESHOLD_DOWN = J.TARGET_UP_ROW.offsetTop + J.TARGET_UP_ROW.offsetHeight / 2, J.TARGET_DOWN_ROW = J.TARGET_UP_ROW, J.TARGET_UP_ROW = w2.previousSibling, J.TARGET_UP_ROW ? J.calculateThresholdUp() : J.THRESHOLD_UP = -1) : (J.moveTargetLine(D, J.TARGET_UP_ROW.offsetTop - 3), J.THRESHOLD_DOWN = J.THRESHOLD_UP, J.TARGET_DOWN_ROW = J.TARGET_UP_ROW, J.TARGET_UP_ROW = J.TARGET_UP_ROW.previousSibling, J.calculateThresholdUp(), J.ACTIVE_INDEX -= 1));
    }
    // Upon approaching the original row the target line is hidden
    static removeLineOnMoveUp(D, w2) {
      D.style.opacity = "0", J.ACTIVE_INDEX = 0, J.THRESHOLD_TO_NO_LINE_UP = -1, J.calculateThresholdDown(w2);
    }
    static attemptSwitchDown(D, w2) {
      var O;
      J.TARGET_DOWN_ROW && (J.TARGET_DOWN_ROW.nextSibling === w2 ? (J.THRESHOLD_TO_NO_LINE_DOWN = J.TARGET_DOWN_ROW.offsetTop + J.TARGET_DOWN_ROW.offsetHeight / 2, J.TARGET_UP_ROW = J.TARGET_DOWN_ROW, J.THRESHOLD_UP = J.TARGET_UP_ROW.offsetTop - J.TARGET_UP_ROW.offsetHeight / 2, J.TARGET_DOWN_ROW = (O = w2 == null ? void 0 : w2.nextSibling) == null ? void 0 : O.nextSibling, J.calculateThresholdDown(w2)) : (J.moveTargetLine(D, J.TARGET_DOWN_ROW.offsetTop + J.TARGET_DOWN_ROW.offsetHeight - 3), J.THRESHOLD_UP = J.THRESHOLD_DOWN, J.TARGET_UP_ROW = J.TARGET_DOWN_ROW, J.TARGET_DOWN_ROW = J.TARGET_DOWN_ROW.nextSibling, J.calculateThresholdDown(w2), J.ACTIVE_INDEX += 1));
    }
    static windowDrag(D, w2) {
      if (J.isDisabled(D) || !J.TARGET_LINE || !D._focusedElements.rowDragEl || !J.CLONE_ROW)
        return;
      const O = Math.max(0, J.ACTIVE_ROW_TOP_PX + w2.movementY), x2 = Math.min(O, J.MAX_DOWN);
      J.ACTIVE_ROW_TOP_PX = x2, J.CLONE_ROW.style.top = `${J.ACTIVE_ROW_TOP_PX}px`, J.ACTIVE_ROW_TOP_PX > J.THRESHOLD_DOWN ? J.attemptSwitchDown(J.TARGET_LINE, D._focusedElements.rowDragEl) : J.ACTIVE_ROW_TOP_PX < J.THRESHOLD_UP ? J.attemptSwitchUp(J.TARGET_LINE, D._focusedElements.rowDragEl) : J.THRESHOLD_TO_NO_LINE_DOWN >= 0 && J.THRESHOLD_TO_NO_LINE_DOWN < J.ACTIVE_ROW_TOP_PX ? J.removeLineOnMoveDown(J.TARGET_LINE) : J.THRESHOLD_TO_NO_LINE_UP >= 0 && J.THRESHOLD_TO_NO_LINE_UP > J.ACTIVE_ROW_TOP_PX && J.removeLineOnMoveUp(J.TARGET_LINE, D._focusedElements.rowDragEl);
    }
    static windowMouseUp(D) {
      J.IS_MOUSE_DOWN = false, !J.isDisabled(D) && D._focusedElements.rowDragEl && (J.resetElements(D._focusedElements.rowDragEl), delete D._focusedElements.rowDragEl, J.INITIALISING_DRAG_PX = 0, J.move(D, J.ACTIVE_INDEX, MoveRow.move));
    }
    // row dragging is cumbersome when filter/pagination enabled as some rows are hidden
    static isDisabled(D) {
      return D.dragRows === false || D.filter || D.pagination;
    }
  };
  _DragRow.ROW_CLONE_CLASS = "row-clone";
  _DragRow.INITIALISING_DRAG_PX = 0;
  _DragRow.ACTIVE_ROW_TOP_PX = 0;
  _DragRow.CLONE_ROW = null;
  _DragRow.IS_MOUSE_DOWN = false;
  _DragRow.ACTIVE_INDEX = 0;
  _DragRow.THRESHOLD_UP = 0;
  _DragRow.THRESHOLD_DOWN = 0;
  _DragRow.MAX_DOWN = 0;
  _DragRow.THRESHOLD_TO_NO_LINE_DOWN = -1;
  _DragRow.THRESHOLD_TO_NO_LINE_UP = -1;
  var DragRow = _DragRow;
  var _DragColumn = class Z extends Drag {
    static setHeaderElementsToDefault(D) {
      var O;
      const w2 = (O = D.parentElement) == null ? void 0 : O.children;
      Z.CLONE_CELLS.forEach((x2) => x2.remove()), Array.from(w2 || []).forEach((x2) => {
        x2.tagName === CellElement.HEADER_TAG && x2.classList.remove(Drag.CELL_HIDDEN_CLASS);
      }), Z.DIVIDERS.forEach((x2) => {
        x2.style.pointerEvents = "";
      });
    }
    static applyCloneHeaderCell(D, w2, O, x2) {
      w2.classList.add(Drag.CELL_HIDDEN_CLASS), D.classList.add(Z.HEADER_CELL_CLONE_CLASS), D.classList.add(Z.HEADER_CELL_CLONE_ANIMATION_CLASS), D.style.left = `${w2.offsetLeft}px`, D.style.height = x2, O == null || O.insertAdjacentElement("beforebegin", D), Z.CLONE_CELLS.push(D), Z.REAL_CELLS.push(w2);
    }
    static getThreshold(D, w2) {
      const O = Z.REAL_CELLS[Z.ACTIVE_INDEX + w2], x2 = Math.min(D.offsetWidth / 2, (O == null ? void 0 : O.offsetWidth) / 2) * w2;
      return D.offsetLeft + x2;
    }
    static initiateDragState(D, w2) {
      if (Z.ACTIVE_INDEX = Z.REAL_CELLS.findIndex((W) => w2 === W), Z.ACTIVE_INDEX + 2 >= Z.CLONE_CELLS.length && Z.ACTIVE_INDEX - 1 <= 0)
        return;
      D._focusedElements.colDragEl = Z.CLONE_CELLS[Z.ACTIVE_INDEX], D._focusedElements.colDragEl.classList.remove(Z.HEADER_CELL_CLONE_ANIMATION_CLASS), Z.ACTIVE_CELL_LEFT_PX = w2.offsetLeft, Z.THRESHOLD_LEFT = Z.getThreshold(w2, -1), Z.THRESHOLD_RIGHT = Z.getThreshold(w2, 1);
      const O = Z.REAL_CELLS[0];
      Z.MIN_LEFT = O.classList.contains(IndexColumn.INDEX_CELL_CLASS) ? O.offsetWidth : 0;
      const x2 = Z.REAL_CELLS[Z.REAL_CELLS.length - 1], U = x2.classList.contains(AddNewColumnElement.ADD_COLUMN_CELL_CLASS) ? 0 : x2.offsetWidth;
      Z.MAX_LEFT = x2.offsetLeft + U - w2.offsetWidth;
      const F = Z.REAL_CELLS[0].classList.contains(IndexColumn.INDEX_CELL_CLASS);
      Drag.ORIGINAL_INDEX = Z.ACTIVE_INDEX - (F ? 1 : 0);
    }
    static processHeaderCellsToDrag(D, w2, O) {
      var U;
      const x2 = `${w2.offsetHeight}px`;
      Array.from(((U = w2.parentElement) == null ? void 0 : U.children) || []).forEach((F) => {
        if (F.tagName === CellElement.HEADER_TAG) {
          const W = F.cloneNode(true);
          Z.applyCloneHeaderCell(W, F, O, x2);
        } else
          F.style.pointerEvents = "none", Z.DIVIDERS.push(F);
      }), Z.initiateDragState(D, w2);
    }
    static applyEventsToElement(D, w2, O) {
      D.dragColumns !== false && (w2.onmousedown = () => {
        Z.IS_MOUSE_DOWN = true;
      }, w2.onmousemove = () => {
        var x2;
        if (Z.IS_MOUSE_DOWN && !D._focusedElements.colDragEl && (Z.INITIALISING_DRAG_PX += 1, Z.INITIALISING_DRAG_PX > Drag.DRAG_PX_TO_MOVE)) {
          const U = (x2 = O.parentElement) == null ? void 0 : x2.children[O.parentElement.children.length - 1];
          Z.processHeaderCellsToDrag(D, O, U), FocusedCellUtils.set(D._focusedElements.cell, O, 0, Drag.ORIGINAL_INDEX);
        }
      });
    }
    static switch(D) {
      const w2 = Z.CLONE_CELLS[Z.ACTIVE_INDEX], O = Z.CLONE_CELLS[Z.ACTIVE_INDEX + D];
      D > 0 ? (Z.THRESHOLD_LEFT = Z.THRESHOLD_RIGHT - 5, Z.THRESHOLD_RIGHT = w2.offsetLeft + O.offsetWidth, O.style.left = `${O.offsetLeft - w2.offsetWidth}px`) : (Z.THRESHOLD_RIGHT = Z.THRESHOLD_LEFT + 5, Z.THRESHOLD_LEFT = w2.offsetLeft - O.offsetWidth, O.style.left = `${O.offsetLeft + w2.offsetWidth}px`), ArrayUtils.swap(Z.CLONE_CELLS, Z.ACTIVE_INDEX, Z.ACTIVE_INDEX + D), Z.ACTIVE_INDEX += D;
    }
    static windowDrag(D, w2, O) {
      if (D.dragColumns === false)
        return;
      const x2 = Math.max(Z.MIN_LEFT, Z.ACTIVE_CELL_LEFT_PX + O.movementX), U = Math.min(x2, Z.MAX_LEFT);
      Z.ACTIVE_CELL_LEFT_PX = U, w2.style.left = `${Z.ACTIVE_CELL_LEFT_PX}px`, Z.ACTIVE_CELL_LEFT_PX > Z.THRESHOLD_RIGHT ? Z.switch(1) : Z.ACTIVE_CELL_LEFT_PX < Z.THRESHOLD_LEFT && Z.switch(-1);
    }
    static windowMouseUp(D) {
      if (Z.IS_MOUSE_DOWN = false, D.dragColumns === false || !D._focusedElements.colDragEl)
        return;
      Z.setHeaderElementsToDefault(D._focusedElements.colDragEl), delete D._focusedElements.colDragEl, Z.INITIALISING_DRAG_PX = 0, Z.ACTIVE_CELL_LEFT_PX = 0, Z.CLONE_CELLS = [], Z.DIVIDERS = [];
      const w2 = Z.REAL_CELLS[0].classList.contains(IndexColumn.INDEX_CELL_CLASS);
      DragRow.move(D, Z.ACTIVE_INDEX - Drag.ORIGINAL_INDEX - (w2 ? 1 : 0), MoveColumn.move), Z.REAL_CELLS = [];
    }
  };
  _DragColumn.HEADER_CELL_CLONE_CLASS = "header-cell-clone";
  _DragColumn.HEADER_CELL_CLONE_ANIMATION_CLASS = "header-cell-clone-animation";
  _DragColumn.INITIALISING_DRAG_PX = 0;
  _DragColumn.ACTIVE_CELL_LEFT_PX = 0;
  _DragColumn.IS_MOUSE_DOWN = false;
  _DragColumn.CLONE_CELLS = [];
  _DragColumn.REAL_CELLS = [];
  _DragColumn.DIVIDERS = [];
  _DragColumn.ACTIVE_INDEX = 0;
  _DragColumn.THRESHOLD_RIGHT = 0;
  _DragColumn.THRESHOLD_LEFT = 0;
  _DragColumn.MAX_LEFT = 0;
  _DragColumn.MIN_LEFT = 0;
  var DragColumn = _DragColumn;
  var DropdownCellOverlay = class {
  };
  DropdownCellOverlay.HIDDEN_PX = "0px";
  DropdownCellOverlay.VISIBLE_PX = "10px";
  DropdownCellOverlay.DROPDOWN_CELL_OVERLAY_CLASS = "dropdown-cell-overlay";
  var _ColumnDropdownCellOverlay = class Le {
    static setDefault(D, w2) {
      var O;
      D.style.backgroundColor = ((O = w2 == null ? void 0 : w2.default) == null ? void 0 : O.backgroundColor) || "";
    }
    static resetDefaultColor(D, w2) {
      var x2;
      const O = w2 == null ? void 0 : w2.overlayStyles;
      (x2 = O == null ? void 0 : O.hover) != null && x2.backgroundColor && Le.setDefault(D, O);
    }
    static setHoverColor(D, w2) {
      var x2, U;
      const O = (U = (x2 = w2 == null ? void 0 : w2.overlayStyles) == null ? void 0 : x2.hover) == null ? void 0 : U.backgroundColor;
      O && (D.columnDropdownCellOverlay.style.backgroundColor = O);
    }
    static hide(D, w2) {
      const { columnDropdownCellOverlay: O } = w2, x2 = D._hoveredElements.headerCell;
      setTimeout(() => {
        x2 !== D._hoveredElements.headerCell && (O.style.height = DropdownCellOverlay.HIDDEN_PX);
      });
    }
    static setHorizontalDimensions(D) {
      const { columnDropdownCellOverlay: w2, elements: O } = D, x2 = O[0].offsetWidth / 100;
      w2.style.width = `${x2 * 50}px`, w2.style.right = `${x2 * 25}px`;
    }
    static display(D) {
      D.columnDropdownCellOverlay.style.height = DropdownCellOverlay.VISIBLE_PX, Le.setHorizontalDimensions(D);
    }
    static isDisplayed(D) {
      return D.style.height === DropdownCellOverlay.VISIBLE_PX;
    }
    static updateIfDisplayed(D) {
      Le.isDisplayed(D.columnDropdownCellOverlay) && Le.setHorizontalDimensions(D);
    }
    static create(D, w2, O) {
      const x2 = document.createElement("div");
      return x2.classList.add(DropdownCellOverlay.DROPDOWN_CELL_OVERLAY_CLASS), x2.classList.add(Le.COLUMN_DROPDOWN_CELL_OVERLAY_CLASS), x2.style.height = DropdownCellOverlay.HIDDEN_PX, Le.setDefault(x2, O), DragColumn.applyEventsToElement(D, x2, w2), x2;
    }
    static add(D, w2) {
      var W, G;
      const O = (G = (W = D._defaultColumnsSettings.columnDropdown) == null ? void 0 : W.displaySettings) == null ? void 0 : G.overlayStyles, x2 = D._columnsDetails[w2].elements[0], U = Le.create(D, x2, O);
      return x2.nextSibling.appendChild(U), U;
    }
  };
  _ColumnDropdownCellOverlay.COLUMN_DROPDOWN_CELL_OVERLAY_CLASS = "column-dropdown-cell-overlay";
  var ColumnDropdownCellOverlay = _ColumnDropdownCellOverlay;
  var _MovableColumnSizerElement = class Ie {
    // this is recalculated as it depends on the column index that the sizer is on
    static setStaticProperties(D, w2, O) {
      D.style.marginRight = w2, D.style.width = O;
    }
    // the vertical line has no pointer events, hence it should not be expected to be passed in here
    static isMovableColumnSizer(D) {
      return D.classList.contains(Ie.MOVABLE_SIZER_CLASS);
    }
    static getVerticalLineHeight(D, w2) {
      let O = D.offsetHeight;
      if (w2) {
        const x2 = D.lastChild.offsetHeight;
        O -= x2;
      }
      return O;
    }
    static display(D, w2, O) {
      const x2 = w2.movableElement;
      x2.style.display = "flex";
      const U = x2.children[0];
      U.style.height = `${Ie.getVerticalLineHeight(D, O)}px`;
    }
    static hide(D) {
      D.style.display = "none", D.style.left = "";
    }
    static createVerticalLine(D) {
      const w2 = document.createElement("div");
      return w2.style.backgroundColor = D, w2.classList.add(Ie.VERTICAL_LINE_CLASS), w2;
    }
    static getMovableBackgroundColor(D) {
      return D.click || D.hover || Ie.DEFAULT_BACKGROUND_COLOR;
    }
    static create(D) {
      const w2 = Ie.getMovableBackgroundColor(D), O = document.createElement("div");
      O.style.backgroundColor = w2, O.classList.add(Ie.MOVABLE_SIZER_CLASS), Ie.hide(O);
      const x2 = Ie.createVerticalLine(w2);
      return O.appendChild(x2), O;
    }
  };
  _MovableColumnSizerElement.DEFAULT_BACKGROUND_COLOR = "#4668ed";
  _MovableColumnSizerElement.MOVABLE_SIZER_CLASS = "movable-column-sizer";
  _MovableColumnSizerElement.VERTICAL_LINE_CLASS = "movable-column-sizer-vertical-line";
  var MovableColumnSizerElement = _MovableColumnSizerElement;
  var MoveLimits = class _MoveLimits {
    // Borders of the side cells tend to breach over the limits of the table (when no side frame elements),
    // causing the offsets to give incorrect data and set the limits beyond the table. The breach magnitude is
    // influenced by the sizer start position when cells have borders - which is the very center position of
    // the total of those two borders width.
    // prettier-ignore
    static getSideLimitDelta(D) {
      const w2 = ExtractElements.getRightColumnSiblingCell(D);
      return ((Number.parseFloat(getComputedStyle(D).borderRightWidth) || 0) - (Number.parseFloat(getComputedStyle(w2).borderLeftWidth) || 0)) / 2;
    }
    static getRightLimitDynamicWidthTable() {
      return window.innerWidth;
    }
    // prettier-ignore
    static getRightLimitForMaxWidth(D, w2, O) {
      return StaticTable.isTableAtMaxWidth(D, w2) ? O ? Number.parseFloat(O.style.width) : 0 : w2.maxWidth - D.offsetWidth;
    }
    static getRightLimit(D, w2) {
      return D._tableDimensions.width !== void 0 ? Number.parseFloat(w2.style.width) : D._tableDimensions.maxWidth !== void 0 && D._tableElementRef ? _MoveLimits.getRightLimitForMaxWidth(D._tableElementRef, D._tableDimensions, w2) : _MoveLimits.getRightLimitDynamicWidthTable();
    }
    static getLeftLimit(D, w2) {
      let O = -D.offsetWidth;
      return w2 !== void 0 && (O += w2), O;
    }
    // prettier-ignore
    static generate(D, w2, O, x2, U, F) {
      const W = w2 || O ? _MoveLimits.getSideLimitDelta(F) : 0;
      return {
        left: _MoveLimits.getLeftLimit(F, w2 ? W : void 0) + x2,
        right: _MoveLimits.getRightLimit(D, U)
      };
    }
  };
  var SelectedColumnSizer = class _SelectedColumnSizer {
    // prettier-ignore
    static generateObj(D, w2, O, x2, U, F) {
      const W = w2.movableElement.offsetLeft;
      return {
        element: w2.element,
        moveLimits: MoveLimits.generate(D, O, x2, W, F, U),
        // this is to reflect the initial sizer offset to center itself in the cell divider
        initialOffset: W,
        mouseMoveOffset: W,
        fireColumnsUpdate: FireEvents.onColumnsUpdate.bind(this, D)
      };
    }
    static get(D, w2) {
      const O = D._columnsDetails[w2].columnSizer, x2 = w2 === 0, U = D._columnsDetails.length - 2 === w2, F = D._columnsDetails[w2].elements[0], W = ColumnSizerGenericUtils.findNextResizableColumnHeader(D._columnsDetails, w2);
      return _SelectedColumnSizer.generateObj(D, O, x2, U, F, W);
    }
  };
  var SEMI_TRANSPARENT_COLOR = "#ffffff01";
  var ColumnSizer = class _ColumnSizer {
    static shouldWidthBeIncreased(D) {
      return D > 4;
    }
    // prettier-ignore
    static getBackgroundImage(D, w2, O, x2, U) {
      if (x2 && U) {
        if (Number.parseInt(getComputedStyle(U).borderRightWidth) > 0 && (w2 > 0 || O === void 0 || O > 0))
          return ColumnSizerElement.EMPTY_BACKGROUND_IMAGE;
      } else if (D > 0)
        return ColumnSizerElement.EMPTY_BACKGROUND_IMAGE;
      return ColumnSizerElement.FILLED_BACKGROUND_IMAGE;
    }
    static getMarginRight(D, w2) {
      return w2 || !D ? "0px" : `${D.leftCellRight - D.rightCellLeft}px`;
    }
    static getTotalCellBorderWidth(D) {
      return D ? D.rightCellLeft + D.leftCellRight : 0;
    }
    static generateBorderWidthsInfo(D, w2) {
      var W, G, X;
      const O = {
        rightCellLeft: 0,
        leftCellLeft: 0,
        leftCellRight: 0,
        beforeLeftCellRight: void 0
      }, x2 = (W = D[w2 - 1]) == null ? void 0 : W.elements[0];
      x2 && (O.beforeLeftCellRight = Number.parseInt(getComputedStyle(x2).borderRightWidth) || 0);
      const U = (G = D[w2]) == null ? void 0 : G.elements[0];
      if (U) {
        const K = getComputedStyle(U);
        O.leftCellLeft = Number.parseInt(K.borderLeftWidth) || 0, O.leftCellRight = Number.parseInt(K.borderRightWidth) || 0;
      }
      const F = (X = D[w2 + 1]) == null ? void 0 : X.elements[0];
      return F && (O.rightCellLeft = Number.parseInt(getComputedStyle(F).borderLeftWidth) || 0), O;
    }
    // prettier-ignore
    static createObject(D, w2, O, x2, U, F, W) {
      const G = _ColumnSizer.generateBorderWidthsInfo(w2, O), X = _ColumnSizer.getTotalCellBorderWidth(G), K = w2.length - 1 === O, q = _ColumnSizer.getMarginRight(G, K), Q = _ColumnSizer.getBackgroundImage(
        X,
        G.leftCellLeft,
        G.beforeLeftCellRight,
        K,
        x2
      ), le = _ColumnSizer.shouldWidthBeIncreased(X), re = {
        element: D,
        styles: {
          default: {
            width: le ? `${X + 2}px` : "1.5px",
            backgroundImage: Q
          },
          hover: {
            width: le ? `${(X + 2) * 1.5}px` : "9px"
          },
          static: {
            marginRight: q
          }
        },
        isSideCellHovered: false,
        isSizerHovered: false,
        isMouseUpOnSizer: false
      };
      return W && (re.hoverColor = W.hover || ColumnSizerElement.DEFAULT_HOVER_COLOR), F && (re.movableElement = F), U && (re.overlayElement = U), re;
    }
    // prettier-ignore
    static create(D, w2) {
      const { _columnsDetails: O, _tableElementRef: x2, columnResizerColors: U } = D, F = ColumnSizerElement.create(w2, U.hover), W = MovableColumnSizerElement.create(U), G = ColumnSizerOverlayElement.create(), X = _ColumnSizer.createObject(
        F,
        O,
        w2,
        x2,
        G,
        W,
        U
      );
      return ColumnSizerOverlayElement.applyEvents(D, X), X;
    }
  };
  var _ColumnSizerFillerElement = class ft {
    static create(D) {
      const w2 = document.createElement("div");
      return w2.classList.add(ft.SIZER_FILLER_CLASS), w2.style.backgroundColor = D || ColumnSizerElement.DEFAULT_HOVER_COLOR, w2.style.display = "none", w2;
    }
    static setWidth(D, w2) {
      const O = Number.parseInt(w2);
      D.style.width = `${ColumnSizer.shouldWidthBeIncreased(O) ? O : 4}px`;
    }
    static display(D) {
      D.style.display = "block";
    }
    static hide(D) {
      D.style.display = "none";
    }
  };
  _ColumnSizerFillerElement.SIZER_FILLER_CLASS = "column-sizer-filler";
  var ColumnSizerFillerElement = _ColumnSizerFillerElement;
  var _ColumnSizerElement = class Ce {
    static isHovered(D) {
      return D.style.backgroundImage === Ce.EMPTY_BACKGROUND_IMAGE;
    }
    static setBackgroundImage(D, w2) {
      D.style.backgroundImage = w2;
    }
    static unsetBackgroundImage(D) {
      D.style.backgroundImage = Ce.EMPTY_BACKGROUND_IMAGE;
    }
    static setBackgroundColor(D, w2) {
      D.style.backgroundColor = w2;
    }
    static setTransitionTime(D) {
      D.style.transition = Ce.TRANSITION_TIME;
    }
    static unsetTransitionTime(D) {
      D.style.transition = "0.0s";
    }
    // is not used to unset background image
    static unsetElementsToDefault(D, w2, O = true) {
      O && Ce.setBackgroundColor(D, SEMI_TRANSPARENT_COLOR), ColumnSizerFillerElement.hide(D.children[0]), D.style.width = w2;
    }
    // this is recalculated as it depends on the column index that the sizer is on
    static setStaticProperties(D, w2) {
      D.style.marginRight = w2;
    }
    static setElementId(D, w2) {
      D.id = `${Ce.COLUMN_SIZER_ID_PREFIX}${w2}`;
    }
    static create(D, w2) {
      const O = document.createElement("div");
      Ce.setElementId(O, D), O.classList.add(Ce.COLUMN_SIZER_CLASS);
      const x2 = ColumnSizerFillerElement.create(w2);
      return O.append(x2), Ce.hide(O), O;
    }
    static display(D) {
      var w2;
      UpdateRowElement.updateHeaderRowHeight((w2 = D.parentElement) == null ? void 0 : w2.parentElement), D.style.display = "flex";
    }
    static hide(D) {
      D.style.display = "none";
    }
    static hideWithBlurAnimation(D) {
      setTimeout(() => {
        Ce.hide(D);
      }, Ce.HALF_TRANSITION_TIME_ML);
    }
    static hideWhenCellNotHovered(D, w2) {
      D.isSideCellHovered || (w2 ? Ce.hideWithBlurAnimation(D.element) : Ce.hide(D.element));
    }
    static setHoverStyle(D, w2, O, x2) {
      const { element: U, hoverColor: F } = D;
      ColumnSizerFillerElement.display(U.children[0]), O && Ce.setTransitionTime(U), Ce.setBackgroundColor(U, x2 || F), U.style.width = w2;
    }
  };
  _ColumnSizerElement.FILLED_BACKGROUND_IMAGE = "linear-gradient(180deg, #cdcdcd, #cdcdcd 75%, transparent 75%, transparent 100%)";
  _ColumnSizerElement.EMPTY_BACKGROUND_IMAGE = "none";
  _ColumnSizerElement.DEFAULT_HOVER_COLOR = "grey";
  _ColumnSizerElement.COLUMN_SIZER_CLASS = "column-sizer";
  _ColumnSizerElement.COLUMN_SIZER_ID_PREFIX = `${_ColumnSizerElement.COLUMN_SIZER_CLASS}-`;
  _ColumnSizerElement.TRANSITION_TIME_ML = 200;
  _ColumnSizerElement.TRANSITION_TIME = `${_ColumnSizerElement.TRANSITION_TIME_ML / 1e3}s`;
  _ColumnSizerElement.HALF_TRANSITION_TIME_ML = _ColumnSizerElement.TRANSITION_TIME_ML / 2;
  var ColumnSizerElement = _ColumnSizerElement;
  var _ColumnSizerOverlayEvents = class st {
    static overlayMouseEnter(D) {
      if (D.isSizerHovered = true, D.isMouseUpOnSizer || this._activeOverlayElements.selectedColumnSizer)
        return;
      const { width: w2 } = D.styles.hover;
      ColumnSizerElement.display(D.element), ColumnSizerElement.setTransitionTime(D.element), setTimeout(() => {
        D.isSizerHovered && ColumnSizerElement.setHoverStyle(D, w2, false);
      }, 1), setTimeout(() => {
        D.isSizerHovered && ColumnSizerElement.unsetBackgroundImage(D.element);
      }, st.MOUSE_PASSTHROUGH_TIME_ML);
    }
    // the constant if statement checking is used to prevent a bug where if a mouse leaves the sizer and immediately reenters
    // the timeouts would still proceed to execute the code below
    static unsetColorDuringTransition(D) {
      setTimeout(() => {
        D.isSizerHovered || (ColumnSizerElement.setBackgroundImage(D.element, D.styles.default.backgroundImage), setTimeout(() => {
          D.isSizerHovered || (ColumnSizerElement.unsetTransitionTime(D.element), ColumnSizerElement.setBackgroundColor(D.element, SEMI_TRANSPARENT_COLOR));
        }, ColumnSizerElement.HALF_TRANSITION_TIME_ML));
      }, ColumnSizerElement.HALF_TRANSITION_TIME_ML);
    }
    static overlayMouseLeave(D) {
      if (D.isSizerHovered = false, this._activeOverlayElements.selectedColumnSizer || D.isMouseUpOnSizer)
        return;
      const { element: w2, styles: O } = D;
      ColumnSizerElement.unsetElementsToDefault(w2, O.default.width);
      const x2 = ColumnSizerElement.isHovered(w2);
      setTimeout(() => {
        !this._activeOverlayElements.selectedColumnSizer && !D.isSizerHovered && (st.unsetColorDuringTransition(D), ColumnSizerElement.hideWhenCellNotHovered(D, x2));
      }, st.MOUSE_PASSTHROUGH_TIME_ML);
    }
    // we need to pass down the sizer element instead of the id as the id can change when columns are inserted/removed
    // prettier-ignore
    static overlayMouseDown(D) {
      const { _columnsDetails: w2, _tableBodyElementRef: O, _frameComponents: { displayAddNewRow: x2 } } = this, { columnSizer: U, sizerNumber: F } = ColumnSizerGenericUtils.getSizerDetailsViaElementId(D.id, w2), { element: W, styles: G } = U;
      MovableColumnSizerElement.display(O, U, x2), ColumnSizerElement.unsetElementsToDefault(W, G.default.width), ColumnSizerElement.setBackgroundImage(W, G.default.backgroundImage), this._activeOverlayElements.selectedColumnSizer = SelectedColumnSizer.get(this, F);
    }
  };
  _ColumnSizerOverlayEvents.MOUSE_PASSTHROUGH_TIME_ML = 50;
  var ColumnSizerOverlayEvents = _ColumnSizerOverlayEvents;
  var _ColumnSizerOverlayElement = class ht {
    // this is recalculated as it depends on the column index that the sizer is on
    static setStaticProperties(D, w2, O) {
      D.style.marginRight = w2, D.style.width = O;
    }
    static applyEvents(D, w2) {
      w2.overlayElement.onmouseenter = ColumnSizerOverlayEvents.overlayMouseEnter.bind(D, w2), w2.overlayElement.onmouseleave = ColumnSizerOverlayEvents.overlayMouseLeave.bind(D, w2), w2.overlayElement.onmousedown = ColumnSizerOverlayEvents.overlayMouseDown.bind(D, w2.element);
    }
    static create() {
      const D = document.createElement("div");
      return D.classList.add(ht.SIZER_OVERLAY_CLASS), D;
    }
  };
  _ColumnSizerOverlayElement.SIZER_OVERLAY_CLASS = "column-sizer-overlay";
  var ColumnSizerOverlayElement = _ColumnSizerOverlayElement;
  var InsertRemoveColumnSizer = class _InsertRemoveColumnSizer {
    static updateIdsOfAllSubsequent(D, w2) {
      D.slice(w2).forEach((O, x2) => {
        if (!O.columnSizer)
          return;
        const U = w2 + x2;
        ColumnSizerElement.setElementId(O.columnSizer.element, U);
      });
    }
    static applySizerStateToElements(D) {
      const { element: w2, movableElement: O, overlayElement: x2, styles: U } = D;
      ColumnSizerElement.unsetElementsToDefault(w2, U.default.width), ColumnSizerFillerElement.setWidth(w2.children[0], U.default.width), ColumnSizerElement.setStaticProperties(w2, U.static.marginRight), ColumnSizerElement.setBackgroundImage(w2, U.default.backgroundImage), MovableColumnSizerElement.setStaticProperties(O, U.static.marginRight, U.hover.width), ColumnSizerOverlayElement.setStaticProperties(x2, U.static.marginRight, U.hover.width);
    }
    static insertAtIndex(D, w2, O) {
      const x2 = w2.elements[0].nextSibling, U = ColumnSizer.create(D, O);
      w2.columnSizer = U, x2.appendChild(U.element), x2.appendChild(U.overlayElement), x2.appendChild(U.movableElement), _InsertRemoveColumnSizer.applySizerStateToElements(U);
    }
    // prettier-ignore
    static updateSizer(D, w2, O, x2) {
      const U = ColumnSizer.createObject(D.element, w2, O, x2);
      Object.assign(D, U), _InsertRemoveColumnSizer.applySizerStateToElements(D);
    }
    static updatePrevious(D, w2, O) {
      var F;
      const x2 = w2 - 1;
      if (x2 < 0)
        return;
      const { columnSizer: U } = D[x2];
      ((F = D[x2].settings.widths) == null ? void 0 : F.staticWidth) !== void 0 || !U || _InsertRemoveColumnSizer.updateSizer(U, D, w2, O);
    }
    static getNewColumnIndexIfWidthSet(D, w2) {
      var O;
      return D.length - 1 === w2 ? (O = D[w2 - 1]) != null && O.columnSizer ? -1 : w2 - 1 : w2;
    }
    static isNotResizable(D) {
      const { widths: w2, isColumnResizable: O } = D.settings;
      return (w2 == null ? void 0 : w2.staticWidth) !== void 0 || !O;
    }
    // REF-13
    static insert(D, w2) {
      const { _columnsDetails: O } = D;
      if (!_InsertRemoveColumnSizer.isNotResizable(O[w2])) {
        if (D._tableDimensions.width !== void 0) {
          if (w2 = _InsertRemoveColumnSizer.getNewColumnIndexIfWidthSet(D._columnsDetails, w2), w2 === -1 || _InsertRemoveColumnSizer.isNotResizable(O[w2]))
            return;
        } else
          _InsertRemoveColumnSizer.updatePrevious(O, w2, D._tableElementRef);
        _InsertRemoveColumnSizer.insertAtIndex(D, O[w2], w2), _InsertRemoveColumnSizer.updateIdsOfAllSubsequent(O, w2 + 1);
      }
    }
    // this is only used for when table width is static, otherwise it is removed directly with the column
    static removeSizer(D) {
      var w2, O, x2, U, F, W;
      (O = (w2 = D.columnSizer) == null ? void 0 : w2.element) == null || O.remove(), (U = (x2 = D.columnSizer) == null ? void 0 : x2.movableElement) == null || U.remove(), (W = (F = D.columnSizer) == null ? void 0 : F.overlayElement) == null || W.remove(), delete D.columnSizer;
    }
    // need to remove the sizer of the new last column as when width is set - last column does not have a sizer
    static removeIfLastColumn(D, w2) {
      return D.length === w2 && D[w2] && (w2 -= 1, _InsertRemoveColumnSizer.removeSizer(D[w2])), w2;
    }
    static remove(D, w2) {
      const { _tableDimensions: O, _columnsDetails: x2, _tableElementRef: U } = D;
      O.width !== void 0 && (w2 = _InsertRemoveColumnSizer.removeIfLastColumn(x2, w2)), _InsertRemoveColumnSizer.updatePrevious(x2, w2, U), _InsertRemoveColumnSizer.updateIdsOfAllSubsequent(x2, w2);
    }
    // This is used to cleanup sizers for columns that have or had static widths because they do not have sizers,
    // additionally when the table width is set the last column that is not static also does not have a sizer.
    static cleanUpCustomColumnSizers(D, w2) {
      const { _tableDimensions: O, _columnsDetails: x2 } = D;
      if (O.width === void 0)
        return;
      let U = false;
      for (let F = x2.length - 1; F >= 0; F -= 1) {
        const W = x2[F];
        if (_InsertRemoveColumnSizer.isNotResizable(W))
          W.columnSizer && _InsertRemoveColumnSizer.removeSizer(W);
        else if (U === false) {
          if (U = true, W.columnSizer && _InsertRemoveColumnSizer.removeSizer(W), F < w2)
            break;
        } else if (!W.columnSizer && x2.length - 1 !== F && _InsertRemoveColumnSizer.insertAtIndex(D, W, F), U === true && F < w2)
          break;
      }
    }
  };
  var DropdownDisplaySettingsUtil = class {
    static process(D) {
      D.isAvailable ?? (D.isAvailable = true), D.isAvailable ? (D.openMethod ?? (D.openMethod = {}), D.openMethod.overlayClick ? delete D.openMethod.cellClick : D.openMethod.cellClick ? delete D.openMethod.overlayClick : D.openMethod.overlayClick = true) : (delete D.openMethod, delete D.overlayStyles);
    }
  };
  var ColumnSettingsDefaultTextUtils = class {
    static unsetDefaultText(D, w2, O) {
      w2.elements.slice(1).forEach((x2, U) => {
        const F = U + 1;
        CellEvents.removeTextIfDefault(D, F, O, x2);
      });
    }
    static setDefaultText(D, w2, O) {
      w2.elements.slice(1).forEach((x2, U) => {
        const F = U + 1;
        CellEvents.setCellToDefaultIfNeeded(D, F, O, x2, false);
      }), setTimeout(() => FireEvents.onDataUpdate(D));
    }
  };
  var ColumnSettingsWidthUtils = class _ColumnSettingsWidthUtils {
    // prettier-ignore
    static getSettingsWidthNumber(D, w2, O = true) {
      return StringDimensionUtils.generateNumberDimensionFromClientString(
        D,
        w2,
        O ? "staticWidth" : "initialWidth",
        true,
        ColumnDetails.MINIMAL_COLUMN_WIDTH
      );
    }
    static updateColumnWidth(D, w2, O, x2) {
      const { _tableDimensions: U, _tableElementRef: F } = D, { number: W } = _ColumnSettingsWidthUtils.getSettingsWidthNumber(F, O);
      w2.style.width = `${W}px`, TableElement.changeStaticWidthTotal(U, x2 ? W : -W);
    }
    // prettier-ignore
    static changeWidth(D, w2, O, x2) {
      let U = false;
      O != null && O.staticWidth && (_ColumnSettingsWidthUtils.updateColumnWidth(D, w2, O, false), U = true), x2 != null && x2.staticWidth && (_ColumnSettingsWidthUtils.updateColumnWidth(D, w2, x2, true), U = true), U && StaticTableWidthUtils.changeWidthsBasedOnColumnInsertRemove(D, true);
    }
  };
  var ColumnDropdownCellOverlayEvents = class _ColumnDropdownCellOverlayEvents {
    static mouseClick(D, w2) {
      ColumnDropdown.display(this, D);
      const O = w2.elements[0];
      setTimeout(() => FocusedCellUtils.setHeaderCell(this._focusedElements.cell, O, D));
    }
    // prettier-ignore
    static mouseLeave(D) {
      var w2;
      ColumnDropdownCellOverlay.hide(this, D), delete this._hoveredElements.headerCell, ColumnDropdownCellOverlay.resetDefaultColor(
        D.columnDropdownCellOverlay,
        (w2 = this._defaultColumnsSettings.columnDropdown) == null ? void 0 : w2.displaySettings
      );
    }
    static mouseEnter(D) {
      var O;
      const w2 = D.elements[0];
      this._hoveredElements.headerCell = w2, ColumnDropdownCellOverlay.setHoverColor(D, (O = this._defaultColumnsSettings.columnDropdown) == null ? void 0 : O.displaySettings);
    }
    static setEvents(D, w2) {
      const O = D._columnsDetails[w2], { columnDropdownCellOverlay: x2 } = O;
      x2 && (x2.onmouseenter = _ColumnDropdownCellOverlayEvents.mouseEnter.bind(D, O), x2.onmouseleave = _ColumnDropdownCellOverlayEvents.mouseLeave.bind(D, O), x2.onclick = _ColumnDropdownCellOverlayEvents.mouseClick.bind(D, w2, O));
    }
  };
  var EditableHeaderIconTextEvents = class _EditableHeaderIconTextEvents {
    static keyDownOnText(D, w2, O) {
      UpdateRowElement.updateHeadRowHeightOnKeyDown(this._tableBodyElementRef), O.key === KEYBOARD_KEY.TAB && CellTextEvents.tabOutOfCell(this, D, w2, O);
    }
    // REF-15
    static blurText(D, w2, O) {
      const x2 = O.target, U = CellElement.getCellElement(x2);
      HeaderText.onAttemptChange(this, U, w2), DataCellEvents.blur(this, D, w2, x2);
    }
    static setEvents(D, w2, O, x2) {
      D._columnsDetails[x2].settings.isHeaderTextEditable && (w2.onfocus = CellWithTextEvents.focusText.bind(D, O, x2, null), w2.onblur = _EditableHeaderIconTextEvents.blurText.bind(D, O, x2), w2.onkeydown = _EditableHeaderIconTextEvents.keyDownOnText.bind(D, O, x2));
    }
  };
  var ColumnSizerCellEvents = class _ColumnSizerCellEvents {
    static hideColumnSizer(D) {
      if (!D)
        return;
      D.isSideCellHovered = false;
      const w2 = ColumnSizerElement.isHovered(D.element);
      setTimeout(() => {
        D.isSizerHovered || ColumnSizerElement.hideWhenCellNotHovered(D, w2);
      });
    }
    static cellMouseLeave(D, w2) {
      var O, x2;
      _ColumnSizerCellEvents.hideColumnSizer((O = D[w2 - 1]) == null ? void 0 : O.columnSizer), _ColumnSizerCellEvents.hideColumnSizer((x2 = D[w2]) == null ? void 0 : x2.columnSizer);
    }
    static displayColumnSizer(D) {
      D && (ColumnSizerElement.display(D.element), D.isSideCellHovered = true);
    }
    static cellMouseEnter(D, w2) {
      var O, x2;
      _ColumnSizerCellEvents.displayColumnSizer((O = D[w2 - 1]) == null ? void 0 : O.columnSizer), _ColumnSizerCellEvents.displayColumnSizer((x2 = D[w2]) == null ? void 0 : x2.columnSizer);
    }
  };
  var HeaderCellEvents = class _HeaderCellEvents {
    static mouseEnterCell(D, w2) {
      var O, x2, U, F;
      if (!this._activeOverlayElements.selectedColumnSizer) {
        const W = this._columnsDetails[D], G = w2.target;
        CellHighlightUtils.highlight(G, (O = W.headerStateColors) == null ? void 0 : O.hover), ColumnSizerCellEvents.cellMouseEnter(this._columnsDetails, D), ((F = (U = (x2 = this._defaultColumnsSettings.columnDropdown) == null ? void 0 : x2.displaySettings) == null ? void 0 : U.openMethod) == null ? void 0 : F.overlayClick) && ColumnDropdownCellOverlay.display(W), this._hoveredElements.headerCell = G;
      }
    }
    static mouseLeaveCell(D, w2) {
      var O, x2, U, F;
      Dropdown.isDisplayed(this._activeOverlayElements.columnDropdown) || (CellHighlightUtils.fade(w2.target, (O = this._columnsDetails[D].headerStateColors) == null ? void 0 : O.default), ColumnDropdownCellOverlay.hide(this, this._columnsDetails[D]), (F = (U = (x2 = this._defaultColumnsSettings.columnDropdown) == null ? void 0 : x2.displaySettings) == null ? void 0 : U.openMethod) != null && F.overlayClick && delete this._hoveredElements.headerCell), this._activeOverlayElements.selectedColumnSizer || ColumnSizerCellEvents.cellMouseLeave(this._columnsDetails, D);
    }
    static mouseClick(D, w2) {
      var U, F, W;
      const O = w2.target;
      CellEvents.removeTextIfDefault(this, 0, D, O), ((W = (F = (U = this._defaultColumnsSettings.columnDropdown) == null ? void 0 : U.displaySettings) == null ? void 0 : F.openMethod) == null ? void 0 : W.cellClick) && ColumnDropdown.display(this, D), setTimeout(() => FocusedCellUtils.setHeaderCell(this._focusedElements.cell, O, D));
    }
    static setEvents(D, w2, O) {
      w2.onmouseenter = _HeaderCellEvents.mouseEnterCell.bind(D, O), w2.onmouseleave = _HeaderCellEvents.mouseLeaveCell.bind(D, O), w2.onclick = _HeaderCellEvents.mouseClick.bind(D, O), DragColumn.applyEventsToElement(D, w2, w2);
    }
  };
  var EditableHeaderCellEvents = class _EditableHeaderCellEvents {
    static mouseClickCell(D, w2) {
      const O = w2.target;
      FocusedCellUtils.purge(this._focusedElements.cell), setTimeout(() => FocusedCellUtils.setHeaderCell(this._focusedElements.cell, O, D));
    }
    static setEvents(D, w2, O, x2) {
      if (w2.onmouseenter = HeaderCellEvents.mouseEnterCell.bind(D, x2), w2.onmouseleave = HeaderCellEvents.mouseLeaveCell.bind(D, x2), D.displayHeaderIcons) {
        w2.onfocus = () => {
        }, w2.onblur = () => {
        }, w2.onmousedown = CellWithTextEvents.mouseDown.bind(D, null), w2.onclick = _EditableHeaderCellEvents.mouseClickCell.bind(D, x2);
        const U = CellElement.getTextElement(w2);
        EditableHeaderIconTextEvents.setEvents(D, U, O, x2);
      } else
        w2.onclick = HeaderCellEvents.mouseClick.bind(D, x2);
    }
  };
  var CellEventsReset = class _CellEventsReset {
    static unset(D) {
      D.onfocus = () => {
      }, D.onblur = () => {
      }, D.onmouseenter = () => {
      }, D.onmouseleave = () => {
      }, D.onmousedown = () => {
      }, D.oninput = () => {
      }, D.onpaste = () => {
      }, D.onkeydown = () => {
      };
    }
    static setDataCellEvents(D, w2, O, x2) {
      const { settings: U, activeType: F } = D._columnsDetails[x2];
      if (!U.isCellTextEditable)
        return;
      DataCellEvents.setEvents(D, w2, O, x2);
      const { cellDropdownProps: W, calendar: G, checkbox: X } = F;
      W ? SelectCell.setEvents(D, w2, O, x2) : G ? DateCellEvents.setEvents(D, w2, O, x2) : X && CheckboxCellEvents.setEvents(D, w2, O, x2);
    }
    static setHeaderCellEvents(D, w2, O, x2) {
      var U, F, W;
      (W = (F = (U = D._defaultColumnsSettings.columnDropdown) == null ? void 0 : U.displaySettings) == null ? void 0 : F.openMethod) != null && W.cellClick ? HeaderCellEvents.setEvents(D, w2, x2) : (DataCellEvents.setEvents(D, w2, O, x2), EditableHeaderCellEvents.setEvents(D, w2, 0, x2), ColumnDropdownCellOverlayEvents.setEvents(D, x2));
    }
    // REF-33
    static reset(D, w2, O, x2) {
      O === 0 ? _CellEventsReset.setHeaderCellEvents(D, w2, O, x2) : _CellEventsReset.setDataCellEvents(D, w2, O, x2), !D._frameComponents.displayIndexColumn && x2 === 0 && RowDropdownCellOverlayEvents.addCellEvents(D, O, w2);
    }
  };
  var ResetColumnStructure = class {
    static reset(D, w2, O) {
      const { elements: x2, activeType: U, settings: F } = w2;
      x2.slice(1).forEach((W) => {
        F.isCellTextEditable || CellEventsReset.unset(W);
      }), ChangeColumnType.setNewStructureBasedOnType(D, O, U), ColumnSettingsBorderUtils.resetBorderOverwritingState(w2), setTimeout(() => FireEvents.onColumnsUpdate(D));
    }
  };
  var ColumnSettingsUtils = class _ColumnSettingsUtils {
    static updateSizer(D, w2) {
      const { _columnsDetails: O, _tableElementRef: x2 } = D;
      if (!x2)
        return;
      const { columnSizer: U } = O[w2];
      U || InsertRemoveColumnSizer.insert(D, w2), InsertRemoveColumnSizer.cleanUpCustomColumnSizers(D, w2), U && InsertRemoveColumnSizer.updateSizer(U, O, w2, x2);
      const F = w2 - 1;
      if (w2 > 0 && O[F].columnSizer) {
        const { columnSizer: W } = O[F];
        InsertRemoveColumnSizer.updateSizer(W, O, F, x2);
      }
    }
    // prettier-ignore
    static change(D, w2, O, x2, U, F) {
      const W = D._columnsDetails[O];
      ColumnSettingsDefaultTextUtils.unsetDefaultText(D, W, O), W.settings = U, W.activeType = ColumnTypesUtils.getActiveType(U, W.settings.defaultColumnTypeName), ResetColumnStructure.reset(D, W, O), ColumnSettingsDefaultTextUtils.setDefaultText(D, W, O), F || ColumnSettingsWidthUtils.changeWidth(D, w2, x2.widths, U.widths), ColumnSettingsStyleUtils.changeStyleFunc(D, O, x2), ColumnSettingsBorderUtils.updateSiblingColumns(D, O), _ColumnSettingsUtils.updateSizer(D, O), D.displayHeaderIcons && HeaderIconCellElement.changeHeaderIcon(D._columnsDetails[O]), ColumnDropdownCellOverlay.updateIfDisplayed(W), AddNewColumnElement.toggle(D, true);
    }
    // prettier-ignore
    static parseSettingsChange(D) {
      const { _customColumnsSettings: w2, _columnsDetails: O, _focusedElements: { cell: { element: x2, columnIndex: U } } } = D, W = O[U].settings, G = w2[CellElement.getText(x2)];
      return { oldSettings: W, newSettings: G, areSettingsDifferent: G ? W !== G : false };
    }
    // prettier-ignore
    static changeColumnSettingsIfNameDifferent(D, w2, O, x2 = false) {
      const { oldSettings: U, newSettings: F, areSettingsDifferent: W } = _ColumnSettingsUtils.parseSettingsChange(D);
      W && _ColumnSettingsUtils.change(D, w2, O, U, F, x2);
    }
    static setDropdownSettings(D, w2) {
      !D || !w2 || (D.isSortAvailable ?? (D.isSortAvailable = w2.isSortAvailable), D.isDeleteAvailable ?? (D.isDeleteAvailable = w2.isDeleteAvailable), D.isInsertLeftAvailable ?? (D.isInsertLeftAvailable = w2.isInsertLeftAvailable), D.isInsertRightAvailable ?? (D.isInsertRightAvailable = w2.isInsertRightAvailable), D.isMoveAvailable ?? (D.isMoveAvailable = w2.isMoveAvailable));
    }
    static processCellDimensions(D) {
      const w2 = D.cellStyle;
      if (!w2)
        return;
      const O = D;
      if (w2.width) {
        const x2 = D.isColumnResizable === false ? "staticWidth" : "initialWidth";
        O.widths = { [x2]: w2.width };
      } else
        O.widths && D.isColumnResizable && O.widths.staticWidth && (O.widths = { initialWidth: O.widths.staticWidth });
      StringDimensionUtils.removeAllDimensions(w2);
    }
    static createInternalSettings(D, w2) {
      const O = D;
      return ColumnSettingsStyleUtils.doesSettingHaveSideBorderStyle(O) && (O.stylePrecedence = true), _ColumnSettingsUtils.setDropdownSettings(D.columnDropdown, w2.columnDropdown), Object.keys(w2).forEach((x2) => {
        O[x2] ?? (O[x2] = w2[x2]);
      }), O.types = ColumnTypesUtils.getProcessedTypes(O), _ColumnSettingsUtils.processCellDimensions(D), O;
    }
    static createInternalMap(D, w2) {
      return D.reduce((O, x2) => (O[x2.headerName] = _ColumnSettingsUtils.createInternalSettings(x2, w2), O), {});
    }
    static setDefaultTypeProperties(D) {
      const { _defaultColumnsSettings: w2 } = D;
      w2.availableDefaultColumnTypes = D.availableDefaultColumnTypes, w2.customColumnTypes = D.customColumnTypes, w2.defaultColumnTypeName = D.defaultColumnTypeName, w2.types = ColumnTypesUtils.getProcessedTypes(w2);
    }
    static setDefaultDropdownProperties(D) {
      var x2, U, F, W, G, X;
      const { _defaultColumnsSettings: w2 } = D, O = { openMethod: { cellClick: true } };
      w2.columnDropdown = D.columnDropdown || { displaySettings: O }, (x2 = w2.columnDropdown).displaySettings ?? (x2.displaySettings = O), DropdownDisplaySettingsUtil.process(w2.columnDropdown.displaySettings), (U = w2.columnDropdown).isSortAvailable ?? (U.isSortAvailable = true), (F = w2.columnDropdown).isDeleteAvailable ?? (F.isDeleteAvailable = true), (W = w2.columnDropdown).isInsertLeftAvailable ?? (W.isInsertLeftAvailable = true), (G = w2.columnDropdown).isInsertRightAvailable ?? (G.isInsertRightAvailable = true), (X = w2.columnDropdown).isMoveAvailable ?? (X.isMoveAvailable = true);
    }
    static setDefaultGenericProperties(D) {
      const { _defaultColumnsSettings: w2 } = D;
      w2.defaultText = D.defaultText ?? EMPTY_STRING, w2.isDefaultTextRemovable = D.isDefaultTextRemovable ?? true, w2.cellStyle = D.cellStyle, w2.isCellTextEditable = D.isCellTextEditable ?? true, w2.headerStyles = D.headerStyles, w2.isHeaderTextEditable = D.isHeaderTextEditable ?? w2.isCellTextEditable, w2.headerIconStyle = D.headerIconStyle, w2.isColumnResizable = D.isColumnResizable ?? true;
    }
    static setDefaultColumnsSettings(D) {
      const { _defaultColumnsSettings: w2 } = D;
      _ColumnSettingsUtils.setDefaultGenericProperties(D), _ColumnSettingsUtils.processCellDimensions(w2), _ColumnSettingsUtils.setDefaultDropdownProperties(D), _ColumnSettingsUtils.setDefaultTypeProperties(D);
    }
    // REF-21
    static setUpInternalSettings(D) {
      _ColumnSettingsUtils.setDefaultColumnsSettings(D), D._customColumnsSettings = _ColumnSettingsUtils.createInternalMap(
        D.customColumnsSettings,
        D._defaultColumnsSettings
      );
    }
  };
  var HeaderText = class {
    static onAttemptChange(D, w2, O, x2) {
      const U = x2 == null ? void 0 : x2.colRemove;
      U || ColumnSettingsUtils.changeColumnSettingsIfNameDifferent(D, w2, O, x2 == null ? void 0 : x2.colMove), D._visiblityInternal.filters && FilterInternalUtils.wasHeaderChanged(D._columnsDetails, D._visiblityInternal.filters, O, U) && VisibilityUtils.headerChanged(D);
    }
  };
  var NestedDropdownItem = class {
    static resetItemStyle(D) {
      Array.from(D.children).forEach((w2) => {
        const O = w2;
        O.style.backgroundColor = "", O.style.color = "";
      });
    }
  };
  NestedDropdownItem.NESTED_DROPDOWN_ITEM = "nested-dropdown-item";
  var DropdownItemNavigation = class _DropdownItemNavigation {
    static focusInputElement(D) {
      D.children[0].dispatchEvent(new MouseEvent("mouseenter"));
    }
    // either at the end when isNext is true or the start when isNext is false
    static focusItemWhenOnEdge(D, w2, O) {
      var F;
      if (DropdownItem.doesElementContainInputClass(D)) {
        const W = D.parentElement;
        return _DropdownItemNavigation.focusSiblingItem(W, w2, O);
      }
      ((F = D.parentElement) == null ? void 0 : F.parentElement).classList.contains(DropdownItem.DROPDOWN_ITEM_CLASS) && (w2 = D.parentElement);
      const U = O ? w2.children[0] : w2.children[w2.children.length - 1];
      return _DropdownItemNavigation.focusSiblingItem(U, w2, O, true);
    }
    // isEdgeItem means is it a start/end or inside item
    // prettier-ignore
    static focusSiblingItem(D, w2, O, x2 = false) {
      if (D.classList.contains(NestedDropdownItem.NESTED_DROPDOWN_ITEM)) {
        const F = D.children[2];
        Dropdown.isDisplayed(F) && Dropdown.hide(F);
      }
      const U = x2 ? D : D[O ? "nextSibling" : "previousSibling"];
      if (U) {
        if (!DropdownItem.isDisplayed(U) || U.classList.contains(DropdownItem.DROPDOWN_TITLE_ITEM_CLASS) || U.classList.contains(DropdownItem.DROPDOWN_ITEM_DIVIDER_CLASS))
          return _DropdownItemNavigation.focusSiblingItem(U, w2, O);
        if (U.classList.contains(DropdownItem.DROPDOWN_INPUT_ITEM_CLASS))
          return _DropdownItemNavigation.focusInputElement(U);
      } else
        return _DropdownItemNavigation.focusItemWhenOnEdge(D, w2, O);
      U.dispatchEvent(new MouseEvent("mouseenter"));
    }
    static focusFirstNestedDropdownItem(D) {
      if (D.classList.contains(NestedDropdownItem.NESTED_DROPDOWN_ITEM)) {
        const w2 = D.children[2];
        Dropdown.isDisplayed(w2) && w2.children[0].dispatchEvent(new MouseEvent("mouseenter"));
      }
    }
    static focusNestedDropdownParentItem(D) {
      var O;
      const w2 = (O = D.parentElement) == null ? void 0 : O.parentElement;
      w2.classList.contains(DropdownItem.DROPDOWN_ITEM_CLASS) && (Dropdown.hide(D.parentElement), w2.dispatchEvent(new MouseEvent("mouseenter")));
    }
  };
  var ColumnTypeDropdownItemEvents = class _ColumnTypeDropdownItemEvents {
    static onClickMiddleware(D) {
      ColumnSettingsUtils.parseSettingsChange(this).areSettingsDifferent || D(), ColumnDropdown.processTextAndHide(this);
    }
    // prettier-ignore
    static set(D, w2, O) {
      w2.forEach((x2) => {
        const U = x2;
        U.onclick = _ColumnTypeDropdownItemEvents.onClickMiddleware.bind(
          D,
          ChangeColumnType.change.bind(D, U.innerText.trim(), O)
        );
      });
    }
  };
  var ColumnTypeDropdownItem = class _ColumnTypeDropdownItem {
    static unsetActiveItem(D) {
      const w2 = D.getElementsByClassName(DropdownItem.ACTIVE_ITEM_CLASS)[0];
      w2 && (w2.children[0].style.filter = "", w2.classList.remove(DropdownItem.ACTIVE_ITEM_CLASS));
    }
    static reset(D) {
      _ColumnTypeDropdownItem.unsetActiveItem(D), DropdownItem.removeItems(D);
    }
    static setActiveItem(D, w2) {
      const O = D.find((x2) => CellElement.getText(x2) === w2);
      O && (O.classList.add(DropdownItem.ACTIVE_ITEM_CLASS), O.children[0].style.filter = SVGIconUtils.WHITE_FILTER);
    }
    // the items are repopulated every time column dropdown is opened
    static setUp(D, w2) {
      const { columnTypeDropdown: O } = D._activeOverlayElements, x2 = D._columnsDetails[w2], U = x2.settings.types.map((F) => F.dropdownItem.element);
      DropdownItem.addButtonItemElements(D, O, U), ColumnTypeDropdownItemEvents.set(D, U, w2), _ColumnTypeDropdownItem.setActiveItem(U, x2.activeType.name);
    }
  };
  var DropdownEvents = class {
    static itemKeyNavigation(D, w2, O) {
      if (O.key === KEYBOARD_KEY.TAB || O.key === KEYBOARD_KEY.ARROW_DOWN) {
        O.preventDefault();
        const x2 = D != null && D.activeElement ? O.target : w2.children[0];
        DropdownItemNavigation.focusSiblingItem(x2, w2, true);
      } else
        O.key === KEYBOARD_KEY.ARROW_UP ? DropdownItemNavigation.focusSiblingItem(O.target, w2, false) : O.key === KEYBOARD_KEY.ARROW_RIGHT ? DropdownItemNavigation.focusFirstNestedDropdownItem(O.target) : O.key === KEYBOARD_KEY.ARROW_LEFT && DropdownItemNavigation.focusNestedDropdownParentItem(O.target);
    }
  };
  var ColumnDropdownEvents = class _ColumnDropdownEvents {
    static focusNextColumnDropdown(D, w2) {
      var U, F, W;
      w2.preventDefault(), ColumnDropdown.processTextAndHide(D);
      let O = D._focusedElements.cell.columnIndex;
      O === D._columnsDetails.length - 1 && (O = -1);
      const x2 = D._columnsDetails[O + 1];
      (W = (F = (U = D._defaultColumnsSettings.columnDropdown) == null ? void 0 : U.displaySettings) == null ? void 0 : F.openMethod) != null && W.cellClick ? x2.elements[0].click() : x2.columnDropdownCellOverlay.click();
    }
    static onKeyDown(D, w2) {
      if (w2.key === KEYBOARD_KEY.ENTER) {
        const O = w2.target;
        DropdownItem.doesElementContainInputClass(O) ? ColumnDropdown.processTextAndHide(this) : (O.dispatchEvent(new Event("mouseenter")), O.dispatchEvent(new Event("click")));
      } else
        w2.key === KEYBOARD_KEY.ESCAPE ? ColumnDropdown.processTextAndHide(this) : w2.key === KEYBOARD_KEY.TAB && this._columnsDetails.length > 0 ? _ColumnDropdownEvents.focusNextColumnDropdown(this, w2) : DropdownEvents.itemKeyNavigation(this.shadowRoot, D, w2);
    }
    static set(D, w2) {
      w2.onkeydown = _ColumnDropdownEvents.onKeyDown.bind(D, w2);
    }
  };
  function buildIcon$4(Y) {
    return `<?xml version="1.0" standalone="no"?>
    <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="16" style="transform: ${Y}">
      <g transform="matrix(0.84210527 0 0 0.84210527 0 0)">
        <g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
          <path d="M186.67 193.5L186.67 58.33C 186.67 51.888603 191.8927 46.666 198.334 46.666C 204.7793 46.666 210.002 51.888702 210.002 58.33L210.002 58.33L210.002 193.5L260.08398 143.418C 264.64258 138.8594 272.029 138.8594 276.58398 143.418C 281.14258 147.9727 281.14258 155.359 276.58398 159.918L276.58398 159.918L206.58398 229.918C 202.02928 234.4727 194.64299 234.4727 190.08398 229.918L190.08398 229.918L120.083984 159.918C 115.52928 155.3594 115.52928 147.97299 120.083984 143.418C 124.642586 138.8594 132.02899 138.8594 136.58398 143.418L136.58398 143.418L186.67 193.5zM396.66998 93.33L326.66998 93.33L326.66998 443.33002L396.66998 443.33002zM420.00198 93.33L420.00198 443.33002L490.00198 443.33002L490.00198 93.33002zM151.672 490C 145.2267 490 140.004 484.7773 140.004 478.332L140.004 478.332L140.004 268.332C 140.004 261.8906 145.2267 256.668 151.672 256.668L151.672 256.668L245.004 256.668C 251.4454 256.668 256.672 261.8907 256.672 268.332L256.672 268.332L256.672 478.332C 256.672 484.7773 251.4454 490 245.004 490zM163.336 466.668L233.336 466.668L233.336 279.998L163.336 279.998zM315.00598 466.668C 308.56458 466.668 303.33798 461.4414 303.33798 455L303.33798 455L303.33798 81.67001C 303.33798 75.22472 308.56458 70.002014 315.00598 70.002014L315.00598 70.002014L501.67596 70.002014C 508.11737 70.002014 513.33997 75.22472 513.33997 81.67001L513.33997 81.67001L513.33997 455C 513.33997 461.4414 508.11728 466.668 501.67596 466.668z" stroke="none" fill="#000000" fill-rule="nonzero" />
        </g>
      </g>
    </svg>`;
  }
  var INSERT_LEFT_ICON_SVG_STRING = buildIcon$4("");
  var INSERT_RIGHT_ICON_SVG_STRING = buildIcon$4("rotate(180deg) scale(1, -1)");
  var INSERT_UP_ICON_SVG_STRING = buildIcon$4("rotate(90deg) scale(1, -1)");
  var INSERT_DOWN_ICON_SVG_STRING = buildIcon$4("rotate(-90deg)");
  function buildIcon$3(Y) {
    return `<?xml version="1.0" standalone="no"?>
    <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="9" height="9" style="transform: ${Y}">
      <g transform="matrix(0.47368425 0 0 0.47368425 0 0)">
        <g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
          <g>
            <path d="M169 139.73L308.72998 0L349.175 40.484L109.124985 280.544L348.645 520.054L308.74698 559.999L169.01698 420.26904C 92.164986 343.42105 29.286987 280.29904 29.286987 279.99902C 29.286987 279.699 92.165985 216.57303 169.01698 139.72902L169.01698 139.72902L169 139.73zM490.55 139.73L630.27997 0L670.725 40.484L430.675 280.544L670.195 520.054L630.297 559.999L490.56702 420.26904C 413.71503 343.42105 350.83704 280.29904 350.83704 279.99902C 350.83704 279.699 413.71603 216.57303 490.56702 139.72902z" stroke="none" fill="#000000" fill-rule="nonzero" />
          </g>
        </g>
      </g>
    </svg>`;
  }
  var MOVE_LEFT_ICON_SVG_STRING = buildIcon$3("");
  var MOVE_RIGHT_ICON_SVG_STRING = buildIcon$3("rotate(180deg)");
  var MOVE_UP_ICON_SVG_STRING = buildIcon$3("rotate(90deg)");
  var MOVE_DOWN_ICON_SVG_STRING = buildIcon$3("rotate(-90deg)");
  function buildIcon$2(Y) {
    return `<?xml version="1.0" standalone="no"?>
    <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="9" height="12" style="transform: ${Y}">
      <g transform="matrix(0.5 0 0 0.5 0 0)">
        <path d="M0 0L24 0L24 24L0 24L0 0z" stroke="none" fill="none" />
        <path d="M3 18L9 18L9 16L3 16L3 18zM3 6L3 8L21 8L21 6L3 6zM3 13L15 13L15 11L3 11L3 13z" stroke="none" fill="#000000" fill-rule="nonzero" />
      </g>
    </svg>`;
  }
  var SORT_ASC_ICON_SVG_STRING = buildIcon$2("scale(1, -1)");
  var SORT_DESC_ICON_SVG_STRING = buildIcon$2("");
  var TRASH_ICON_SVG_STRING = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16" height="15">
  <g transform="matrix(1.0666668 0 0 1.0714285 0 0)">
    <g transform="matrix(0.027142858 0 0 0.027142858 0 0)">
      <g>
        <path d="M459.21 156.28L448.835 436.32C 448.6592 441.1247 444.4248 445.195 439.6006 445.195L439.6006 445.195L260.40057 445.195C 255.58028 445.195 251.34198 441.1091 251.16617 436.32L251.16617 436.32L240.79117 156.28C 240.50601 148.5534 234.00996 142.522 226.28317 142.807C 218.55658 143.09607 212.52518 149.58821 212.81018 157.315L212.81018 157.315L223.18118 437.355C 223.91946 457.195 240.51718 473.195 260.40018 473.195L260.40018 473.195L439.60016 473.195C 459.47516 473.195 476.08017 457.22202 476.81915 437.355L476.81915 437.355L487.19016 157.315C 487.4753 149.58841 481.44406 143.09601 473.71716 142.807C 465.99057 142.52185 459.49417 148.5531 459.20917 156.28L459.20917 156.28L459.21 156.28z" stroke="none" fill="#000000" fill-rule="nonzero" />
        <path d="M338.8 212.8L338.8 403.2C 338.8 409.3875 343.81168 414.39902 349.999 414.39902C 356.1863 414.39902 361.198 409.38733 361.198 403.2L361.198 403.2L361.198 212.80002C 361.198 206.61252 356.1863 201.60101 349.999 201.60101C 343.81168 201.60101 338.8 206.61272 338.8 212.80002L338.8 212.80002L338.8 212.8z" stroke="none" fill="#000000" fill-rule="nonzero" />
        <path d="M277.2 213.13L282.8016 403.53C 282.9852 409.7136 288.14142 414.581 294.32462 414.397C 300.5082 414.21732 305.3756 409.0572 305.19162 402.874L305.19162 402.874L299.59003 212.474C 299.41034 206.2904 294.2502 201.423 288.06702 201.607C 281.88342 201.78668 277.02002 206.9468 277.2 213.12999L277.2 213.12999L277.2 213.13z" stroke="none" fill="#000000" fill-rule="nonzero" />
        <path d="M400.41 212.47L394.8084 402.87C 394.62482 409.0536 399.492 414.214 405.6754 414.393C 411.859 414.5766 417.0154 409.7094 417.19843 403.526L417.19843 403.526L422.80002 213.126C 422.9797 206.94241 418.11642 201.78201 411.933 201.60301C 405.74942 201.41942 400.58902 206.2866 400.41 212.47002L400.41 212.47002L400.41 212.47z" stroke="none" fill="#000000" fill-rule="nonzero" />
        <path d="M210 162.4L490 162.4C 497.7305 162.4 504 156.1344 504 148.4C 504 140.6695 497.7305 134.4 490 134.4L490 134.4L210 134.4C 202.2695 134.4 196 140.6695 196 148.4C 196 156.1344 202.2695 162.4 210 162.4z" stroke="none" fill="#000000" fill-rule="nonzero" />
        <path d="M307.46 143.85L313.2881 123.44401C 314.5381 119.076805 320.20218 114.803406 324.75308 114.803406L324.75308 114.803406L375.2451 114.803406C 379.7959 114.803406 385.46008 119.07291 386.71008 123.44401L386.71008 123.44401L392.53818 143.85L419.46017 136.15471L413.63208 115.75271C 408.94458 99.35771 392.29608 86.80371 375.2451 86.80371L375.2451 86.80371L324.75308 86.80371C 307.7021 86.80371 291.05008 99.36271 286.3661 115.75271L286.3661 115.75271L280.538 136.15471L307.46 143.85z" stroke="none" fill="#000000" fill-rule="nonzero" />
      </g>
    </g>
  </g>
</svg>`;
  var ColumnDropdownButtonItemConf = class {
  };
  ColumnDropdownButtonItemConf.ITEMS = [
    {
      text: "Sort Ascending",
      iconSettings: {
        svgString: SORT_ASC_ICON_SVG_STRING,
        containerStyles: { dropdown: { marginRight: "9px", marginTop: "2px" } }
      }
    },
    {
      text: "Sort Descending",
      iconSettings: {
        svgString: SORT_DESC_ICON_SVG_STRING,
        containerStyles: { dropdown: { marginRight: "9px", marginTop: "1px" } }
      }
    },
    {
      text: "Insert Left",
      iconSettings: {
        svgString: INSERT_LEFT_ICON_SVG_STRING,
        containerStyles: { dropdown: { marginLeft: "-2px", marginRight: "3px", marginTop: "1px" } }
      }
    },
    {
      text: "Insert Right",
      iconSettings: {
        svgString: INSERT_RIGHT_ICON_SVG_STRING,
        containerStyles: { dropdown: { marginLeft: "-3px", marginRight: "4px", marginTop: "1px" } }
      }
    },
    {
      text: "Move Left",
      iconSettings: {
        svgString: MOVE_LEFT_ICON_SVG_STRING,
        containerStyles: { dropdown: { marginLeft: "1px", marginRight: "7px", marginTop: "3.5px" } }
      }
    },
    {
      text: "Move Right",
      iconSettings: {
        svgString: MOVE_RIGHT_ICON_SVG_STRING,
        containerStyles: { dropdown: { marginLeft: "1px", marginRight: "7px", marginTop: "1.5px" } }
      }
    },
    {
      text: "Delete",
      iconSettings: {
        svgString: TRASH_ICON_SVG_STRING,
        containerStyles: { dropdown: { marginLeft: "-4px", marginRight: "5px", marginTop: "-1px" } }
      }
    }
  ];
  var UpdateCellsForColumns = class _UpdateCellsForColumns {
    // prettier-ignore
    static updateColumn(D, w2, O, x2, U) {
      U !== CELL_UPDATE_TYPE.REMOVED && CellEventsReset.reset(D, O, w2, x2), FireEvents.onCellUpdate(D, CellElement.getText(O), w2, x2, U);
    }
    // prettier-ignore
    static updateNextBeforeLastColumns(D, w2, O, x2) {
      ExtractElements.textCellsArrFromRow(w2.element).slice(O, x2).forEach((F, W) => {
        const G = W + O;
        _UpdateCellsForColumns.updateColumn(D, w2.index, F, G, CELL_UPDATE_TYPE.UPDATE);
      });
    }
    // the reason why last column details need to be passed here is because after removal of last element, its details are
    // no longer present here as this class's methods are run in setTimeouts, hence those details need to be captured
    // before these methods are executed
    // prettier-ignore
    static rebindAndFireUpdates(D, w2, O, x2, U) {
      _UpdateCellsForColumns.updateNextBeforeLastColumns(D, w2, O, U.index), _UpdateCellsForColumns.updateColumn(D, w2.index, U.element, U.index, x2);
    }
  };
  var LastColumn = class {
    // the reason why last column details are used is because after removal of the last column element, its details are
    // no longer present and update methods are run in setTimeouts, hence those details need to be captured before
    // their methods are executed
    static getDetails(D, w2) {
      const O = D.length - 1;
      return { element: D[O].elements[w2], index: O };
    }
  };
  var RemoveColumn = class _RemoveColumn {
    static reduceStaticWidthTotal(D, w2) {
      var O;
      if ((O = w2.widths) != null && O.staticWidth) {
        const { number: x2 } = ColumnSettingsWidthUtils.getSettingsWidthNumber(
          D._tableElementRef,
          w2.widths
        );
        TableElement.changeStaticWidthTotal(D._tableDimensions, -x2);
      }
    }
    static updateTableDimensions(D, w2) {
      _RemoveColumn.reduceStaticWidthTotal(D, w2), StaticTableWidthUtils.changeWidthsBasedOnColumnInsertRemove(D, false);
    }
    static cleanUpData(D) {
      D.length > 0 && D[0].length === 0 && D.splice(0);
    }
    static removeElements(D, w2, O) {
      const x2 = CellElementIndex.getViaColumnIndex(w2, O);
      D.children[x2].remove(), D.children[x2].remove();
    }
    static removeCell(D, w2, O, x2) {
      const U = LastColumn.getDetails(D._columnsDetails, O);
      _RemoveColumn.removeElements(w2, x2, !!D._frameComponents.displayIndexColumn), D.data[O].splice(x2, 1), setTimeout(() => {
        const F = { element: w2, index: O };
        UpdateCellsForColumns.rebindAndFireUpdates(D, F, x2, CELL_UPDATE_TYPE.REMOVED, U);
      });
    }
    static removeCellFromAllRows(D, w2) {
      ExtractElements.textRowsArrFromTBody(D._tableBodyElementRef, D.data).forEach((U, F) => {
        _RemoveColumn.removeCell(D, U, F, w2);
      }), _RemoveColumn.cleanUpData(D.data), HeaderText.onAttemptChange(D, D._columnsDetails[w2].elements[0], w2, { colRemove: true });
      const x2 = D._columnsDetails.splice(w2, 1)[0];
      return _RemoveColumn.updateTableDimensions(D, x2.settings), x2;
    }
    static remove(D, w2) {
      const O = _RemoveColumn.removeCellFromAllRows(D, w2);
      ToggleAdditionElements.update(D, false, AddNewColumnElement.toggle), ColumnSettingsBorderUtils.updateSiblingColumns(D, w2), setTimeout(() => {
        O.cellDropdown.element.remove(), InsertRemoveColumnSizer.remove(D, w2), InsertRemoveColumnSizer.cleanUpCustomColumnSizers(D, w2), w2 === 0 && D._columnsDetails.length > 0 && RowDropdownCellOverlay.resetOverlays(D), setTimeout(() => {
          FireEvents.onDataUpdate(D), FireEvents.onColumnsUpdate(D);
        });
      });
    }
    static removeEvent(D) {
      _RemoveColumn.remove(this, D);
    }
  };
  var ElementSiblingIterator = class {
    static create(D) {
      let w2 = D;
      return {
        next: () => {
          const O = w2.nextSibling;
          return O && (w2 = O), O;
        },
        currentElement: () => w2
      };
    }
  };
  var ColumnDropdownItemEvents = class _ColumnDropdownItemEvents {
    static onClickMiddleware(D) {
      D(), ColumnDropdown.processTextAndHide(this);
    }
    // prettier-ignore
    static setItemEvents(D, w2, O) {
      const x2 = O.getElementsByClassName(ColumnDropdownItem.SORT_ITEM_CLASS)[0], U = ElementSiblingIterator.create(x2);
      U.currentElement().onclick = _ColumnDropdownItemEvents.onClickMiddleware.bind(
        D,
        Sort.sortColumn.bind(this, D, w2, true)
      ), U.next().onclick = _ColumnDropdownItemEvents.onClickMiddleware.bind(
        D,
        Sort.sortColumn.bind(this, D, w2, false)
      ), U.next().onclick = _ColumnDropdownItemEvents.onClickMiddleware.bind(
        D,
        InsertNewColumn.insert.bind(this, D, w2)
      ), U.next().onclick = _ColumnDropdownItemEvents.onClickMiddleware.bind(
        D,
        InsertNewColumn.insert.bind(this, D, w2 + 1)
      ), U.next().onclick = _ColumnDropdownItemEvents.onClickMiddleware.bind(
        D,
        MoveColumn.move.bind(this, D, w2, false)
      ), U.next().onclick = _ColumnDropdownItemEvents.onClickMiddleware.bind(
        D,
        MoveColumn.move.bind(this, D, w2, true)
      ), U.next().onclick = _ColumnDropdownItemEvents.onClickMiddleware.bind(
        D,
        RemoveColumn.remove.bind(this, D, w2)
      );
    }
    // reason why using onInput for updating cells is because it works for paste
    // prettier-ignore
    static onInput(D, w2, O, x2) {
      setTimeout(() => {
        CellEvents.updateCell(this, x2.value, 0, D, { element: w2, processText: false }), O.style.top = ColumnDropdown.getTopPosition(this, w2);
      });
    }
    // prettier-ignore
    static setInputItemEvent(D, w2, O, x2, U) {
      x2.oninput = _ColumnDropdownItemEvents.onInput.bind(
        D,
        w2,
        O,
        U,
        x2
      );
    }
  };
  var SIDE = /* @__PURE__ */ ((Y) => (Y[Y.LEFT = 0] = "LEFT", Y[Y.RIGHT = 1] = "RIGHT", Y[Y.TOP = 2] = "TOP", Y[Y.BOTTOM = 3] = "BOTTOM", Y))(SIDE || {});
  var NestedDropdown = class _NestedDropdown {
    static create(D, w2) {
      const O = Dropdown.createBase();
      return O.style.top = `-${Number.parseInt(O.style.paddingTop) + 22}px`, D && w2 && DropdownItem.addNewButtonItems(D, O, w2), O;
    }
    static resetPosition(D) {
      D.style.left = "";
    }
    static hideDropdown(D) {
      const w2 = D.target.children[2];
      w2.style.display = "none", _NestedDropdown.resetPosition(w2);
    }
    // prettier-ignore
    static correctPosition(D, w2, O) {
      const x2 = ElementVisibility.getDetailsInWindow(D, O);
      if (!x2.isFullyVisible && x2.blockingSides.has(SIDE.RIGHT)) {
        D.style.left = `-${w2.style.width}`;
        const U = ElementVisibility.getDetailsInWindow(D, O);
        !U.isFullyVisible && U.blockingSides.has(SIDE.LEFT) && (D.style.left = "");
      }
    }
    // prettier-ignore
    static correctPositionForOverflow(D, w2, O) {
      const { _tableElementRef: x2, _overflow: U } = D;
      !x2 || !U || x2.offsetWidth !== U.overflowContainer.scrollWidth && (w2.style.left = `-${O.style.width}`, w2.getBoundingClientRect().x < 0 && (w2.style.left = ""));
    }
    static displayAndSetDropdownPosition(D) {
      const w2 = D.target.children[2], O = D.target.parentElement;
      w2.style.left = O.style.width, w2.style.display = O.style.display, this._overflow && OverflowUtils.isOverflowElement(this._overflow.overflowContainer) ? _NestedDropdown.correctPositionForOverflow(this, w2, O) : _NestedDropdown.correctPosition(w2, O, this._tableDimensions.border);
    }
  };
  var NestedDropdownItemEvents = class {
    // prettier-ignore
    static addEvents(D, w2) {
      w2.addEventListener("mouseenter", NestedDropdown.displayAndSetDropdownPosition.bind(D)), w2.addEventListener("mouseleave", NestedDropdown.hideDropdown), w2.children[1].addEventListener(
        "mouseenter",
        DropdownItemHighlightUtils.highlightNew.bind(this, D._activeOverlayElements, w2)
      );
    }
  };
  var _ColumnTypeDropdown = class nt {
    static setupParentItemData(D, w2) {
      var W;
      const { name: O, dropdownItem: x2 } = w2, U = ((W = x2.element) == null ? void 0 : W.children[0]).cloneNode(true);
      D.replaceChild(U, D.children[0]);
      const F = D.children[1];
      F.innerText = O;
    }
    static setUp(D, w2, O) {
      const { activeType: x2, settings: U } = D._columnsDetails[O], F = w2.getElementsByClassName(nt.COLUMN_TYPE_ITEM_CLASS)[0];
      if (nt.setupParentItemData(F, x2), U.types.length < 2)
        return F.style.pointerEvents = "none";
      F.style.pointerEvents = "", setTimeout(() => ColumnTypeDropdownItem.setUp(D, O));
    }
    // prettier-ignore
    static create(D, w2) {
      const O = DropdownItem.addButtonItem(
        D,
        w2,
        DropdownButtonItemConf.DEFAULT_ITEM,
        NestedDropdownItem.NESTED_DROPDOWN_ITEM,
        nt.COLUMN_TYPE_ITEM_CLASS
      );
      NestedDropdownItemEvents.addEvents(D, O);
      const x2 = NestedDropdown.create();
      O.appendChild(x2), D._activeOverlayElements.columnTypeDropdown = x2;
    }
  };
  _ColumnTypeDropdown.COLUMN_TYPE_ITEM_CLASS = "dropdown-column-type-item";
  var ColumnTypeDropdown = _ColumnTypeDropdown;
  var _ColumnDropdownItem = class Oe {
    static resetItems(D) {
      Array.from(D.children).forEach((O) => DropdownItem.toggleItem(O, true));
    }
    static addItems(D, w2) {
      setTimeout(() => {
        DropdownItem.addTitle(w2, "Property type"), ColumnTypeDropdown.create(D, w2), DropdownItem.addDivider(w2), ColumnDropdownButtonItemConf.ITEMS.slice(0, 2).forEach((O) => {
          DropdownItem.addButtonItem(D, w2, O, Oe.SORT_ITEM_CLASS);
        }), ColumnDropdownButtonItemConf.ITEMS.slice(2).forEach((O) => {
          DropdownItem.addButtonItem(D, w2, O);
        });
      });
    }
    // hide divider when there are no items below
    static hideDivider(D) {
      D.slice(4).find((O) => O.style.display !== "none") || DropdownItem.toggleItem(D[3], false);
    }
    static toggleItems(D, w2) {
      const { isSortAvailable: O, isDeleteAvailable: x2, isInsertLeftAvailable: U, isInsertRightAvailable: F, isMoveAvailable: W } = D;
      O || (DropdownItem.toggleItem(w2[4], false), DropdownItem.toggleItem(w2[5], false)), U || DropdownItem.toggleItem(w2[6], false), F || DropdownItem.toggleItem(w2[7], false), W || (DropdownItem.toggleItem(w2[8], false), DropdownItem.toggleItem(w2[9], false)), x2 || DropdownItem.toggleItem(w2[10], false), Oe.hideDivider(w2);
    }
    // prettier-ignore
    static setUpInputElement(D, w2, O, x2, U) {
      var G, X, K;
      const { isCellTextEditable: F, isHeaderTextEditable: W } = D._columnsDetails[w2].settings;
      if ((K = (X = (G = D._defaultColumnsSettings.columnDropdown) == null ? void 0 : G.displaySettings) == null ? void 0 : X.openMethod) != null && K.overlayClick || (ObjectUtils.areValuesFullyDefined(W) ? !W : !F))
        DropdownItem.toggleItem(x2, false);
      else {
        const q = x2.children[0];
        q.value = D.data[0][w2], ColumnDropdownItemEvents.setInputItemEvent(D, w2, O, q, U);
      }
    }
    static setUp(D, w2, O, x2) {
      ColumnTypeDropdown.setUp(D, w2, O);
      const U = Array.from(w2.children);
      Oe.setUpInputElement(D, O, x2, U[0], w2), Oe.toggleItems(D._columnsDetails[O].settings.columnDropdown, U), Oe.updateItemsStyle(D, O, w2), ColumnDropdownItemEvents.setItemEvents(D, O, w2);
    }
    static updateMoveColumnItemsStyle(D, w2, O) {
      const { isMoveAvailable: x2 } = D._columnsDetails[w2].settings.columnDropdown;
      x2 && (DropdownItem.toggleUsability(O[8], true), DropdownItem.toggleUsability(O[9], true), w2 === 0 && DropdownItem.toggleUsability(O[8], false), w2 === D._columnsDetails.length - 1 && DropdownItem.toggleUsability(O[9], false));
    }
    static updateInsertColumnItemsStyle(D, w2) {
      MaximumColumns.canAddMore(D) ? (DropdownItem.toggleUsability(w2[6], true), DropdownItem.toggleUsability(w2[7], true)) : (DropdownItem.toggleUsability(w2[6], false), DropdownItem.toggleUsability(w2[7], false));
    }
    static updateItemsStyle(D, w2, O) {
      const x2 = Array.from(O.children);
      Oe.updateInsertColumnItemsStyle(D, x2), Oe.updateMoveColumnItemsStyle(D, w2, x2);
    }
  };
  _ColumnDropdownItem.SORT_ITEM_CLASS = "dropdown-sort-item";
  var ColumnDropdownItem = _ColumnDropdownItem;
  var ColumnDropdown = class _ColumnDropdown {
    static resetDropdownPosition(D) {
      D.style.left = "";
    }
    // prettier-ignore
    static processTextAndHide(D) {
      var X;
      const { _activeOverlayElements: w2, _columnsDetails: O, _focusedElements: { cell: { element: x2, columnIndex: U } } } = D, { columnDropdown: F, columnTypeDropdown: W, fullTableOverlay: G } = w2;
      !F || !G || !W || !x2 || (GenericElementUtils.doesElementExistInDom(x2) && (CellEvents.setCellToDefaultIfNeeded(D, 0, U, x2), HeaderText.onAttemptChange(D, x2, U)), CellHighlightUtils.fade(x2, (X = O[U]) == null ? void 0 : X.headerStateColors.default), Dropdown.hide(F, G, W), ColumnTypeDropdownItem.reset(W), _ColumnDropdown.resetDropdownPosition(F), ColumnDropdownItem.resetItems(F), DropdownItemHighlightUtils.fadeCurrentlyHighlighted(w2));
    }
    static create(D) {
      const w2 = Dropdown.createBase();
      return ColumnDropdownEvents.set(D, w2), DropdownItem.addInputItem(D, w2), ColumnDropdownItem.addItems(D, w2), w2;
    }
    // prettier-ignore
    static getDefaultDropdownTopPosition(D, w2, O) {
      return O ? `${Browser.IS_FIREFOX ? 1 + w2.topWidth : 1}px` : `${ElementOffset.processTop(D.offsetTop + D.offsetHeight, w2)}px`;
    }
    static getTopPosition(D, w2) {
      var x2, U, F;
      const O = (F = (U = (x2 = D._defaultColumnsSettings.columnDropdown) == null ? void 0 : x2.displaySettings) == null ? void 0 : U.openMethod) == null ? void 0 : F.overlayClick;
      if (D._overflow) {
        const W = D._overflow.overflowContainer;
        return `${O ? W.scrollTop + 1 : W.scrollTop + w2.offsetHeight}px`;
      } else if (D._stickyProps.header) {
        const W = w2.parentElement.offsetTop;
        return `${(O ? 1 : w2.offsetHeight) + W}px`;
      }
      return _ColumnDropdown.getDefaultDropdownTopPosition(w2, D._tableDimensions.border, O);
    }
    static getLeftPropertyToCenterDropdown(D, w2) {
      return `${ElementOffset.processLeft(D.offsetLeft + D.offsetWidth / 2, w2) - Dropdown.DROPDOWN_WIDTH / 2}px`;
    }
    static displayAndSetDropdownPosition(D, w2, O) {
      O.style.left = _ColumnDropdown.getLeftPropertyToCenterDropdown(w2, D._tableDimensions.border), O.style.top = _ColumnDropdown.getTopPosition(D, w2), Dropdown.display(O);
      const x2 = ElementVisibility.getDetailsInWindow(O, D._tableDimensions.border);
      x2.isFullyVisible || (x2.blockingSides.has(SIDE.LEFT) ? O.style.left = "0px" : x2.blockingSides.has(SIDE.RIGHT) && (O.style.left = `${w2.offsetLeft + w2.offsetWidth - Dropdown.DROPDOWN_WIDTH}px`));
    }
    // no active table based overflow - REF-37
    static displayAndSetPositionForSticky(D, w2, O) {
      O.style.left = _ColumnDropdown.getLeftPropertyToCenterDropdown(w2, D._tableDimensions.border), O.style.top = _ColumnDropdown.getTopPosition(D, w2), Dropdown.display(O);
    }
    // prettier-ignore
    static displayAndSetPositionForOverflow(D, w2, O) {
      const { _tableElementRef: x2, _overflow: U, _tableDimensions: F } = D;
      if (!x2 || !(U != null && U.overflowContainer))
        return;
      const W = U.overflowContainer;
      O.style.left = _ColumnDropdown.getLeftPropertyToCenterDropdown(w2, F.border), O.style.top = _ColumnDropdown.getTopPosition(D, w2), Dropdown.display(O), x2.offsetWidth !== W.scrollWidth ? O.style.left = `${x2.offsetWidth - O.offsetWidth}px` : O.offsetLeft < 0 && (O.style.left = "0px");
    }
    static display(D, w2) {
      const O = D._activeOverlayElements.columnDropdown, x2 = D._columnsDetails[w2].elements[0];
      ColumnDropdownItem.setUp(D, O, w2, x2), D._overflow ? _ColumnDropdown.displayAndSetPositionForOverflow(D, x2, O) : D._stickyProps.header ? _ColumnDropdown.displayAndSetPositionForSticky(D, x2, O) : _ColumnDropdown.displayAndSetDropdownPosition(D, x2, O);
      const U = DropdownItem.getInputElement(O);
      U && DropdownItemNavigation.focusInputElement(U), FullTableOverlayElement.display(D);
    }
  };
  var FullTableOverlayEvents = class {
    // prettier-ignore
    static onMouseDown(D) {
      const { _activeOverlayElements: { columnDropdown: w2, rowDropdown: O } } = this;
      Dropdown.isDisplayed(w2) && !Dropdown.isPartOfDropdownElement(D.target) && ColumnDropdown.processTextAndHide(this), Dropdown.isDisplayed(O) && RowDropdown.hide(this);
    }
  };
  var FullTableOverlayElement = class {
    // at offsets is a bug fix for a situation where the user was able to click the table border, focus and unfocus a cell
    // and therefore not allow the column dropdown to close because there is nothing focused
    static display(D) {
      var O;
      const w2 = D._activeOverlayElements.fullTableOverlay;
      if (w2.style.width = `${D.offsetWidth}px`, w2.style.height = `${D.offsetHeight}px`, (O = D._overflow) != null && O.overflowContainer)
        w2.style.top = `${D.offsetTop}px`, w2.style.left = `${D.offsetLeft}px`;
      else {
        const x2 = D._tableElementRef.offsetTop - D.offsetTop;
        w2.style.top = `-${Browser.IS_FIREFOX ? x2 : x2 + D._tableDimensions.border.topWidth}px`, w2.style.left = `-${Browser.IS_FIREFOX ? 0 : D._tableDimensions.border.leftWidth}px`;
      }
      Dropdown.display(w2);
    }
    static create(D) {
      const w2 = document.createElement("div");
      return w2.id = "full-table-overlay", w2.style.backgroundColor = SEMI_TRANSPARENT_COLOR, w2.style.display = "none", w2.onmousedown = FullTableOverlayEvents.onMouseDown.bind(D), w2;
    }
  };
  var RowDropdownEvents = class _RowDropdownEvents {
    // the reason why we track window key events is because the table is not actually focused when it is displayed,
    // (unlike column dropdown which has an input), hence initially clicking tab does not focus the dropdown and
    // instead we need to focus it programmatically here. Once focused, the actual dropdown events can take over.
    // prettier-ignore
    static windowOnKeyDown(D, w2) {
      const { _activeOverlayElements: { rowDropdown: O, fullTableOverlay: x2 }, shadowRoot: U } = D;
      D._focusedElements.rowDropdown || !O || !x2 || (w2.key === KEYBOARD_KEY.ENTER || w2.key === KEYBOARD_KEY.ESCAPE ? RowDropdown.hide(D) : U != null && U.activeElement || (w2.key === KEYBOARD_KEY.TAB || w2.key === KEYBOARD_KEY.ARROW_DOWN ? (w2.preventDefault(), D._focusedElements.rowDropdown = O, DropdownItemNavigation.focusSiblingItem(O.children[0], O, true, true)) : w2.key === KEYBOARD_KEY.ARROW_UP && (D._focusedElements.rowDropdown = O, DropdownItemNavigation.focusSiblingItem(
        O.children[O.children.length - 1],
        O,
        false,
        true
      ))));
    }
    static dropdownOnKeyDown(D, w2) {
      if (w2.key === KEYBOARD_KEY.ENTER) {
        const O = w2.target;
        O.dispatchEvent(new Event("mouseenter")), O.dispatchEvent(new Event("click"));
      } else
        w2.key === KEYBOARD_KEY.ESCAPE && RowDropdown.hide(this);
      DropdownEvents.itemKeyNavigation(this.shadowRoot, D, w2);
    }
    static set(D, w2) {
      w2.onkeydown = _RowDropdownEvents.dropdownOnKeyDown.bind(D, w2);
    }
  };
  var RowDropdownButtonItemConf = class {
  };
  RowDropdownButtonItemConf.ITEMS = [
    {
      text: "Insert Up",
      iconSettings: {
        svgString: INSERT_UP_ICON_SVG_STRING,
        containerStyles: { dropdown: { marginRight: "1px" } }
      }
    },
    {
      text: "Insert Down",
      iconSettings: {
        svgString: INSERT_DOWN_ICON_SVG_STRING,
        containerStyles: { dropdown: { marginRight: "1px" } }
      }
    },
    {
      text: "Move Up",
      iconSettings: {
        svgString: MOVE_UP_ICON_SVG_STRING,
        containerStyles: { dropdown: { marginRight: "8px", marginTop: "3.5px" } }
      }
    },
    {
      text: "Move Down",
      iconSettings: {
        svgString: MOVE_DOWN_ICON_SVG_STRING,
        containerStyles: { dropdown: { marginLeft: "2px", marginRight: "6px", marginTop: "3.5px" } }
      }
    },
    {
      text: "Delete",
      iconSettings: {
        svgString: TRASH_ICON_SVG_STRING,
        containerStyles: { dropdown: { marginLeft: "-4px", marginRight: "5px", marginTop: "-1px" } }
      }
    }
  ];
  var IndexColumnEvents = class _IndexColumnEvents {
    static mouseEnterCell(D, w2) {
      const O = w2.target, { cellColors: x2 } = this._frameComponents, U = FrameComponentsColors.getColorsBasedOnParam(x2, D);
      CellHighlightUtils.highlight(O, U.hover);
    }
    static mouseLeaveCell(D, w2) {
      if (!Dropdown.isDisplayed(this._activeOverlayElements.rowDropdown)) {
        const { cellColors: O } = this._frameComponents, x2 = FrameComponentsColors.getColorsBasedOnParam(O, D);
        CellHighlightUtils.fade(w2.target, x2.default);
      }
    }
    static setEvents(D, w2, O) {
      var F;
      w2.onmouseenter = _IndexColumnEvents.mouseEnterCell.bind(D, O), w2.onmouseleave = _IndexColumnEvents.mouseLeaveCell.bind(D, O);
      const { displaySettings: x2, canEditHeaderRow: U } = D.rowDropdown;
      !U && O === 0 || (x2.isAvailable && ((F = x2.openMethod) != null && F.cellClick) ? w2.onclick = RowDropdown.display.bind(D, O, w2) : RowDropdownCellOverlayEvents.addCellEvents(D, O, w2));
    }
  };
  var UpdateCellsForRows = class _UpdateCellsForRows {
    // prettier-ignore
    static updateRowCells(D, w2, O, x2, U = true) {
      var W;
      if (ExtractElements.textCellsArrFromRow(w2).forEach((G, X) => {
        x2 !== CELL_UPDATE_TYPE.REMOVED && CellEventsReset.reset(D, G, O, X), U && FireEvents.onCellUpdate(D, CellElement.getText(G), O, X, x2);
      }), x2 !== CELL_UPDATE_TYPE.REMOVED) {
        const G = w2.children[0];
        if (D._frameComponents.displayIndexColumn && (IndexColumnEvents.setEvents(D, G, O), DragRow.applyEventsToElement(D, G, G)), (W = D.rowDropdown.displaySettings.openMethod) != null && W.overlayClick) {
          const X = RowDropdownCellOverlayEvents.setOverlayEvents(D, O, G);
          DragRow.applyEventsToElement(D, X, G);
        }
      }
    }
    static updateLastRow(D, w2, O) {
      var x2;
      (x2 = D._tableBodyElementRef) != null && x2.children && _UpdateCellsForRows.updateRowCells(D, O.element, O.index, w2);
    }
    static updateLowerBeforeLastRows(D, w2, O) {
      var U;
      const x2 = (U = D._tableBodyElementRef) == null ? void 0 : U.children;
      x2 && Array.from(x2).slice(w2, O).forEach((W, G) => {
        const X = G + w2, K = W;
        _UpdateCellsForRows.updateRowCells(D, K, X, CELL_UPDATE_TYPE.UPDATE);
      });
    }
    // REF-20
    // the reason why last row details need to be passed here is because after removal of last row, the last element details
    // are no longer available as this class's methods are run in setTimeouts, hence those details need to be captured
    // before these methods are executed
    // CAUTION-2 if the addition or removal of row causes the parent div to change width, this is indeed run after rerender,
    // however the onCellUpdate messages are required and event rebinding here still appears to be valid
    // prettier-ignore
    static rebindAndFireUpdates(D, w2, O, x2) {
      _UpdateCellsForRows.updateLowerBeforeLastRows(D, w2, x2.index), _UpdateCellsForRows.updateLastRow(D, O, x2);
    }
  };
  var RemoveRow = class _RemoveRow {
    // when the last row has been removed, there are no more columns
    static removeAllColumnsDetails(D) {
      const { _columnsDetails: w2 } = D;
      w2.forEach((O) => RemoveColumn.reduceStaticWidthTotal(D, O.settings)), w2.splice(0, w2.length);
    }
    static update(D, w2, O, x2) {
      const U = { element: O, index: x2 };
      UpdateCellsForRows.rebindAndFireUpdates(D, w2, CELL_UPDATE_TYPE.REMOVED, U), setTimeout(() => FireEvents.onDataUpdate(D)), !D._isRendering && (D.data.length === 0 && _RemoveRow.removeAllColumnsDetails(D), D._addColumnCellsElementsRef.splice(w2, 1));
    }
    static rowToBeRemovedIndexWhenPagination(D, w2) {
      var x2;
      const O = (x2 = D._tableBodyElementRef) == null ? void 0 : x2.children[w2];
      return D._pagination.visibleRows.findIndex((U) => U === O);
    }
    static removeRow(D, w2) {
      var U;
      const O = D.pagination ? _RemoveRow.rowToBeRemovedIndexWhenPagination(D, w2) : 0;
      (U = D._tableBodyElementRef) == null || U.children[w2].remove(), D._rowDropdownCellOverlays.splice(w2, 1);
      const x2 = D.data.splice(w2, 1);
      return x2[0].forEach((F, W) => {
        D._columnsDetails[W].elements.splice(w2, 1), D._columnsDetails[W].processedStyle.splice(w2, 1);
      }), D.pagination && PaginationUtils.updateOnRowChange(D, O), x2[0];
    }
    // REF-27
    static changeRowIndexIfRemoveHeaderWithDataBelow(D, w2) {
      return w2 === 0 && D._columnsDetails[0].elements.length > 1 ? (MoveRow.move(D, 0, true), 1) : w2;
    }
    static remove(D, w2) {
      var U;
      w2 = _RemoveRow.changeRowIndexIfRemoveHeaderWithDataBelow(D, w2);
      const O = D.data.length - 1, x2 = (U = D._tableBodyElementRef) == null ? void 0 : U.children[O];
      _RemoveRow.removeRow(D, w2), ToggleAdditionElements.update(D, false, AddNewRowElement.toggle), D._frameComponents.displayIndexColumn && IndexColumn.updateIndexes(D, w2), CustomRowProperties.update(D, w2), setTimeout(() => _RemoveRow.update(D, w2, x2, O));
    }
  };
  var RowDropdownItemEvents = class _RowDropdownItemEvents {
    static onClickMiddleware(D) {
      D(), RowDropdown.hide(this);
    }
    // prettier-ignore
    static set(D, w2, O) {
      const x2 = w2.getElementsByClassName(DropdownItem.DROPDOWN_ITEM_CLASS)[0], U = ElementSiblingIterator.create(x2);
      U.currentElement().onclick = _RowDropdownItemEvents.onClickMiddleware.bind(
        D,
        InsertNewRow.insert.bind(this, D, O, true)
      ), U.next().onclick = _RowDropdownItemEvents.onClickMiddleware.bind(
        D,
        InsertNewRow.insert.bind(this, D, O + 1, true)
      ), U.next().onclick = _RowDropdownItemEvents.onClickMiddleware.bind(
        D,
        MoveRow.move.bind(this, D, O, false)
      ), U.next().onclick = _RowDropdownItemEvents.onClickMiddleware.bind(
        D,
        MoveRow.move.bind(this, D, O, true)
      ), U.next().onclick = _RowDropdownItemEvents.onClickMiddleware.bind(
        D,
        RemoveRow.remove.bind(this, D, O)
      );
    }
  };
  var RowDropdownItem = class _RowDropdownItem {
    static updateDeleteRowItemStyle(D, w2, O) {
      DropdownItem.toggleUsability(O[4], !!(w2 > 0 || D.rowDropdown.canEditHeaderRow));
    }
    static updateMoveRowsItemsStyle(D, w2, O) {
      const { isMoveAvailable: x2, canEditHeaderRow: U } = D.rowDropdown;
      x2 && (DropdownItem.toggleUsability(O[2], true), DropdownItem.toggleUsability(O[3], true), (w2 === 0 || w2 === 1 && !U) && DropdownItem.toggleUsability(O[2], false), (w2 === D._columnsDetails[0].elements.length - 1 || w2 === 0 && !U) && DropdownItem.toggleUsability(O[3], false));
    }
    static updateInsertRowsItemsStyle(D, w2, O) {
      MaximumRows.canAddMore(D) ? (w2 === 0 && !D.rowDropdown.canEditHeaderRow ? DropdownItem.toggleUsability(O[0], false) : DropdownItem.toggleUsability(O[0], true), DropdownItem.toggleUsability(O[1], true)) : (DropdownItem.toggleUsability(O[0], false), DropdownItem.toggleUsability(O[1], false));
    }
    static updateItemStyle(D, w2, O) {
      const x2 = Array.from(w2.children);
      _RowDropdownItem.updateInsertRowsItemsStyle(D, O, x2), _RowDropdownItem.updateMoveRowsItemsStyle(D, O, x2), _RowDropdownItem.updateDeleteRowItemStyle(D, O, x2);
    }
    static update(D, w2, O) {
      _RowDropdownItem.updateItemStyle(D, w2, O), RowDropdownItemEvents.set(D, w2, O);
    }
    static setUpItems(D, w2) {
      setTimeout(() => {
        const { rowDropdown: O } = D, { isInsertUpAvailable: x2, isInsertDownAvailable: U, isMoveAvailable: F, isDeleteAvailable: W } = O, G = RowDropdownButtonItemConf.ITEMS.map((X) => DropdownItem.addButtonItem(D, w2, X));
        x2 || DropdownItem.toggleItem(G[0], false), U || DropdownItem.toggleItem(G[1], false), F || (DropdownItem.toggleItem(G[2], false), DropdownItem.toggleItem(G[3], false)), W || DropdownItem.toggleItem(G[4], false);
      });
    }
  };
  var RowDropdown = class _RowDropdown {
    // prettier-ignore
    static hide(D) {
      const {
        _activeOverlayElements: { rowDropdown: w2, fullTableOverlay: O },
        _focusedElements: { cell: { element: x2, rowIndex: U } },
        _frameComponents: { cellColors: F, displayIndexColumn: W }
      } = D;
      if (!w2 || !O || !x2)
        return;
      Dropdown.hide(w2, O);
      const G = FrameComponentsColors.getColorsBasedOnParam(F, U);
      W && CellHighlightUtils.fade(x2, G.default), DropdownItemHighlightUtils.fadeCurrentlyHighlighted(D._activeOverlayElements), setTimeout(() => {
        delete D._focusedElements.rowDropdown, FocusedCellUtils.purge(D._focusedElements.cell);
      });
    }
    static focusCell(D, w2, O) {
      const { _frameComponents: x2, _focusedElements: U } = D;
      x2.displayIndexColumn ? FocusedCellUtils.setIndexCell(U.cell, O, w2) : FocusedCellUtils.set(U.cell, O, w2, 0);
    }
    // prettier-ignore
    static correctPositionWhenBottomOverflow(D, w2, O) {
      const { top: x2 } = w2.parentElement.getBoundingClientRect(), U = x2 + D.border.topWidth;
      let F = window.innerHeight - U - w2.offsetHeight;
      Browser.IS_FIREFOX && (F += D.border.topWidth), w2.style.top = `${F}px`;
      const W = ElementVisibility.getDetailsInWindow(w2, D.border);
      !W.isFullyVisible && W.blockingSides.has(SIDE.TOP) && (w2.style.top = O);
    }
    static getLeft(D, w2) {
      var x2;
      const O = (x2 = D.rowDropdown.displaySettings.openMethod) == null ? void 0 : x2.cellClick;
      return `${ElementOffset.processWidth(O ? w2.offsetWidth : 5, D._tableDimensions.border)}px`;
    }
    static displayAndSetPosition(D, w2, O) {
      const x2 = `${ElementOffset.processTop(w2.offsetTop, D._tableDimensions.border)}px`;
      O.style.top = x2, O.style.left = _RowDropdown.getLeft(D, w2), Dropdown.display(O);
      const U = ElementVisibility.getDetailsInWindow(O, D._tableDimensions.border);
      U.isFullyVisible || U.blockingSides.has(SIDE.BOTTOM) && _RowDropdown.correctPositionWhenBottomOverflow(D._tableDimensions, O, x2);
    }
    // prettier-ignore
    static setOverflowPosition(D, w2, O, x2) {
      if (D._stickyProps.header && w2.tagName === CellElement.HEADER_TAG)
        if (D._overflow)
          O.style.top = `${x2.scrollTop}px`;
        else {
          const U = w2.parentElement.offsetTop, F = Number.parseInt(getComputedStyle(w2).borderTopWidth);
          O.style.top = `${U + F}px`;
        }
      else
        O.style.top = `${ElementOffset.processTop(w2.offsetTop, D._tableDimensions.border)}px`;
      O.style.left = _RowDropdown.getLeft(D, w2);
    }
    // no active table based overflow
    static displayAndSetPositionForSticky(D, w2, O) {
      const x2 = D.parentElement;
      _RowDropdown.setOverflowPosition(D, w2, O, x2), Dropdown.display(O);
    }
    static displayAndSetPositionOverflow(D, w2, O) {
      const { _tableElementRef: x2, _overflow: U, _stickyProps: F } = D;
      if (!x2 || !(U != null && U.overflowContainer))
        return;
      _RowDropdown.setOverflowPosition(D, w2, O, U.overflowContainer), Dropdown.display(O);
      const W = F.header && w2.tagName === CellElement.HEADER_TAG;
      x2.offsetHeight !== U.overflowContainer.scrollHeight && !W && (O.style.top = `${x2.offsetHeight - O.offsetHeight}px`);
    }
    static display(D, w2) {
      var x2;
      const O = this._activeOverlayElements.rowDropdown;
      RowDropdownItem.update(this, O, D), (x2 = this._overflow) != null && x2.overflowContainer ? _RowDropdown.displayAndSetPositionOverflow(this, w2, O) : this._stickyProps.header ? _RowDropdown.displayAndSetPositionForSticky(this, w2, O) : _RowDropdown.displayAndSetPosition(this, w2, O), FullTableOverlayElement.display(this), setTimeout(() => _RowDropdown.focusCell(this, D, w2));
    }
    static create(D) {
      const w2 = Dropdown.createBase();
      return RowDropdownEvents.set(D, w2), RowDropdownItem.setUpItems(D, w2), w2;
    }
  };
  var RowDropdownCellOverlayEvents = class _RowDropdownCellOverlayEvents {
    static mouseLeave(D, w2) {
      RowDropdownCellOverlay.hide(this, D), delete this._hoveredElements.leftMostCell, RowDropdownCellOverlay.resetDefaultColor(this.rowDropdown.displaySettings, w2);
    }
    static mouseEnter(D, w2) {
      this._hoveredElements.leftMostCell = D, RowDropdownCellOverlay.setHoverColor(this.rowDropdown.displaySettings, w2);
    }
    // prettier-ignore
    static setOverlayEvents(D, w2, O) {
      const x2 = D._rowDropdownCellOverlays[w2].element;
      return x2.onmouseenter = _RowDropdownCellOverlayEvents.mouseEnter.bind(
        D,
        O,
        x2
      ), x2.onmouseleave = _RowDropdownCellOverlayEvents.mouseLeave.bind(
        D,
        w2,
        x2
      ), x2.onclick = RowDropdown.display.bind(D, w2, O), x2;
    }
    static cellMouseLeave(D) {
      RowDropdownCellOverlay.hide(this, D), delete this._hoveredElements.leftMostCell;
    }
    static cellMouseEnter(D, w2) {
      RowDropdownCellOverlay.display(this, D), this._hoveredElements.leftMostCell = w2;
    }
    // This method is adding more events to existing cells instead of overwriting them, the reason for using this approach is
    // because we would instead need to add logic inside data cell events, select/label events, header events and more as
    // row dropdown overlay can appear above them if index column is not displayed
    // Interestingly using setting events like .onmousenter does not overwrite the events that have been added via
    // addEventListener, hence they need to be removed here before adding again
    static addCellEvents(D, w2, O) {
      const { displaySettings: x2, canEditHeaderRow: U } = D.rowDropdown;
      if (!x2.isAvailable || !U && w2 === 0)
        return;
      const F = D._rowDropdownCellOverlays[w2];
      if (F != null && F.cellElement) {
        const { cellElement: W, enter: G, leave: X } = F;
        W.removeEventListener("mouseenter", G), W.removeEventListener("mouseleave", X);
      }
      F.cellElement = O, F.enter = _RowDropdownCellOverlayEvents.cellMouseEnter.bind(D, w2, O), F.leave = _RowDropdownCellOverlayEvents.cellMouseLeave.bind(D, w2), O.addEventListener("mouseenter", F.enter), O.addEventListener("mouseleave", F.leave);
    }
  };
  var _RowDropdownCellOverlay = class Ue {
    static setDefault(D, w2) {
      var O;
      D.style.backgroundColor = ((O = w2 == null ? void 0 : w2.default) == null ? void 0 : O.backgroundColor) || "";
    }
    static resetDefaultColor(D, w2) {
      var x2;
      const O = D.overlayStyles;
      (x2 = O == null ? void 0 : O.hover) != null && x2.backgroundColor && Ue.setDefault(w2, O);
    }
    static setHoverColor(D, w2) {
      var x2, U;
      const O = (U = (x2 = D.overlayStyles) == null ? void 0 : x2.hover) == null ? void 0 : U.backgroundColor;
      O && (w2.style.backgroundColor = O);
    }
    static hide(D, w2) {
      const O = D._hoveredElements.leftMostCell;
      setTimeout(() => {
        if (O !== D._hoveredElements.leftMostCell) {
          const x2 = D._rowDropdownCellOverlays[w2].element;
          x2.style.width = DropdownCellOverlay.HIDDEN_PX;
        }
      });
    }
    static display(D, w2) {
      const O = D._columnsDetails[0], x2 = D._rowDropdownCellOverlays[w2].element;
      x2.style.width = DropdownCellOverlay.VISIBLE_PX;
      const U = O.elements[w2], { displayIndexColumn: F } = D._frameComponents, W = F ? U.previousSibling : U, G = W.offsetHeight / 100;
      x2.style.height = `${G * 60}px`, x2.style.top = `${G * 20}px`;
      const X = F ? O.elements[0].offsetWidth : 0;
      x2.style.left = `-${W.offsetWidth + X}px`;
    }
    static create(D) {
      const w2 = document.createElement("div");
      return w2.classList.add(Ue.ROW_DROPDOWN_CELL_OVERLAY_CLASS), w2.classList.add(DropdownCellOverlay.DROPDOWN_CELL_OVERLAY_CLASS), w2.style.width = DropdownCellOverlay.HIDDEN_PX, Ue.setDefault(w2, D), w2;
    }
    static getCellDividerElement(D, w2) {
      let O = D.nextSibling;
      return w2 && (O = O.nextSibling), O;
    }
    static add(D, w2, O) {
      const x2 = Ue.create(D.rowDropdown.displaySettings.overlayStyles), { displayIndexColumn: U } = D._frameComponents;
      Ue.getCellDividerElement(O, !!U).appendChild(x2), D._rowDropdownCellOverlays.splice(w2, 0, {
        element: x2,
        // these events are stubs and will be replaced by real ones in RowDropdownCellOverlayEvents.addCellEvents
        enter: () => {
        },
        leave: () => {
        }
      });
    }
    static resetOverlays(D) {
      var O;
      if (!((O = D.rowDropdown.displaySettings.openMethod) != null && O.overlayClick))
        return;
      D._rowDropdownCellOverlays.splice(0, D._rowDropdownCellOverlays.length), ExtractElements.textRowsArrFromTBody(D._tableBodyElementRef, D.data).forEach((x2, U) => {
        const F = x2.children[0];
        Ue.add(D, U, F), RowDropdownCellOverlayEvents.setOverlayEvents(D, U, F);
      });
    }
  };
  _RowDropdownCellOverlay.ROW_DROPDOWN_CELL_OVERLAY_CLASS = "row-dropdown-cell-overlay";
  var RowDropdownCellOverlay = _RowDropdownCellOverlay;
  var PaginationRowIndexes = class _PaginationRowIndexes {
    static getVisibleRowRealIndex(D, w2, O) {
      const x2 = Array.from(D.children), U = O === void 0 ? w2.visibleRows.length - 1 : O, F = w2.visibleRows[U];
      return x2.findIndex((W) => W === F);
    }
    static getVisibleRowIndex(D, w2, O) {
      const x2 = D.children[O];
      return w2.visibleRows.findIndex((U) => U === x2);
    }
    static getFilteredMaxVisibleRowIndex(D, w2) {
      const { rowsPerPage: O, visibleRows: x2 } = w2, U = _PaginationRowIndexes.getVisibleRowRealIndex(D, w2);
      return x2.length === O ? U : U + (O - x2.length);
    }
    static getRawMaxVisibleRowIndex(D) {
      const { _pagination: w2, _tableBodyElementRef: O, data: x2, _visiblityInternal: U } = D, { activePageNumber: F, rowsPerPage: W, isAllRowsOptionSelected: G } = w2;
      return G ? x2.length + 1 : U.filters ? _PaginationRowIndexes.getFilteredMaxVisibleRowIndex(O, w2) : F * W;
    }
    static getMaxVisibleRowIndex(D) {
      const { dataStartsAtHeader: w2 } = D;
      let O = _PaginationRowIndexes.getRawMaxVisibleRowIndex(D);
      return w2 || (O += 1), O;
    }
  };
  var _RowElement = class Re {
    static create() {
      const D = document.createElement("tr");
      return D.classList.add("row"), D;
    }
    static moveClassToLastVisibleRow(D, w2) {
      w2 && (w2.id = ""), D.id = Re.LAST_VISIBLE_ROW_ID;
    }
    static toggleNonAddRow(D, w2, O) {
      if (D.pagination && D._pagination) {
        const U = D._pagination.visibleRows[D._pagination.visibleRows.length - 1];
        if (U)
          return Re.moveClassToLastVisibleRow(U, O);
      }
      const { previousElementSibling: x2 } = w2;
      x2 && Re.moveClassToLastVisibleRow(x2, O);
    }
    // REF-25
    // Add new row element is always appended to the table, but not always visible (e.g. if the user has
    // chosen not to display it or max rows has been reached), hence we must always monitor its current
    // visibility and given that it can be safely assumed that it is the last row element, we can use
    // its isDisplayed method to help assign the last-visible row id to the correct row
    static toggleLastRowClass(D) {
      const w2 = D.shadowRoot, O = D._addRowCellElementRef.parentElement, x2 = w2.getElementById(Re.LAST_VISIBLE_ROW_ID);
      AddNewRowElement.isDisplayed(O.children[0]) ? O.id !== Re.LAST_VISIBLE_ROW_ID && Re.moveClassToLastVisibleRow(O, x2) : Re.toggleNonAddRow(D, O, x2);
    }
  };
  _RowElement.LAST_VISIBLE_ROW_ID = "last-visible-row";
  var RowElement = _RowElement;
  var CellDividerElement = class {
    static create(D) {
      const w2 = document.createElement("div");
      return w2.classList.add("cell-divider"), D === 0 && (w2.style.height = ColumnSizerGenericUtils.canHeightBeInherited() ? "100%" : "inherit"), w2;
    }
  };
  var InsertNewCell = class _InsertNewCell {
    // prettier-ignore
    static insertElementsToRow(D, w2, O, x2, U) {
      const F = CellElementIndex.getViaColumnIndex(x2, U);
      D.insertBefore(w2, D.children[F]);
      const W = CellDividerElement.create(O);
      D.insertBefore(W, D.children[F + 1]);
    }
    static updateColumnDetailsAndSizers(D, w2, O, x2) {
      const U = D._columnsDetails[O];
      if (U && w2 === 0) {
        const F = ColumnDropdownCellOverlay.add(D, O);
        ColumnDetails.updateWithNoSizer(U, F), InsertRemoveColumnSizer.insert(D, O), x2 && (InsertRemoveColumnSizer.cleanUpCustomColumnSizers(D, O), UpdateIndexColumnWidth.wrapTextWhenNarrowColumnsBreached(D));
      }
    }
    // prettier-ignore
    static insert(D, w2, O, x2, U, F, W) {
      const { _frameComponents: { displayIndexColumn: G }, data: X, _columnsDetails: K } = D, q = K[W];
      q.elements.splice(F, 0, O), q.processedStyle.splice(F, 0, ProcessedDataTextStyle.getDefaultProcessedTextStyle()), _InsertNewCell.insertElementsToRow(w2, O, F, W, !!G), X[F].splice(W, U ? 0 : 1, x2);
    }
    static convertCell(D, w2, O, x2) {
      const U = D._columnsDetails[O];
      w2 === 0 && D.displayHeaderIcons && HeaderIconCellElement.setHeaderIconStructure(D, x2, O), U.activeType && (U.activeType.cellDropdownProps ? w2 === 0 ? CellDropdown.setUpDropdown(D, O) : (SelectCell.convertCell(D, O, x2), SelectCell.finaliseEditedText(D, x2.children[0], O, true)) : w2 > 0 && (U.activeType.checkbox && CheckboxCellElement.setCellCheckboxStructure(D, x2, O, w2), U.activeType.calendar && DateCellElement.setCellDateStructure(D, x2, O)));
    }
    // REF-13
    // prettier-ignore
    static insertInitialColumnDetails(D, w2, O) {
      const { _columnsDetails: x2, _customColumnsSettings: U, _cellDropdownContainer: F, _defaultColumnsSettings: W } = D, G = CellDropdown.createAndAppend(F), X = ColumnDetails.createInitial(
        W,
        G,
        U[w2],
        D._defaultCellHoverColors,
        FireEvents.onColumnsUpdate.bind(this, D)
      );
      x2.splice(O, 0, X);
    }
    // isNewText indicates whether rowData is already in the data state or if it needs to be added
    // prettier-ignore
    static insertToRow(D, w2, O, x2, U, F) {
      O === 0 && _InsertNewCell.insertInitialColumnDetails(D, U, x2);
      const W = DataUtils.processCellText(D, O, x2, U), G = CellElement.createCellElement(D, W, x2, O === 0);
      _InsertNewCell.insert(D, w2, G, W, F, O, x2), _InsertNewCell.convertCell(D, O, x2, G), O === 0 ? (F && StaticTableWidthUtils.changeWidthsBasedOnColumnInsertRemove(D, true), ColumnSettingsBorderUtils.updateSiblingColumns(D, x2)) : ProcessedDataTextStyle.setCellStyle(D, O, x2), setTimeout(() => _InsertNewCell.updateColumnDetailsAndSizers(D, O, x2, F));
    }
  };
  var InsertNewRow = class _InsertNewRow {
    // CAUTION-2 if the addition or removal of row causes the parent div to change width, this is indeed run after rerender,
    // however the notification messages are necessary and the rebinding does not seem to cause issues, nevertheless take
    // note of this if editing any of the logic below
    static bindAndfireCellUpdates(D, w2) {
      var F;
      const O = D.data.length - 1, U = { element: (F = D._tableBodyElementRef) == null ? void 0 : F.children[O], index: O };
      UpdateCellsForRows.rebindAndFireUpdates(D, w2, CELL_UPDATE_TYPE.ADD, U), setTimeout(() => FireEvents.onDataUpdate(D));
    }
    static canStartRenderCellBeAdded(D, w2, O) {
      return w2 === 0 ? MaximumColumns.canAddMore(D) : D._columnsDetails[O];
    }
    // prettier-ignore
    static addCells(D, w2, O, x2, U) {
      const { _frameComponents: { displayIndexColumn: F, displayAddNewColumn: W } } = D;
      F && IndexColumn.createAndPrependToRow(D, O, x2), w2.forEach((G, X) => {
        (U || _InsertNewRow.canStartRenderCellBeAdded(D, x2, X)) && InsertNewCell.insertToRow(D, O, x2, X, G, U);
      }), W && AddNewColumnElement.createAndAppendToRow(D, O, x2), setTimeout(() => RowDropdownCellOverlay.add(D, x2, O.children[0]));
    }
    static updatePagination(D, w2, O, x2) {
      O ? PaginationUtils.updateOnRowChange(D, w2, x2) : PaginationUtils.initialRowUpdates(D, w2, x2);
    }
    static insertNewRow(D, w2, O, x2) {
      var W, G;
      const U = x2 || DataUtils.createEmptyStringDataArray(((W = D.data[0]) == null ? void 0 : W.length) || 1), F = RowElement.create();
      return D.pagination && _InsertNewRow.updatePagination(D, w2, O, F), (G = D._tableBodyElementRef) == null || G.insertBefore(F, D._tableBodyElementRef.children[w2]), O && D.data.splice(w2, 0, []), _InsertNewRow.addCells(D, U, F, w2, O), F;
    }
    // isNewText indicates whether rowData is already in the data state or if it needs to be added
    static insert(D, w2, O, x2) {
      if (!MaximumRows.canAddMore(D))
        return;
      const U = O && w2 === 0 && D._columnsDetails.length > 0;
      U && (w2 = 1);
      const F = _InsertNewRow.insertNewRow(D, w2, O, x2);
      O && (ToggleAdditionElements.update(D, true, AddNewRowElement.toggle), D._frameComponents.displayIndexColumn && IndexColumn.updateIndexes(D, w2 + 1), CustomRowProperties.update(D, w2)), U && MoveRow.move(D, 0, true), setTimeout(() => {
        D._isPopulatingTable ? UpdateCellsForRows.updateRowCells(D, F, w2, CELL_UPDATE_TYPE.ADD) : x2 ? w2 === D.data.length - 1 && _InsertNewRow.bindAndfireCellUpdates(D, 0) : _InsertNewRow.bindAndfireCellUpdates(D, w2);
      });
    }
    // prettier-ignore
    static insertEvent() {
      let D = this.data.length;
      if (this.pagination)
        if (this._visiblityInternal.filters && this._tableBodyElementRef)
          D = this.data.length === 1 && !this.dataStartsAtHeader ? 1 : PaginationRowIndexes.getVisibleRowRealIndex(this._tableBodyElementRef, this._pagination) + 1;
        else {
          const w2 = PaginationRowIndexes.getMaxVisibleRowIndex(this);
          w2 < D && (D = w2);
        }
      _InsertNewRow.insert(this, D, true);
    }
  };
  var AddNewRowEvents = class _AddNewRowEvents {
    static mouseEnterCell(D, w2) {
      CellHighlightUtils.highlight(w2.target, D.hover);
    }
    static mouseLeaveCell(D, w2) {
      CellHighlightUtils.fade(w2.target, D.default);
    }
    static setCellEvents(D, w2) {
      w2.onclick = InsertNewRow.insertEvent.bind(D);
      const O = D._frameComponents.cellColors.data;
      w2.onmouseenter = _AddNewRowEvents.mouseEnterCell.bind(this, O), w2.onmouseleave = _AddNewRowEvents.mouseLeaveCell.bind(this, O);
    }
  };
  var _AddNewRowElement = class ge {
    static isDisplayed(D) {
      return D.style.display === ge.VISIBLE;
    }
    static setDisplay(D, w2) {
      ge.isDisplayed(D) !== w2 && (D.style.display = w2 ? ge.VISIBLE : ge.HIDDEN);
    }
    static setDefaultStyle(D) {
      D.innerText = "+ New", D.style.width = "";
    }
    // prettier-ignore
    static createCell(D) {
      const { _defaultColumnsSettings: { cellStyle: w2 }, _frameComponents: { displayAddNewRow: O, styles: x2 }, rootCell: U } = D, F = CellElement.createDataCell(false, w2, x2 == null ? void 0 : x2.default);
      return F.id = ge.ID, O ? ge.setDefaultStyle(F) : (RootCellElement.convertToRootCell(F, U == null ? void 0 : U.text), F.addEventListener("click", ge.setDisplay.bind(this, F, false))), ge.setDisplay(F, O), F.colSpan = ge.DEFAULT_COL_SPAN, AddNewRowEvents.setCellEvents(D, F), F;
    }
    static create(D) {
      const w2 = RowElement.create(), O = ge.createCell(D);
      return w2.appendChild(O), O;
    }
    // prettier-ignore
    static toggle(D) {
      const { _tableBodyElementRef: w2, _addRowCellElementRef: O, _frameComponents: { displayAddNewRow: x2 } } = D;
      !(O != null && O.parentElement) || !w2 || (x2 && ge.setDisplay(O, MaximumRows.canAddMore(D)), RowElement.toggleLastRowClass(D));
    }
    static isAddNewRowRow(D) {
      var w2;
      return ((w2 = D == null ? void 0 : D.children[0]) == null ? void 0 : w2.id) === ge.ID;
    }
  };
  _AddNewRowElement.DEFAULT_COL_SPAN = 1e9;
  _AddNewRowElement.HIDDEN = "none";
  _AddNewRowElement.VISIBLE = "";
  _AddNewRowElement.ID = "add-new-row-cell";
  var AddNewRowElement = _AddNewRowElement;
  var ElementEvents = class {
    static toggleListeners(D, w2, O) {
      Object.keys(w2).forEach((x2) => {
        (w2[x2] || []).forEach((F) => {
          D[O ? "addEventListener" : "removeEventListener"](x2, F);
        });
      });
    }
    static convertToArrayObj(D) {
      return Object.keys(D).reduce((w2, O) => {
        const x2 = O, U = D[x2];
        return x2 && U && (w2[x2] = [U]), w2;
      }, {});
    }
    static getDefault() {
      return { rootCell: { styles: {} } };
    }
  };
  var RootCellEvents = class _RootCellEvents {
    static removeEvents(D, w2) {
      AddNewRowElement.setDefaultStyle(D), ElementEvents.toggleListeners(D, w2.styles, false), D.dispatchEvent(new MouseEvent("mouseenter")), delete w2.applied;
    }
    // setting, not apply here as this is only triggered once
    static setEventFunctions(D, w2, O) {
      if (O && (D._eventFunctions.rootCell.styles = ElementEvents.convertToArrayObj(
        StatefulCSSEvents.getEvents(w2, O)
      )), D._frameComponents.displayAddNewRow) {
        const x2 = RootCellElement.convertFromRootCell.bind(this, D), { styles: U } = D._eventFunctions.rootCell;
        U.click ?? (U.click = []), U.click.push(x2);
      }
    }
    static applyStyles(D, w2, O) {
      var U, F, W, G;
      const x2 = ElementStyle.generateStatefulCSS(w2, {}, {});
      (U = x2.default) != null && U.width && (O.style.width = x2.default.width), (F = x2.default) == null || delete F.width, (W = x2.hover) == null || delete W.width, (G = x2.click) == null || delete G.width, Object.assign(D.style, x2.default);
    }
    // prettier-ignore
    static applyEvents(D, w2) {
      const { _tableElementRef: O, rootCell: x2, _eventFunctions: { rootCell: U } } = D, F = x2 != null && x2.styles ? JSON.parse(JSON.stringify(x2.styles)) : null;
      F && O && _RootCellEvents.applyStyles(w2, F, O), Object.keys(U.styles).length === 0 && _RootCellEvents.setEventFunctions(D, w2, F), ElementEvents.toggleListeners(w2, U.styles, true), U.applied = true;
    }
  };
  var _RootCellElement = class Je {
    // prettier-ignore
    static convertFromRootCell(D) {
      const { _addRowCellElementRef: w2, rootCell: O, _eventFunctions: { rootCell: x2 } } = D;
      w2 && (w2.classList.remove(Je.ROOT_CELL_CLASS), O != null && O.styles && ElementStyle.unsetAllCSSStates(w2, O.styles), RootCellEvents.removeEvents(w2, x2));
    }
    static convertToRootCell(D, w2) {
      D.classList.add(Je.ROOT_CELL_CLASS), D.innerText = w2 || "+", D.style.width = `${TableDimensionsUtils.MINIMAL_TABLE_WIDTH}px`;
    }
    // addNewRowCell is preserved as it is reused as the root cell
    static removeRows(D) {
      Array.from(D.children).slice(0, D.children.length - 1).forEach((w2) => w2.remove());
    }
    // prettier-ignore
    static display(D) {
      const {
        _tableBodyElementRef: w2,
        _addColumnCellsElementsRef: O,
        _addRowCellElementRef: x2,
        rootCell: U,
        _frameComponents: { displayAddNewColumn: F, displayAddNewRow: W }
      } = D;
      if (!x2)
        return;
      const G = w2;
      F && O.splice(0, O.length), Je.removeRows(G), W && Je.convertToRootCell(x2, U == null ? void 0 : U.text), D._eventFunctions.rootCell.applied || RootCellEvents.applyEvents(D, x2), AddNewRowElement.setDisplay(x2, true);
    }
  };
  _RootCellElement.ROOT_CELL_CLASS = "root-cell";
  var RootCellElement = _RootCellElement;
  var ToggleAdditionElements = class {
    static update(D, w2, O) {
      D.data.length === 0 || D._columnsDetails.length === 0 ? RootCellElement.display(D) : O(D, w2);
    }
  };
  var InsertNewColumn = class _InsertNewColumn {
    static updateColumns(D, w2, O, x2) {
      const U = { element: w2, index: O }, F = LastColumn.getDetails(D._columnsDetails, O);
      UpdateCellsForColumns.rebindAndFireUpdates(D, U, x2, CELL_UPDATE_TYPE.ADD, F);
    }
    static insertToAllRows(D, w2, O) {
      ExtractElements.textRowsArrFromTBody(D._tableBodyElementRef, D.data).forEach((U, F) => {
        const W = O ? O[F] : EMPTY_STRING;
        InsertNewCell.insertToRow(D, U, F, w2, W, true), setTimeout(() => _InsertNewColumn.updateColumns(D, U, F, w2));
      });
    }
    // columnData is in a row format to populate the column by iterating through each row
    static insert(D, w2, O) {
      MaximumColumns.canAddMore(D) && (FocusedCellUtils.incrementColumnIndex(D._focusedElements.cell, w2), _InsertNewColumn.insertToAllRows(D, w2, O), ToggleAdditionElements.update(D, true, AddNewColumnElement.toggle), setTimeout(() => {
        FireEvents.onDataUpdate(D), FireEvents.onColumnsUpdate(D);
      }));
    }
    static insertEvent() {
      _InsertNewColumn.insert(this, this._columnsDetails.length);
    }
  };
  var InsertMatrix = class _InsertMatrix {
    // prettier-ignore
    static removeDataThatIsNotEditableFromNewRows(D, w2, O) {
      return D.slice(O).forEach((U, F) => {
        U.settings.isCellTextEditable || w2.forEach((W) => {
          W[F] = EMPTY_STRING;
        });
      }), w2;
    }
    // if the data does not fill the 2D array, fill cells with empty strings
    static createRowDataArrayWithEmptyCells(D, w2, O) {
      const x2 = DataUtils.createEmptyStringDataArray(D);
      return x2.splice(O, w2.length, ...w2), x2;
    }
    // prettier-ignore
    static createNewRows(D, w2, O) {
      _InsertMatrix.removeDataThatIsNotEditableFromNewRows(
        D._columnsDetails,
        w2,
        O
      ).forEach((U) => {
        var W;
        const F = _InsertMatrix.createRowDataArrayWithEmptyCells(
          ((W = D.data[0]) == null ? void 0 : W.length) || 0,
          U,
          O
        );
        InsertNewRow.insert(D, D.data.length, true, F);
      });
    }
    static changeColumnSettings(D, w2) {
      const { elements: O } = D._columnsDetails[w2];
      FocusedCellUtils.set(D._focusedElements.cell, O[0], 0, w2), HeaderText.onAttemptChange(D, O[0], w2);
    }
    static processNewColumn(D) {
      const w2 = D._columnsDetails.length - 1;
      CellEvents.setCellToDefaultIfNeeded(D, 0, w2, D._columnsDetails[w2].elements[0], false), _InsertMatrix.changeColumnSettings(D, w2);
    }
    // prettier-ignore
    static createNewColumns(D, w2, O) {
      ArrayUtils.transpose(w2).forEach((U) => {
        const F = _InsertMatrix.createRowDataArrayWithEmptyCells(
          D.data.length,
          U,
          O
        );
        InsertNewColumn.insert(D, D.data[0].length, F), _InsertMatrix.processNewColumn(D);
      });
    }
    // prettier-ignore
    static overwriteCell(D, w2, O, x2, U) {
      const { _frameComponents: { displayIndexColumn: F }, _columnsDetails: W } = D, G = CellElementIndex.getViaColumnIndex(x2, !!F), X = w2.children[G], K = W[x2];
      O === 0 && !K.settings.isHeaderTextEditable || O > 0 && !K.settings.isCellTextEditable || (O === 0 && CellElement.setNewText(D, X, U, false, false), CellEvents.updateCell(D, U, O, x2, { element: X, updateTableEvent: false }), ColumnTypesUtils.updateDataElements(D, O, x2, X), O === 0 && _InsertMatrix.changeColumnSettings(D, x2));
    }
    // prettier-ignore
    static overwriteRowData(D, w2, O, x2, U) {
      w2.forEach((F, W) => {
        const G = x2 + W;
        _InsertMatrix.overwriteCell(D, U, O, G, F);
      });
    }
    // prettier-ignore
    static setCaretToEndAndHighlightIfSelect(D, w2, O) {
      const { activeType: x2, cellDropdown: U, settings: { defaultText: F } } = D._columnsDetails[O];
      CaretPosition.setToEndOfText(D, w2), x2.cellDropdownProps && CellDropdown.updateCellDropdown(w2, U, D._tableDimensions.border, F, true);
    }
    // prettier-ignore
    static overwriteExistingCells(D, w2, O, x2) {
      const U = [];
      w2.forEach((W, G) => {
        var re;
        const X = O + G, K = (re = D._tableBodyElementRef) == null ? void 0 : re.children[X], q = D.data[0].length - x2, Q = W.slice(0, q);
        _InsertMatrix.overwriteRowData(D, Q, X, x2, K);
        const le = W.slice(q);
        U.push(le);
      });
      const F = D._focusedElements.cell.element;
      return setTimeout(() => _InsertMatrix.setCaretToEndAndHighlightIfSelect(D, F, x2)), U;
    }
    // no new rows should be created if no columns that are to be overwritten/created allow text edit
    static canNewRowsBeCreated(D, w2, O) {
      return D._columnsDetails.slice(O, O + w2[0].length).find((x2) => x2.settings.isCellTextEditable);
    }
    static insertColumnsInsideIfCantInsertRight(D, w2, O) {
      const U = D._columnsDetails.slice(O).findIndex((F) => F.settings.columnDropdown.isInsertRightAvailable === false);
      if (U !== -1)
        if (U === 0)
          w2.forEach((F) => F.splice(1, F.length - 1));
        else {
          const F = w2[0].length - (U + 1);
          for (let W = 0; W < F; W += 1)
            InsertNewColumn.insert(D, O + U + W);
        }
    }
    static getNewMatrixBasedOnColumns(D, w2, O) {
      var U, F;
      const x2 = (((U = D[0]) == null ? void 0 : U.length) || 0) - (((F = w2[0]) == null ? void 0 : F.length) || 0) - O;
      return x2 > 0 ? new Array(w2.length).fill(new Array(x2).fill(EMPTY_STRING)) : [];
    }
    // A matrix is a complete 2D array
    // prettier-ignore
    static insert(D, w2, O, x2, U) {
      const F = D.data.length - O;
      U || _InsertMatrix.insertColumnsInsideIfCantInsertRight(D, w2, x2);
      const W = w2.slice(0, F), G = U ? _InsertMatrix.getNewMatrixBasedOnColumns(w2, D.data, x2) : _InsertMatrix.overwriteExistingCells(D, W, O, x2);
      if (_InsertMatrix.createNewColumns(D, G, O), !U && !_InsertMatrix.canNewRowsBeCreated(D, w2, x2))
        return;
      const X = w2.slice(F);
      _InsertMatrix.createNewRows(D, X, x2), setTimeout(() => FireEvents.onDataUpdate(D));
    }
  };
  var _ParseCSVClipboardText = class ue {
    static preprocessText(D) {
      let w2 = D;
      return D.charAt(0) === ue.STRING_QUOTE_SYMBOL && (w2 = w2.substring(1)), D.charAt(D.length - 1) === ue.STRING_QUOTE_SYMBOL && (w2 = w2.substring(0, D.length - 2)), w2;
    }
    static getSeparatorSymbols(D) {
      return D.indexOf(ue.EXPLICIT_WINDOWS_NEW_LINE_SYMBOL) > -1 ? {
        newLine: ue.EXPLICIT_WINDOWS_NEW_LINE_SYMBOL,
        tab: ue.EXPLICIT_TAB_SYMBOL
      } : D.indexOf(ue.WINDOWS_NEW_LINE_SYMBOL) > -1 ? { newLine: ue.WINDOWS_NEW_LINE_SYMBOL, tab: ue.TAB_SYMBOL } : D.indexOf(ue.EXPLICIT_NEW_LINE_SYMBOL) > -1 || D.indexOf(ue.EXPLICIT_TAB_SYMBOL) > -1 ? { newLine: ue.EXPLICIT_NEW_LINE_SYMBOL, tab: ue.EXPLICIT_TAB_SYMBOL } : { newLine: ue.NEW_LINE_SYMBOL, tab: ue.TAB_SYMBOL };
    }
    static parse(D) {
      const w2 = ue.preprocessText(D), { newLine: O, tab: x2 } = ue.getSeparatorSymbols(w2);
      return w2.split(O).map((F) => F.split(x2).map((G) => G.replace(/\\"/g, "")));
    }
  };
  _ParseCSVClipboardText.STRING_QUOTE_SYMBOL = '"';
  _ParseCSVClipboardText.TAB_SYMBOL = "\\t";
  _ParseCSVClipboardText.NEW_LINE_SYMBOL = "\\n";
  _ParseCSVClipboardText.EXPLICIT_TAB_SYMBOL = "\\\\t";
  _ParseCSVClipboardText.EXPLICIT_NEW_LINE_SYMBOL = "\\\\n";
  _ParseCSVClipboardText.WINDOWS_NEW_LINE_SYMBOL = "\\r\\n";
  _ParseCSVClipboardText.EXPLICIT_WINDOWS_NEW_LINE_SYMBOL = "\\\\r\\\\n";
  var ParseCSVClipboardText = _ParseCSVClipboardText;
  var OverwriteCellsViaCSVOnPaste = class _OverwriteCellsViaCSVOnPaste {
    static trimCSVRowsIfPaginationAsync(D, w2, O, x2) {
      var G;
      const U = D.length + O;
      w2.length < U && (D = D.slice(0, D.length - (U - w2.length)));
      const F = ((G = w2[0]) == null ? void 0 : G.length) || 0, W = D[0].length + x2;
      if (F < W) {
        const X = D[0].length - (W - F);
        D.forEach((K) => K.splice(X));
      }
      return D;
    }
    static focusOriginalCellAfterProcess(D, w2) {
      const { element: O, rowIndex: x2, columnIndex: U } = D._focusedElements.cell;
      w2(), FocusedCellUtils.set(D._focusedElements.cell, O, x2, U);
    }
    // prettier-ignore
    static overwrite(D, w2, O, x2, U) {
      O.preventDefault();
      let F = ParseCSVClipboardText.parse(w2);
      D._pagination.async && (F = _OverwriteCellsViaCSVOnPaste.trimCSVRowsIfPaginationAsync(F, D.data, x2, U)), _OverwriteCellsViaCSVOnPaste.focusOriginalCellAfterProcess(
        D,
        InsertMatrix.insert.bind(this, D, F, x2, U)
      );
    }
    static isCSVData(D) {
      return D.indexOf(ParseCSVClipboardText.NEW_LINE_SYMBOL) > -1 || D.indexOf(ParseCSVClipboardText.TAB_SYMBOL) > -1;
    }
  };
  var KEYBOARD_COMBINATION_EVENT = /* @__PURE__ */ ((Y) => (Y.PASTE = "Paste", Y))(KEYBOARD_COMBINATION_EVENT || {});
  var KEYBOARD_EVENT = { ...KEYBOARD_COMBINATION_EVENT, [KEYBOARD_KEY.TAB]: KEYBOARD_KEY.TAB };
  var _UserKeyEventsStateUtils = class Tt {
    static createNew() {
      return { [KEYBOARD_KEY.TAB]: false, [KEYBOARD_EVENT.PASTE]: false, [MOUSE_EVENT.DOWN]: false };
    }
    static temporarilyIndicateEvent(D, w2) {
      D[w2] = true, setTimeout(() => D[w2] = false, Tt.KEY_PRESS_STATE_TIMEOUT_ML);
    }
  };
  _UserKeyEventsStateUtils.KEY_PRESS_STATE_TIMEOUT_ML = 5;
  var UserKeyEventsStateUtils = _UserKeyEventsStateUtils;
  var _PasteUtils = class St {
    static sanitizePastedTextData(D) {
      var O, x2;
      D.preventDefault();
      const w2 = (O = D.clipboardData) == null ? void 0 : O.getData("text/plain");
      (x2 = document.execCommand) == null || x2.call(document, "insertHTML", false, w2);
    }
    static extractClipboardText(D) {
      var w2;
      return JSON.stringify((w2 = D.clipboardData) == null ? void 0 : w2.getData(St.TEXT_DATA_FORMAT));
    }
  };
  _PasteUtils.TEXT_DATA_FORMAT = "text/plain";
  var PasteUtils = _PasteUtils;
  var UNDO_INPUT_TYPE = "historyUndo";
  var DataCellEvents = class _DataCellEvents {
    static keyDownCell(D, w2, O) {
      const { elements: x2, activeType: U } = this._columnsDetails[w2];
      O.key === KEYBOARD_KEY.TAB ? UserKeyEventsStateUtils.temporarilyIndicateEvent(this._userKeyEventsState, KEYBOARD_KEY.TAB) : O.key === KEYBOARD_KEY.ENTER && this.enterKeyMoveDown && !U.cellDropdownProps && FocusNextRowCell.focus(this, D, x2, O);
    }
    // using this instead of keydown because when this is fired the new cell text is available
    // prettier-ignore
    static inputCell(D, w2, O) {
      const x2 = O, U = x2.target;
      if (DateCellInputElement.isInputElement(U))
        return;
      const F = CellElement.getText(U);
      if (!this._userKeyEventsState[KEYBOARD_EVENT.PASTE]) {
        const W = x2.inputType === UNDO_INPUT_TYPE;
        CellElement.setNewText(this, U, F, false, W, false);
        const G = this._columnsDetails[w2];
        G.activeType.cellDropdownProps && D > 0 && CellDropdown.updateCellDropdown(
          U,
          G.cellDropdown,
          this._tableDimensions.border,
          G.settings.defaultText,
          true
        ), CellEvents.updateCell(this, F, D, w2, { processText: false });
      }
    }
    // prettier-ignore
    static pasteCell(D, w2, O) {
      UserKeyEventsStateUtils.temporarilyIndicateEvent(this._userKeyEventsState, KEYBOARD_EVENT.PASTE), PasteUtils.sanitizePastedTextData(O);
      const x2 = PasteUtils.extractClipboardText(O);
      if (OverwriteCellsViaCSVOnPaste.isCSVData(x2))
        OverwriteCellsViaCSVOnPaste.overwrite(this, x2, O, D, w2);
      else {
        const U = O.target, { cellDropdown: F, settings: { defaultText: W }, activeType: G } = this._columnsDetails[w2], X = U.tagName === "BR" ? U.parentElement : U;
        setTimeout(() => {
          G.cellDropdownProps && CellDropdown.updateCellDropdown(
            X,
            F,
            this._tableDimensions.border,
            W,
            true
          ), CellEvents.updateCell(this, CellElement.getText(X), D, w2, { processText: false });
        });
      }
    }
    // prettier-ignore
    // textContainerElement can be cell element for data cell, text element for select/label and date cells
    static blur(D, w2, O, x2) {
      CaretDisplayFix.isIssueBrowser() && CaretDisplayFix.removeContentEditable(x2), CellEvents.setCellToDefaultIfNeeded(D, w2, O, x2), FocusedCellUtils.purge(D._focusedElements.cell);
    }
    static blurCell(D, w2, O) {
      var x2, U, F;
      D === 0 && !((F = (U = (x2 = this._defaultColumnsSettings.columnDropdown) == null ? void 0 : x2.displaySettings) == null ? void 0 : U.openMethod) != null && F.cellClick) && HeaderText.onAttemptChange(this, O.target, w2), _DataCellEvents.blur(this, D, w2, O.target);
    }
    // textContainerElement can be cell element for data cell, text element for select/label and date cells
    static prepareText(D, w2, O, x2) {
      var F, W, G;
      const U = (G = (W = (F = D._defaultColumnsSettings.columnDropdown) == null ? void 0 : F.displaySettings) == null ? void 0 : W.openMethod) == null ? void 0 : G.cellClick;
      CaretDisplayFix.isIssueBrowser() && (w2 > 0 || !U) && CaretDisplayFix.setContentEditable(x2), CellEvents.removeTextIfDefault(D, w2, O, x2);
    }
    static focusCell(D, w2, O) {
      const x2 = O.target;
      _DataCellEvents.prepareText(this, D, w2, x2);
      const { _userKeyEventsState: U, _focusedElements: F } = this;
      U[KEYBOARD_KEY.TAB] && CaretPosition.setToEndOfText(this, x2), FocusedCellUtils.set(F.cell, x2, D, w2);
    }
    static setEvents(D, w2, O, x2) {
      w2.onfocus = _DataCellEvents.focusCell.bind(D, O, x2), w2.onblur = _DataCellEvents.blurCell.bind(D, O, x2), w2.onmouseenter = () => {
      }, w2.onmouseleave = () => {
      }, w2.onmousedown = () => {
      }, w2.oninput = _DataCellEvents.inputCell.bind(D, O, x2), w2.onpaste = _DataCellEvents.pasteCell.bind(D, O, x2), w2.onkeydown = _DataCellEvents.keyDownCell.bind(D, O, x2);
    }
  };
  var SelectCellTextBaseEvents = class _SelectCellTextBaseEvents {
    // the reason why this is triggered by window is because when the user clicks on dropdown padding or delete button
    // keydown events will no longer be fired through the cell text - however we need to maintain the same behaviour
    // prettier-ignore
    static keyDownText(D, w2, O, x2) {
      const { cellDropdown: { activeItems: U, canAddMoreOptions: F }, elements: W } = D._columnsDetails[O];
      x2.key === KEYBOARD_KEY.ESCAPE ? CellWithTextEvents.programmaticBlur(D) : x2.key === KEYBOARD_KEY.TAB ? CellTextEvents.tabOutOfCell(D, w2, O, x2) : x2.key === KEYBOARD_KEY.ENTER ? (x2.preventDefault(), FocusNextRowCell.focusOrBlurSelect(W, w2)) : x2.key === KEYBOARD_KEY.ARROW_UP ? (x2.preventDefault(), CellDropdownItem.setSiblingItemOnCell(D, U, "previousSibling")) : x2.key === KEYBOARD_KEY.ARROW_DOWN ? (x2.preventDefault(), CellDropdownItem.setSiblingItemOnCell(D, U, "nextSibling")) : (D.dataStartsAtHeader || w2 > 0) && !F && x2.preventDefault();
    }
    static displayDropdown(D, w2, O) {
      var W;
      const x2 = CellDropdown.display(D, w2, O), { activeType: U, cellDropdown: F } = D._columnsDetails[w2];
      (W = U.cellDropdownProps) != null && W.isBasicSelect && x2 && (F.displayedCellElement = O, ArrowDownIconElement.toggle(O, true), ArrowDownIconElement.setActive(O));
    }
    static clearTypeSpecificProps(D, w2) {
      const { cellDropdown: O, activeType: x2 } = w2;
      x2.cellDropdownProps && (x2.cellDropdownProps.isBasicSelect ? (ArrowDownIconElement.toggle(O.displayedCellElement, false), delete O.displayedCellElement) : OptionButton.hideAfterColorPickerContainerClose(D, w2));
    }
    static blurring(D, w2, O, x2) {
      const U = D._columnsDetails[O];
      Dropdown.hide(U.cellDropdown.element), U.cellDropdown.itemsDetails[CellElement.getText(x2)] || SelectCell.finaliseEditedText(D, x2, O), _SelectCellTextBaseEvents.clearTypeSpecificProps(D._columnsDetails, U), DataCellEvents.blur(D, w2, O, x2);
    }
    static blurText(D, w2, O) {
      this._focusedElements.cellDropdown || _SelectCellTextBaseEvents.blurring(this, D, w2, O.target);
    }
    // prettier-ignore
    static setEvents(D, w2, O, x2) {
      w2.onblur = _SelectCellTextBaseEvents.blurText.bind(D, O, x2), w2.onfocus = CellWithTextEvents.focusText.bind(
        D,
        O,
        x2,
        _SelectCellTextBaseEvents.displayDropdown
      );
    }
  };
  var CellWithTextEvents = class _CellWithTextEvents {
    // prettier-ignore
    static focusText(D, w2, O, x2) {
      const U = x2.target, F = CellElement.getCellElement(U);
      DataCellEvents.prepareText(this, D, w2, U), O == null || O(this, w2, F), FocusedCellUtils.set(this._focusedElements.cell, F, D, w2), this._userKeyEventsState[KEYBOARD_KEY.TAB] && CaretPosition.setToEndOfText(this, U);
    }
    static programmaticBlur(D) {
      const { rowIndex: w2, columnIndex: O, element: x2 } = D._focusedElements.cell, U = CellElement.getTextElement(x2);
      U.blur(), D._focusedElements.cellDropdown && (SelectCellTextBaseEvents.blurring(D, w2, O, U), delete D._focusedElements.cellDropdown);
    }
    // prettier-ignore
    static mouseDownCell(D, w2, O, x2) {
      D._focusedElements.cellDropdown && _CellWithTextEvents.programmaticBlur(D);
      const U = CellElement.getTextElement(O);
      x2.preventDefault(), w2 == null || w2(D), CaretDisplayFix.isIssueBrowser() && U.focus(), CaretPosition.setToEndOfText(D, U);
    }
    static mouseDown(D, w2) {
      if (w2.target.classList.contains(CellElement.CELL_CLASS)) {
        const x2 = w2.target;
        _CellWithTextEvents.mouseDownCell(this, D, x2, w2);
      }
    }
  };
  var CellDropdownScrollbar = class {
    static setProperties(D) {
      const { element: w2, scrollbarPresence: O } = D;
      CellDropdownHorizontalScrollFix.setPropertiesIfHorizontalScrollPresent(D), O.vertical = ScrollbarUtils.isVerticalPresent(w2);
    }
  };
  var OptionDeleteButtonEvents = class _OptionDeleteButtonEvents {
    static delete(D, w2) {
      const { cellDropdown: O } = D, F = w2.target.parentElement.parentElement;
      delete O.itemsDetails[CellElement.getText(F.children[0])], F.remove(), Object.keys(O.itemsDetails).length === 0 ? CellWithTextEvents.programmaticBlur(this) : CellDropdownScrollbar.setProperties(O), setTimeout(() => FireEvents.onColumnsUpdate(this));
    }
    static addEvents(D, w2, O) {
      O.onclick = _OptionDeleteButtonEvents.delete.bind(D, w2);
    }
  };
  var _OptionDeleteButton = class Ge {
    static createIcon() {
      const D = document.createElement("div");
      return D.classList.add(Ge.DELETE_BUTTON_ICON_CLASS), D.innerText = Ge.DELETE_ICON_TEXT, D;
    }
    static createButton(D, w2) {
      const O = document.createElement("div");
      return O.classList.add(DropdownItem.DROPDOWN_ITEM_IDENTIFIER, OptionButton.BUTTON_CLASS), OptionDeleteButtonEvents.addEvents(D, w2, O), O;
    }
    static createContainer() {
      const D = document.createElement("div");
      return D.classList.add(OptionButton.BUTTON_CONTAINER_CLASS), D;
    }
    static create(D, w2) {
      const O = Ge.createContainer(), x2 = Ge.createButton(D, w2), U = Ge.createIcon();
      return x2.appendChild(U), O.appendChild(x2), O;
    }
    static changeVisibility(D, w2, O) {
      const x2 = D.children[1];
      if (x2.style.display = O ? "block" : "none", O) {
        const U = x2.children[0];
        U.style.left = `${O.offsetWidth - w2}px`;
      }
    }
  };
  _OptionDeleteButton.DELETE_BUTTON_ICON_CLASS = "cell-dropdown-option-delete-button-icon";
  _OptionDeleteButton.DELETE_ICON_TEXT = "\xD7";
  var OptionDeleteButton = _OptionDeleteButton;
  var OptionButton = class {
    static changeVisibility(D, w2, O) {
      if (D.isTrusted) {
        const x2 = D.target, U = w2.scrollbarPresence.vertical ? 31 : 16;
        OptionDeleteButton.changeVisibility(x2, U, O), Browser.IS_COLOR_PICKER_SUPPORTED && w2.labelDetails && !w2.labelDetails.colorPickerContainer && OptionColorButton.changeVisibility(x2, U + 18, O);
      }
    }
    // prettier-ignore
    static hideAfterColorPickerContainerClose(D, w2) {
      const { cellDropdown: { labelDetails: O } } = w2;
      if (O != null && O.colorPickerContainer) {
        O.colorPickerContainer.style.display = "none";
        const x2 = O.colorPickerContainer.previousElementSibling;
        x2.style.display = "none", delete O.colorPickerContainer, OptionColorButtonEvents.updateColumnLabelColors(D, w2);
      }
    }
  };
  OptionButton.BUTTON_CONTAINER_CLASS = "cell-dropdown-option-button-container";
  OptionButton.BUTTON_CLASS = "cell-dropdown-option-button";
  var CellDropdownItemEvents = class _CellDropdownItemEvents {
    // prettier-ignore
    static blurItem(D, w2, O) {
      var W;
      const { activeItems: x2, labelDetails: U } = D;
      if (U != null && U.colorPickerContainer)
        return;
      const F = x2[w2];
      F !== void 0 && (w2 === "matchingWithCellText" || w2 === "hovered" && F !== x2.matchingWithCellText) && (F.style.backgroundColor = "", U || (F.style.color = ((W = D.customItemStyle) == null ? void 0 : W.textColor) || ""), delete x2[w2]), O && D.canAddMoreOptions && OptionButton.changeVisibility(O, D);
    }
    // prettier-ignore
    static scrollToItem(D, w2, O, x2, U) {
      if (U.isTrusted)
        return;
      const F = ElementVisibility.isVerticallyVisibleInsideParent(w2, D);
      F.isFullyVisible || (w2.scrollIntoView({ block: "nearest" }), O && F.blockingSides.has(SIDE.BOTTOM) && CellDropdownHorizontalScrollFix.scrollDownFurther(x2));
    }
    static highlightItem(D, w2) {
      const { scrollbarPresence: O, activeItems: x2, labelDetails: U, canAddMoreOptions: F, element: W, itemsDetails: G } = D;
      if (U != null && U.colorPickerContainer)
        return;
      x2.hovered && (x2.hovered.style.backgroundColor = "", U || (x2.hovered.style.color = ""));
      const X = w2.target, K = X.children[0].innerText;
      X.style.backgroundColor = G[K].backgroundColor;
      const q = X.parentElement;
      _CellDropdownItemEvents.scrollToItem(this, X, O.horizontal, q, w2), X === x2.matchingWithCellText ? (U || (X.style.color = "white"), delete x2.hovered) : (U || (X.style.backgroundColor = DropdownItemHighlightUtils.HOVER_BACKGROUND_COLOR), x2.hovered = X), F && OptionButton.changeVisibility(w2, D, W);
    }
    static set(D, w2, O) {
      w2.onmouseenter = _CellDropdownItemEvents.highlightItem.bind(D, O), w2.onmouseleave = _CellDropdownItemEvents.blurItem.bind(this, O, "hovered");
    }
  };
  var _CellDropdownItem = class ae {
    // prettier-ignore
    static updateCellElementIfNotUpdated(D, w2, O, x2, U) {
      D.data[O][x2] !== w2 && CellEvents.updateCell(D, w2, O, x2, { processText: false, element: U });
    }
    // prettier-ignore
    static selectExistingItem(D, w2, O, x2, U) {
      var W;
      const F = CellElement.getText(w2.children[0]);
      ae.updateCellElementIfNotUpdated(D, F, O, x2, U), LabelCellTextElement.isLabelText(U) && (U.style.backgroundColor = (W = D._columnsDetails[x2].cellDropdown.itemsDetails[F]) == null ? void 0 : W.backgroundColor);
    }
    // prettier-ignore
    static addNewItem(D, w2, O, x2) {
      const { cellDropdown: { labelDetails: U } } = O, F = CellElement.getText(w2);
      if (F === EMPTY_STRING)
        return;
      let W = "";
      if (U) {
        const { globalItemColors: { newColors: G, existingColors: X } } = U;
        W = x2 || X[F] || G[G.length - 1] || LabelColorUtils.getLatestPasteleColor(), w2.style.backgroundColor = W, X[F] ?? (X[F] = W), G.pop() || LabelColorUtils.setNewLatestPasteleColor();
      } else
        W = ae.ACTIVE_ITEM_BACKGROUND_COLOR;
      ae.addItem(D, F, W, O), setTimeout(() => FireEvents.onColumnsUpdate(D));
    }
    // prettier-ignore
    static updateCellTextBgColor(D, w2, O, x2) {
      const U = CellElement.getText(w2);
      if (D)
        w2.style.backgroundColor = O.itemsDetails[U].backgroundColor;
      else if (!O.canAddMoreOptions || U === EMPTY_STRING || U === x2)
        w2.style.backgroundColor = "";
      else if (O.labelDetails) {
        const { globalItemColors: { newColors: F, existingColors: W } } = O.labelDetails;
        w2.style.backgroundColor = W[U] || (F == null ? void 0 : F[F.length - 1]) || LabelColorUtils.getLatestPasteleColor();
      }
    }
    static updateItemColor(D, w2) {
      D && (w2.matchingWithCellText = D, D.dispatchEvent(new MouseEvent("mouseenter")));
    }
    static hideHoveredItemHighlight(D) {
      const { hovered: w2, matchingWithCellText: O } = D;
      w2 ? w2.style.backgroundColor = "" : D.hovered = O;
    }
    // prettier-ignore
    static attemptHighlightMatchingItemWithCell(D, w2, O, x2, U) {
      var K;
      const { activeItems: F, itemsDetails: W } = w2, G = CellElement.getText(D), X = U || ((K = W[G]) == null ? void 0 : K.element);
      (!X || F.matchingWithCellText !== X) && (ae.hideHoveredItemHighlight(F), CellDropdownItemEvents.blurItem(w2, "matchingWithCellText")), ae.updateItemColor(X, F), x2 && w2.labelDetails && ae.updateCellTextBgColor(X, D, w2, O);
    }
    // prettier-ignore
    static setItemOnCell(D, w2) {
      const { element: O, rowIndex: x2, columnIndex: U } = D._focusedElements.cell, { cellDropdown: F, settings: { defaultText: W } } = D._columnsDetails[U], G = O.children[0], X = CellElement.getText(w2.children[0]);
      ae.updateCellElementIfNotUpdated(D, X, x2, U, G), ae.attemptHighlightMatchingItemWithCell(G, F, W, true, w2), CaretPosition.setToEndOfText(D, G);
    }
    // prettier-ignore
    static setSiblingItemOnCell(D, w2, O) {
      const { hovered: x2, matchingWithCellText: U } = w2, F = x2 || U, W = F == null ? void 0 : F[O];
      if (W)
        ae.setItemOnCell(D, W);
      else {
        const { columnIndex: G } = D._focusedElements.cell, X = D._columnsDetails[G].cellDropdown.element;
        if (O === "nextSibling") {
          const K = X.children[0];
          K && ae.setItemOnCell(D, K);
        } else {
          const K = X.children[X.children.length - 1];
          K && ae.setItemOnCell(D, K);
        }
      }
    }
    static addItemElement(D, w2, O, x2 = false) {
      const { cellDropdown: U } = O, F = DropdownItem.addPlaneButtonItem(U.element, w2, x2 ? 0 : void 0);
      if (U.customItemStyle && (F.style.color = U.customItemStyle.textColor), U.canAddMoreOptions) {
        const W = OptionDeleteButton.create(D, O);
        if (F.appendChild(W), Browser.IS_COLOR_PICKER_SUPPORTED && U.labelDetails) {
          const G = OptionColorButton.create(D._columnsDetails, O);
          F.appendChild(G);
        }
      }
      return CellDropdownItemEvents.set(D.shadowRoot, F, U), F;
    }
    static addItem(D, w2, O, x2, U = false) {
      x2.cellDropdown.itemsDetails[w2] = {
        backgroundColor: O,
        isCustomBackgroundColor: U,
        element: ae.addItemElement(D, w2, x2)
      };
    }
    static addItems(D, w2, O) {
      O.cellDropdown.element.replaceChildren(), O.cellDropdown.itemsDetails = {}, Object.keys(w2).forEach((x2) => {
        ae.addItem(D, x2, w2[x2].color, O, !!w2[x2].isCustom);
      });
    }
    static postProcessItemToColor(D, w2, O) {
      D && delete w2[O];
    }
    // prettier-ignore
    static processNewItemsToColor(D, w2, O, x2) {
      D.slice(1).reduce((U, F) => {
        const W = F[w2];
        if (W !== EMPTY_STRING && !U[W])
          if (x2) {
            const { globalItemColors: { newColors: G, existingColors: X } } = x2;
            U[W] = { color: X[W] || G.pop() || LabelColorUtils.getLatestPasteleColorAndSetNew() }, X[W] ?? (X[W] = U[W].color);
          } else
            U[W] = { color: ae.ACTIVE_ITEM_BACKGROUND_COLOR };
        return U;
      }, O);
    }
    // prettier-ignore
    static changeUserOptionsToItemToColor(D, w2) {
      return D.reduce((O, x2) => {
        var U;
        if (w2) {
          const { globalItemColors: { newColors: F, existingColors: W } } = w2;
          O[x2.text] = { color: x2.backgroundColor || W[x2.text] || F.pop() || LabelColorUtils.getLatestPasteleColorAndSetNew(), isCustom: true }, W[U = x2.text] ?? (W[U] = O[x2.text].color);
        } else
          O[x2.text] = { color: ae.ACTIVE_ITEM_BACKGROUND_COLOR, isCustom: true };
        return O;
      }, {});
    }
    // prettier-ignore
    static populateItems(D, w2) {
      const { data: O, _columnsDetails: x2 } = D, U = x2[w2], {
        cellDropdown: { labelDetails: F },
        settings: { defaultText: W, isDefaultTextRemovable: G },
        activeType: { cellDropdownProps: X }
      } = U;
      if (!X)
        return;
      let K = {};
      X.options && (K = ae.changeUserOptionsToItemToColor(X.options, F)), X.canAddMoreOptions && ae.processNewItemsToColor(O, w2, K, F), ae.postProcessItemToColor(G, K, W), ae.addItems(D, K, U);
    }
  };
  _CellDropdownItem.ACTIVE_ITEM_BACKGROUND_COLOR = "#4a69d4";
  var CellDropdownItem = _CellDropdownItem;
  var _LabelCellTextElement = class ct {
    static isLabelText(D) {
      return D.classList.contains(ct.TEXT_CLASS);
    }
    static setCellTextAsAnElement(D, w2, O) {
      const x2 = CellTextElement.setCellTextAsAnElement(D, O);
      x2.classList.add(ct.TEXT_CLASS), x2.style.backgroundColor = w2;
    }
    // prettier-ignore
    static finaliseEditedText(D, w2, O, x2 = false) {
      var q;
      const U = D._columnsDetails[O], { cellDropdown: F, activeType: { cellDropdownProps: W }, settings: { defaultText: G, isDefaultTextRemovable: X } } = U, K = (q = F.itemsDetails[CellElement.getText(w2)]) == null ? void 0 : q.backgroundColor;
      CellElement.getText(w2) === EMPTY_STRING || X && CellElement.getText(w2) === G ? w2.style.backgroundColor = "" : x2 && K ? w2.style.backgroundColor = K : W != null && W.canAddMoreOptions && CellDropdownItem.addNewItem(D, w2, U, w2.style.backgroundColor);
    }
  };
  _LabelCellTextElement.TEXT_CLASS = "label-cell-text";
  var LabelCellTextElement = _LabelCellTextElement;
  var CellDropdownEvents = class _CellDropdownEvents {
    // instead of binding click event handlers with the context of current row index to individual item elements every
    // time the dropdown is displayed, click events are handled on the dropdown instead, the reason for this is
    // because it can be expensive to rebind an arbitrary amount of items e.g. 10000+
    // prettier-ignore
    static click(D) {
      const w2 = D.target;
      if (w2.classList.contains(Dropdown.DROPDOWN_CLASS) || w2.classList.contains(OptionButton.BUTTON_CLASS))
        return;
      const { rowIndex: O, columnIndex: x2, element: U } = this._focusedElements.cell, F = w2.classList.contains(DropdownItem.DROPDOWN_ITEM_CLASS) ? w2 : w2.parentElement;
      CellDropdownItem.selectExistingItem(
        this,
        F,
        O,
        x2,
        U.children[0]
      ), CellWithTextEvents.programmaticBlur(this);
    }
    // this is required to record to stop cell blur from closing the dropdown
    // additionally if the user clicks on dropdown scroll or padding, this will record it
    static mouseDown(D, w2) {
      D.cellDropdown = w2;
    }
    static set(D, w2) {
      w2.onmousedown = _CellDropdownEvents.mouseDown.bind(this, D._focusedElements, w2), w2.onclick = _CellDropdownEvents.click.bind(D);
    }
  };
  var _CellDropdown2 = class ce {
    static generateRightPosition() {
      return "4px";
    }
    // prettier-ignore
    static generateBottomPosition(D, w2, O) {
      const x2 = D.offsetParent, U = O.bottomWidth + O.topWidth;
      return `${x2.offsetHeight - U - D.offsetTop - w2.offsetTop + 6}px`;
    }
    // prettier-ignore
    static generateTopPosition(D, w2, O) {
      const x2 = LabelCellTextElement.isLabelText(w2) ? w2.offsetTop + w2.offsetHeight + 2 : D.offsetHeight - 8;
      return `${ElementOffset.processTop(D.offsetTop + x2, O)}px`;
    }
    // prettier-ignore
    static generateLeftPosition(D, w2, O) {
      const x2 = LabelCellTextElement.isLabelText(w2) ? w2.offsetLeft : 1;
      return `${ElementOffset.processLeft(D.offsetLeft + x2, O)}px`;
    }
    // prettier-ignore
    static correctPosition(D, w2, O, x2) {
      const U = ElementVisibility.getDetailsInWindow(D, x2);
      U.isFullyVisible || (U.blockingSides.has(SIDE.RIGHT) && (D.style.left = "", D.style.right = ce.generateRightPosition()), U.blockingSides.has(SIDE.BOTTOM) && (D.style.top = "", D.style.bottom = ce.generateBottomPosition(
        w2,
        O,
        x2
      )));
    }
    // prettier-ignore
    static correctPositionForOverflow(D, w2, O) {
      w2.offsetHeight !== O.scrollHeight && (D.style.top = `${w2.offsetHeight - D.offsetHeight}px`), w2.offsetWidth !== O.scrollWidth && (D.style.left = `${w2.offsetWidth - D.offsetWidth}px`);
    }
    static setPosition(D, w2, O) {
      const x2 = w2.children[0];
      D.style.bottom = "", D.style.right = "", D.style.left = ce.generateLeftPosition(w2, x2, O), D.style.top = ce.generateTopPosition(w2, x2, O);
      const U = D.parentElement.parentElement, F = U.parentElement;
      OverflowUtils.isOverflowElement(F) ? ce.correctPositionForOverflow(D, U, F) : ce.correctPosition(D, w2, x2, O);
    }
    // prettier-ignore
    static updateCellDropdown(D, w2, O, x2, U, F) {
      const W = CellElement.getTextElement(D);
      CellDropdownItem.attemptHighlightMatchingItemWithCell(
        W,
        w2,
        x2,
        U,
        F
      ), U && ce.setPosition(w2.element, W.parentElement, O);
    }
    static focusItemOnDropdownOpen(D, w2, O) {
      CellDropdownItem.attemptHighlightMatchingItemWithCell(D, w2, O, false);
    }
    // prettier-ignore
    static correctWidthForOverflow(D) {
      if (D.clientWidth !== D.scrollWidth) {
        const w2 = D.clientHeight !== D.scrollHeight ? 16 : 0, O = D.scrollWidth + w2;
        D.style.width = `${Math.min(O, ce.MAX_WIDTH)}px`;
      }
      D.children.length > 0 && D.scrollWidth < D.children[0].getBoundingClientRect().width && (D.style.width = `${D.clientWidth + 1}px`);
    }
    static getWidth(D, w2, O) {
      if (O != null && O.width)
        return Number.parseInt(O.width);
      if (!w2.labelDetails)
        return Math.max(D.offsetWidth - 2, ce.MIN_WIDTH);
      const x2 = D.children[0];
      return Math.max(D.offsetWidth - x2.offsetLeft * 2, ce.MIN_WIDTH);
    }
    // prettier-ignore
    static display(D, w2, O) {
      const { cellDropdown: x2, settings: { defaultText: U }, activeType: { cellDropdownProps: F } } = D._columnsDetails[w2], { element: W, itemsDetails: G } = x2;
      if (Object.keys(G).length > 0 && F) {
        CellDropdownEvents.set(D, W), CellDropdownItemEvents.blurItem(x2, "hovered"), CellDropdownItemEvents.blurItem(x2, "matchingWithCellText"), W.style.width = `${ce.getWidth(O, x2, F.dropdownStyle)}px`, Dropdown.display(W), W.scrollLeft = 0, ce.correctWidthForOverflow(W), CellDropdownScrollbar.setProperties(x2), ce.setPosition(W, O, D._tableDimensions.border);
        const X = O.children[0];
        return ce.focusItemOnDropdownOpen(X, x2, U), true;
      }
      return false;
    }
    static setCustomStyle(D, w2) {
      const { paddingTop: O, paddingBottom: x2, marginTop: U, marginLeft: F, border: W, textAlign: G } = w2;
      D.element.style.paddingTop = O || Dropdown.DROPDOWN_VERTICAL_PX, D.element.style.paddingBottom = x2 || Dropdown.DROPDOWN_VERTICAL_PX, D.element.style.marginTop = U || "0px", D.element.style.marginLeft = F || "0px", D.element.style.border = W || "none", D.element.style.textAlign = G || "left";
    }
    static setCustomState(D, w2) {
      D.customDropdownStyle = w2.dropdownStyle, D.customItemStyle = w2.optionStyle, D.canAddMoreOptions = !!w2.canAddMoreOptions;
    }
    // prettier-ignore
    static setUpDropdown(D, w2) {
      const { _columnsDetails: O, _globalItemColors: x2 } = D, { activeType: { cellDropdownProps: U }, cellDropdown: F } = O[w2];
      U && (F.labelDetails = U.isBasicSelect ? void 0 : { globalItemColors: x2 }, ce.setCustomState(F, U), CellDropdownItem.populateItems(D, w2), U.dropdownStyle && ce.setCustomStyle(F, U.dropdownStyle));
    }
    // REF-8 - Created for every column
    static createAndAppend(D) {
      const w2 = Dropdown.createBase();
      return w2.style.maxHeight = ce.MAX_HEIGHT_PX, w2.classList.add(ce.CELL_DROPDOWN_CLASS), D.appendChild(w2), w2;
    }
    static getDefaultObj(D) {
      return {
        itemsDetails: {},
        activeItems: {},
        element: D,
        canAddMoreOptions: true,
        scrollbarPresence: {
          horizontal: false,
          vertical: false
        }
      };
    }
    static createContainerElement() {
      return document.createElement("div");
    }
  };
  _CellDropdown2.CELL_DROPDOWN_CLASS = "cell-dropdown";
  _CellDropdown2.MAX_HEIGHT_PX = "147px";
  _CellDropdown2.MIN_WIDTH = 70;
  _CellDropdown2.MAX_WIDTH = 200;
  var CellDropdown = _CellDropdown2;
  var _ColumnDetails = class Fe {
    // prettier-ignore
    static getHeaderDefaultColor(D, w2, O, x2) {
      var U, F, W, G, X, K;
      return ((F = (U = x2 == null ? void 0 : x2.headerStyles) == null ? void 0 : U.default) == null ? void 0 : F[w2]) || ((W = x2 == null ? void 0 : x2.cellStyle) == null ? void 0 : W[w2]) || ((X = (G = D.headerStyles) == null ? void 0 : G.default) == null ? void 0 : X[w2]) || ((K = D.cellStyle) == null ? void 0 : K[w2]) || O;
    }
    // prettier-ignore
    static getHeaderHoverColor(D, w2, O, x2) {
      var U, F, W, G;
      return ((F = (U = x2 == null ? void 0 : x2.headerStyles) == null ? void 0 : U.hoverColors) == null ? void 0 : F[w2]) || ((G = (W = D.headerStyles) == null ? void 0 : W.hoverColors) == null ? void 0 : G[w2]) || Fe.getHeaderDefaultColor(D, w2, O, x2);
    }
    // settings variable is a variable attached to columnDetails and can be either default or custom
    // prettier-ignore
    static createHeaderStateColors(D, w2, O) {
      return {
        hover: {
          color: Fe.getHeaderHoverColor(D, "color", O.color, w2),
          backgroundColor: Fe.getHeaderHoverColor(
            D,
            "backgroundColor",
            O.backgroundColor,
            w2
          )
        },
        default: {
          color: Fe.getHeaderDefaultColor(D, "color", "", w2),
          backgroundColor: Fe.getHeaderDefaultColor(D, "backgroundColor", "", w2)
        }
      };
    }
    // prettier-ignore
    static createInitial(D, w2, O, x2, U) {
      const F = O || D;
      return {
        elements: [],
        processedStyle: [],
        settings: F,
        headerStateColors: Fe.createHeaderStateColors(D, O, x2),
        bordersOverwrittenBySiblings: {},
        activeType: ColumnTypesUtils.getActiveType(F),
        cellDropdown: CellDropdown.getDefaultObj(w2),
        fireColumnsUpdate: U
      };
    }
    // prettier-ignore
    static updateWithNoSizer(D, w2) {
      return Object.assign(D, { columnDropdownCellOverlay: w2 }), D;
    }
  };
  _ColumnDetails.MINIMAL_COLUMN_WIDTH = 34;
  var ColumnDetails = _ColumnDetails;
  var MaximumColumns = class _MaximumColumns {
    // the motivation behind minimal column length came from the fact that when we have set a table width and all the columns
    // have become too narrow (24px), upon adding any subsequent columns - the set table width would be ignored and the table
    // would expand - as an infinite amount of columns can't just be added to a table width a preset width
    // the actual minimal column length is usually not reached as dividing table width by its columns rarely produces it
    // originally this was set to 28, however the extra padding on the left column causes the table width to overflow
    // the set limit hence it is set to 34 instead
    // REF-24
    // this is a small effort to toggle off the add new column button when columns with set widths breach the table
    static isStaticContentBreachingSetTableWidth(D, w2) {
      if (w2)
        return false;
      const O = D.width || D.maxWidth;
      return O !== void 0 && D.staticWidth > O;
    }
    // prettier-ignore
    static ignoreMinimalColumnWidthCheck(D, w2, O) {
      return D.preserveNarrowColumns || !StaticTable.isStaticTableWidth(w2, D) || O === 0;
    }
    // prettier-ignore
    static canAddMore(D) {
      const { _tableElementRef: w2, _columnsDetails: O, _tableDimensions: x2, maxColumns: U, preserveNarrowColumns: F } = D, W = O.length;
      if (U !== void 0 && U > 0 && U === W || _MaximumColumns.isStaticContentBreachingSetTableWidth(x2, F))
        return false;
      const G = w2;
      return _MaximumColumns.ignoreMinimalColumnWidthCheck(x2, G, W) ? true : (G.offsetWidth - x2.staticWidth) / (W + 1) >= ColumnDetails.MINIMAL_COLUMN_WIDTH;
    }
  };
  var _AddNewColumnEvents = class We {
    static setHeaderCellStyle(D, w2, O) {
      const { default: x2, hover: U } = w2;
      D.style.color = O ? U.color : x2.color, D.style.backgroundColor = O ? U.backgroundColor : x2.backgroundColor;
    }
    static setDataCellStyle(D, w2) {
      setTimeout(() => {
        D.forEach((O) => {
          O.style.backgroundColor = w2;
        });
      });
    }
    // prettier-ignore
    static setDataCellsStyle(D, w2, O) {
      const x2 = D ? O.hover.backgroundColor : O.default.backgroundColor, U = w2.slice(1), F = Math.ceil(U.length / We.NUMBER_OF_HIGHLIGHT_CHUNKS);
      for (let W = 0; W < U.length; W += F) {
        const G = U.slice(W, W + F);
        We.setDataCellStyle(G, x2);
      }
    }
    // prettier-ignore
    static toggleColor(D, w2, O) {
      const { data: x2, header: U } = O, F = w2[0];
      F && We.setHeaderCellStyle(F, U, D), w2.length > 1 && We.setDataCellsStyle(D, w2, x2);
    }
    // prettier-ignore
    static setEvents(D, w2) {
      const { _addColumnCellsElementsRef: O, _frameComponents: { cellColors: x2 } } = D;
      w2.onmouseenter = We.toggleColor.bind(this, true, O, x2), w2.onmouseleave = We.toggleColor.bind(this, false, O, x2), w2.onclick = InsertNewColumn.insertEvent.bind(D);
    }
  };
  _AddNewColumnEvents.NUMBER_OF_HIGHLIGHT_CHUNKS = 3;
  var AddNewColumnEvents = _AddNewColumnEvents;
  var _AddNewColumnElement = class pe {
    // the toggling of the add new column element is not a simple display style change because the following selector:
    // .row > .cell:last-of-type which is responsible for not adding a right-border for the rightmost cell can only
    // detect the last .cell element, so when this button is displayed we want the selector to recognise it and
    // not display a border on the right and not affect the css of the cell before it. When it is not displayed,
    // we want the previous cell to be recognised by the selector. Unfortunately this is not possible as even
    // renaming the class names on this button does not re-trigger selector to identify the previous cell as last.
    // The only way to do this is to remove the cell element when not visible, which is what the code below is doing
    // and re-adding the cell when it is visible. (The cell still remains in the addColumnCellsElementsRef object).
    static setDisplay(D, w2, O, x2) {
      w2 ? O.children[x2].appendChild(D) : D.remove();
    }
    static createCell(D, w2) {
      var x2;
      const O = CellElement.createBaseCell(w2);
      return O.classList.add(
        CellElement.CELL_CLASS,
        GenericElementUtils.NOT_SELECTABLE_CLASS,
        pe.ADD_COLUMN_CELL_CLASS
      ), Object.assign(O.style, D._defaultColumnsSettings.cellStyle, (x2 = D._frameComponents.styles) == null ? void 0 : x2.default), AddNewColumnEvents.setEvents(D, O), O;
    }
    // prettier-ignore
    static createHeaderCell(D) {
      const { _defaultColumnsSettings: { headerStyles: w2 }, _frameComponents: { cellColors: O, inheritHeaderColors: x2 } } = D, U = pe.createCell(D, true);
      return U.style.width = pe.DEFAULT_WIDTH_PX, U.innerText = "+", Object.assign(U.style, x2 ? w2 == null ? void 0 : w2.default : {}, O.header.default), U;
    }
    static createDataCell(D) {
      const w2 = pe.createCell(D, false);
      return Object.assign(w2.style, D._frameComponents.cellColors.data.default), w2;
    }
    static isDisplayed(D) {
      return GenericElementUtils.doesElementExistInDom(D[0]);
    }
    static createAndAppendToRow(D, w2, O) {
      const { _addColumnCellsElementsRef: x2, _columnsDetails: U } = D, F = x2.length === 0 || pe.isDisplayed(x2), W = O === 0 ? pe.createHeaderCell(D) : pe.createDataCell(D);
      x2.splice(O, 0, W);
      const G = U[U.length - 1];
      ColumnSettingsBorderUtils.unsetSubjectBorder(x2, G.elements, "left", O), F && (MaximumColumns.canAddMore(D) ? w2.appendChild(W) : O === 0 && TableElement.changeStaticWidthTotal(D._tableDimensions, -pe.DEFAULT_WIDTH));
    }
    // prettier-ignore
    static toggleEachCell(D, w2, O, x2) {
      O.forEach((U, F) => {
        pe.setDisplay(U, D, w2, F);
      }), D || setTimeout(() => AddNewColumnEvents.toggleColor(false, O, x2));
    }
    static changeTableWidths(D, w2, O) {
      const x2 = w2 ? pe.DEFAULT_WIDTH : -pe.DEFAULT_WIDTH;
      TableElement.changeStaticWidthTotal(D._tableDimensions, x2), StaticTableWidthUtils.changeWidthsBasedOnColumnInsertRemove(D, O);
    }
    // prettier-ignore
    static toggle(D, w2) {
      const {
        _addColumnCellsElementsRef: O,
        _tableBodyElementRef: x2,
        _frameComponents: { displayAddNewColumn: U, cellColors: F }
      } = D;
      if (!U || !x2)
        return;
      const W = MaximumColumns.canAddMore(D);
      W !== pe.isDisplayed(O) && (W ? (pe.toggleEachCell(W, x2, O, F), pe.changeTableWidths(D, W, w2)) : (pe.changeTableWidths(D, W, w2), pe.toggleEachCell(W, x2, O, F)));
    }
  };
  _AddNewColumnElement.ADD_COLUMN_CELL_CLASS = "add-column-cell";
  _AddNewColumnElement.DEFAULT_WIDTH = 25;
  _AddNewColumnElement.DEFAULT_WIDTH_PX = `${_AddNewColumnElement.DEFAULT_WIDTH}px`;
  var AddNewColumnElement = _AddNewColumnElement;
  var ExtractElements = class {
    static textCellsArrFromRow(D) {
      return Array.from(D.children).filter(
        (w2) => (w2.tagName === CellElement.HEADER_TAG || w2.tagName === CellElement.DATA_TAG) && !w2.classList.contains(AddNewColumnElement.ADD_COLUMN_CELL_CLASS) && !w2.classList.contains(IndexColumn.INDEX_CELL_CLASS)
      );
    }
    static textRowsArrFromTBody(D, w2, O = 0) {
      return Array.from(D.children).slice(O, w2.length);
    }
    static getRightColumnSiblingCell(D) {
      var w2;
      return (w2 = D.nextSibling) == null ? void 0 : w2.nextSibling;
    }
  };
  var ColumnSettingsFrameBorderUtils = class _ColumnSettingsFrameBorderUtils {
    // prettier-ignore
    static toggleFrameBorder(D, w2, O, x2) {
      if (D.length > 0) {
        const { subjectBorderStyle: U, siblingBorderStyle: F } = ColumnSettingsBorderUtils.getColumnBorderStyles(O), W = D[0], G = w2[0];
        ColumnSettingsBorderUtils.isBorderDisplayed(G, F) ? ColumnSettingsBorderUtils.unsetSubjectBorder(D, w2, O, 0) : W.style[U] === ColumnSettingsBorderUtils.UNSET_PX && ResetColumnStyles.applyDefaultStyles(D, x2);
      }
    }
    // prettier-ignore
    static updateFrameColumns(D, w2, O, x2) {
      const U = w2 || O;
      if (!U)
        return;
      const {
        _defaultColumnsSettings: F,
        _addColumnCellsElementsRef: W,
        _frameComponents: { displayAddNewColumn: G, displayIndexColumn: X }
      } = D;
      if (!x2 && G && _ColumnSettingsFrameBorderUtils.toggleFrameBorder(
        W,
        U.elements,
        "left",
        F
      ), !O && X) {
        const q = ExtractElements.textRowsArrFromTBody(D._tableBodyElementRef, D.data, 0).map((Q) => Q.children[0]);
        _ColumnSettingsFrameBorderUtils.toggleFrameBorder(q, U.elements, "right", F);
      }
    }
  };
  var _ColumnSettingsBorderUtils = class de {
    // REF-23
    static overwriteSideBorderIfSiblingsHaveSettings(D, w2) {
      const { left: O, right: x2 } = D.bordersOverwrittenBySiblings;
      w2.forEach((U) => {
        O && (U.style.borderLeftWidth = de.UNSET_PX), x2 && (U.style.borderRightWidth = de.UNSET_PX);
      });
    }
    // prettier-ignore
    static getColumnBorderStyles(D) {
      return { subjectBorderStyle: D === "left" ? "borderLeftWidth" : "borderRightWidth", siblingBorderStyle: D === "left" ? "borderRightWidth" : "borderLeftWidth" };
    }
    static isBorderDisplayed(D, w2) {
      return !!(D.style[w2] && D.style[w2] !== de.UNSET_PX);
    }
    // REF-23
    // prettier-ignore
    static unsetSubjectBorder(D, w2, O, x2, U) {
      const { subjectBorderStyle: F, siblingBorderStyle: W } = de.getColumnBorderStyles(O), G = D[x2], X = w2[x2];
      de.isBorderDisplayed(G, F) && de.isBorderDisplayed(X, W) && (U && (U[O] = true), D.forEach((K) => {
        ElementStyle.setStyle(K, F, de.UNSET_PX);
      }));
    }
    // prettier-ignore
    static unsetColumnBorder(D, w2, O) {
      de.unsetSubjectBorder(
        D.elements,
        w2.elements,
        O,
        0,
        D.bordersOverwrittenBySiblings
      );
    }
    // if current column and sibling have custom setting styles
    // REF-23
    // prettier-ignore
    static unsetBorders(D, w2, O) {
      D && (D.settings.stylePrecedence ? (w2 && de.unsetColumnBorder(w2, D, "right"), O && (O.settings.stylePrecedence ? de.unsetColumnBorder(D, O, "right") : O.settings.stylePrecedence || de.unsetColumnBorder(O, D, "left"))) : (O && O.settings.stylePrecedence && de.unsetColumnBorder(D, O, "right"), w2 && w2.settings.stylePrecedence && de.unsetColumnBorder(D, w2, "left")));
    }
    static resetBorderOverwritingState(D) {
      D && (D.bordersOverwrittenBySiblings.left = false, D.bordersOverwrittenBySiblings.right = false);
    }
    // prettier-ignore
    static resetIfBorderOverwritten(D, w2, O, x2) {
      O != null && O.bordersOverwrittenBySiblings[x2] && (O.bordersOverwrittenBySiblings[x2] = false, ColumnSettingsStyleUtils.changeStyleFunc(D, w2, D._columnsDetails[w2].settings));
    }
    // REF-23
    static updateSiblingColumns(D, w2) {
      const { _columnsDetails: O } = D, x2 = O[w2], U = O[w2 - 1], F = O[w2 + 1];
      de.resetIfBorderOverwritten(D, w2 + 1, F, "left"), de.resetIfBorderOverwritten(D, w2 - 1, U, "right"), de.resetBorderOverwritingState(x2), de.unsetBorders(x2, U, F), ColumnSettingsFrameBorderUtils.updateFrameColumns(D, x2, U, F);
    }
  };
  _ColumnSettingsBorderUtils.UNSET_PX = "0px";
  var ColumnSettingsBorderUtils = _ColumnSettingsBorderUtils;
  var _CellElement = class Ee {
    // prettier-ignore
    static setDefaultCellStyle(D, w2, O) {
      Object.assign(D.style, w2, O);
    }
    static createBaseCell(D) {
      const w2 = document.createElement(D ? Ee.HEADER_TAG : Ee.DATA_TAG);
      return D && w2.classList.add(Ee.HEADER_CELL_CLASS), w2.classList.add(Ee.CELL_CLASS), w2;
    }
    // prettier-ignore
    static createDataCell(D, w2, O, x2) {
      const U = Ee.createBaseCell(D);
      return D && x2 && U.classList.add(GenericElementUtils.NOT_SELECTABLE_CLASS), U.setAttribute("role", "textbox"), Ee.setDefaultCellStyle(U, w2, O), U;
    }
    static setCursor(D, w2) {
      D.style.cursor = w2 ? "text" : "default";
    }
    static prepContentEditable(D, w2, O = false) {
      CaretDisplayFix.isIssueBrowser() ? (w2 && CaretDisplayFix.setTabIndex(D), CaretDisplayFix.removeContentEditable(D)) : D.contentEditable = String(w2), O || Ee.setCursor(D, w2);
    }
    // prettier-ignore
    // this is used for cases where element could be the cell element or the text inside a select/label cell
    static getCellElement(D) {
      return D.classList.contains(CellTextElement.CELL_TEXT_DIV_CLASS) || D.classList.contains(DateCellInputElement.DATE_INPUT_CONTAINER_CLASS) ? D.parentElement : D.classList.contains(DateCellInputElement.DATE_INPUT_CLASS) || D.classList.contains(DateCellCalendarIconElement.CALENDAR_ICON_CONTAINER_CLASS) ? D.parentElement.parentElement : D;
    }
    static getTextElement(D) {
      var w2, O;
      return (w2 = D.children[0]) != null && w2.classList.contains(CellTextElement.CELL_TEXT_DIV_CLASS) ? D.children[0] : (O = D.children[1]) != null && O.classList.contains(CellTextElement.CELL_TEXT_DIV_CLASS) ? D.children[1] : CheckboxCellElement.isCheckboxCell(D) ? D.children[0] : D;
    }
    // The reason why .trim() is used is because innerText/textContent property does not just return the cell text, but
    // additionally the new line characters (\n) which represent <br> elements within the cell that make it difficult
    // to compare cell text to other strings or use them for other programmatic purposes.
    // CAUTION-1 - The returned string should not be used to set text on other cells as .trim() removes \n chars for
    // <br> tags which are used to set the pointer position.
    static getText(D) {
      const w2 = CheckboxCellElement.getValue(D);
      return w2 !== void 0 ? w2 : D.innerText.trim();
    }
    // this is used for case where element could be cell element that contains a text div element,
    // hence we need to set the text into the correct container
    // CAUTION-1 - be careful that the text does not come from above method
    static setText(D, w2) {
      if (!CheckboxCellElement.setValue(D, w2)) {
        const O = Ee.getTextElement(D);
        O.innerText = w2;
      }
    }
    // set text is optional as some elements may only need to toggle the BR padding
    // prettier-ignore
    static setNewText(D, w2, O, x2, U, F = true) {
      F && Ee.setText(w2, O), x2 ? setTimeout(() => CaretDisplayFix.toggleCellTextBRPadding(D, w2, U)) : CaretDisplayFix.toggleCellTextBRPadding(D, w2, U);
    }
    // REF-36
    static setColumnWidth(D, w2, O, x2) {
      if (!D._tableElementRef)
        return;
      const U = (O == null ? void 0 : O.widths) || (x2 == null ? void 0 : x2.widths);
      if (U != null && U.staticWidth)
        ColumnSettingsWidthUtils.updateColumnWidth(D, w2, U, true);
      else if (U != null && U.initialWidth) {
        const F = ColumnSettingsWidthUtils.getSettingsWidthNumber(D._tableElementRef, U, false);
        w2.style.width = `${F.number}px`;
      } else
        w2.style.width = `${D._tableDimensions.newColumnWidth}px`;
    }
    // prettier-ignore
    static createCellElement(D, w2, O, x2) {
      var le, re, ut;
      const { _defaultColumnsSettings: { cellStyle: U, headerStyles: F }, _columnsDetails: W } = D, G = W[O], X = (ut = (re = (le = D._defaultColumnsSettings.columnDropdown) == null ? void 0 : le.displaySettings) == null ? void 0 : re.openMethod) == null ? void 0 : ut.cellClick, K = Ee.createDataCell(
        x2,
        U,
        x2 ? F == null ? void 0 : F.default : {},
        X
      ), { settings: q } = G;
      ColumnSettingsStyleUtils.applySettingsStyleOnCell(q, K, x2), ColumnSettingsBorderUtils.overwriteSideBorderIfSiblingsHaveSettings(G, [K]);
      const Q = x2 ? !X && q.isHeaderTextEditable : q.isCellTextEditable;
      return Ee.prepContentEditable(K, !!Q, X), x2 && Ee.setColumnWidth(D, K, q, D._defaultColumnsSettings), Ee.setNewText(D, K, w2, true, false), K;
    }
  };
  _CellElement.CELL_CLASS = "cell";
  _CellElement.HEADER_CELL_CLASS = "header-cell";
  _CellElement.HEADER_TAG = "TH";
  _CellElement.DATA_TAG = "TD";
  var CellElement = _CellElement;
  var _FilterViaWebWorkers = class Me {
    // prettier-ignore
    static processOtherColumnsIfPresent(D, w2, O, x2) {
      FilterInternalUtils.ACTIVE_WORKERS -= 1, O.length > 1 && x2.length > 0 ? Me.execute(D, w2, O.slice(1), x2) : FilterInternalUtils.ACTIVE_WORKERS === 0 && D();
    }
    // cannot use a direct link to a webworker file as parent project may not allow the component to access it
    // const worker = new Worker(new URL('./worker.js', import.meta.url))
    // using a string literal instead, ref:
    // https://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string
    static createWorkerBlobURL() {
      const D = new Blob([Me.CODE], { type: "application/javascript" });
      return URL.createObjectURL(D);
    }
    static hideRows(D, w2, O, x2) {
      const { colCells: U } = O[0], { matchingIndexes: F, notMatchingIndexes: W } = x2.data;
      W.forEach((G) => {
        U[G].parentElement.classList.add(FilterInternalUtils.HIDDEN_ROW_CLASS);
      }), Me.processOtherColumnsIfPresent(D, w2, O, F);
    }
    static toggleRows(D, w2, O, x2) {
      const U = [], { colCells: F } = O[0];
      x2.data.forEach((G, X) => {
        const K = F[X].parentElement;
        G ? (K.classList.remove(FilterInternalUtils.HIDDEN_ROW_CLASS), U.push(X)) : K.classList.add(FilterInternalUtils.HIDDEN_ROW_CLASS);
      }), Me.processOtherColumnsIfPresent(D, w2, O, U);
    }
    // prettier-ignore
    static execute(D, w2, O, x2) {
      const U = new Worker(w2);
      FilterInternalUtils.ACTIVE_WORKERS += 1, U.onmessage = x2 ? Me.hideRows.bind(this, D, w2, O) : Me.toggleRows.bind(this, D, w2, O);
      const F = O[0];
      U.postMessage({
        chunk: F.colCells.map((W) => CellElement.getText(W)),
        filterText: F.filterText,
        isCaseSensitive: F.isCaseSensitive,
        indexArray: x2
      });
    }
  };
  _FilterViaWebWorkers.TRAVERSE_CHUNK = `
    const result = chunk.map((text) => (isCaseSensitive ? text : text.toLocaleLowerCase()).includes(filterText));
    self.postMessage(result);
  `;
  _FilterViaWebWorkers.TRAVERSE_MATCHING_INDEXES = `
    const matchingIndexes = [];
    const notMatchingIndexes = [];
    indexArray.forEach((index) => {
      const text = chunk[index];
      const isMatching = (isCaseSensitive ? text : text.toLocaleLowerCase()).includes(filterText);
      if (isMatching) {
        matchingIndexes.push(index);
      } else {
        notMatchingIndexes.push(index);
      }
    });
    self.postMessage({matchingIndexes, notMatchingIndexes});
  `;
  _FilterViaWebWorkers.CODE = `
    self.onmessage = function (event) {
      const {chunk, indexArray, filterText, isCaseSensitive} = event.data;
      if (indexArray) {
        ${_FilterViaWebWorkers.TRAVERSE_MATCHING_INDEXES}
      } else {
        ${_FilterViaWebWorkers.TRAVERSE_CHUNK}
      }
    };
  `;
  var FilterViaWebWorkers = _FilterViaWebWorkers;
  var FilterViaTimeouts = class _FilterViaTimeouts {
    static processOtherColumnsIfPresent(D, w2, O) {
      FilterInternalUtils.ACTIVE_WORKERS -= 1, w2.length > 1 && O.length > 0 ? _FilterViaTimeouts.processOtherColumns(D, w2.slice(1), O) : FilterInternalUtils.ACTIVE_WORKERS === 0 && D();
    }
    static toggleRow(D, w2, O, x2) {
      const U = CellElement.getText(D), W = (w2.isCaseSensitive ? U : U.toLocaleLowerCase()).includes(w2.filterText), G = D.parentElement;
      W ? (G.classList.remove(FilterInternalUtils.HIDDEN_ROW_CLASS), O.push(x2)) : G.classList.add(FilterInternalUtils.HIDDEN_ROW_CLASS);
    }
    static processOtherColumns(D, w2, O) {
      setTimeout(() => {
        FilterInternalUtils.ACTIVE_WORKERS += 1;
        const x2 = [], U = w2[0];
        O.forEach((F) => {
          const W = U.chunk[F];
          _FilterViaTimeouts.toggleRow(W, U, x2, F);
        }), _FilterViaTimeouts.processOtherColumnsIfPresent(D, w2, x2);
      });
    }
    static execute(D, w2) {
      FilterInternalUtils.ACTIVE_WORKERS += 1, setTimeout(() => {
        const O = [], x2 = w2[0];
        x2.chunk.forEach((U, F) => {
          _FilterViaTimeouts.toggleRow(U, x2, O, F);
        }), _FilterViaTimeouts.processOtherColumnsIfPresent(D, w2, O);
      });
    }
  };
  var _FilterInternalUtils = class Ne {
    static finishFiltering(D) {
      D.pagination && (PageButtonContainerElement.repopulateButtons(D), PaginationUtils.displayRowsForDifferentButton(D, 1));
    }
    static getFilterFunc(D) {
      const w2 = Ne.finishFiltering.bind(this, D);
      return window.Worker ? FilterViaWebWorkers.execute.bind(this, w2, FilterViaWebWorkers.createWorkerBlobURL()) : FilterViaTimeouts.execute.bind(this, w2);
    }
    static generateDefaultHeaderName(D, w2) {
      var O, x2, U;
      return w2 && ((O = D[0]) == null ? void 0 : O.find((W) => W === w2)) ? w2 : ((x2 = D[0]) == null ? void 0 : x2[0]) !== void 0 ? String((U = D[0]) == null ? void 0 : U[0]) : "";
    }
    static addConfig(D, w2) {
      var F;
      const { placeholderTemplate: O, defaultColumnHeaderName: x2 } = w2, U = {
        isCaseSensitive: false,
        placeholderTemplate: O,
        defaultColumnHeaderName: x2 || Ne.generateDefaultHeaderName(D.data)
      };
      return (F = D._visiblityInternal).filters ?? (F.filters = []), D._visiblityInternal.filters.push(U), U;
    }
    // colElements are used to identify active column (not using name as columns can have same names)
    static assignElements(D, w2) {
      var U;
      const { data: O, _columnsDetails: x2 } = D;
      if (O.length !== 0)
        if (w2.defaultColumnHeaderName) {
          const F = O[0].findIndex((W) => W === w2.defaultColumnHeaderName);
          w2.elements = x2[F === -1 ? 0 : F].elements, delete w2.defaultColumnHeaderName;
        } else
          w2.elements && !((U = D.shadowRoot) != null && U.contains(w2.elements[0])) && (w2.elements = x2[0].elements);
    }
    // prettier-ignore
    static resetInput(D, w2) {
      const { _visiblityInternal: { filters: O } } = D;
      if (Ne.assignElements(D, w2), !w2.elements || !O)
        return;
      const x2 = CellElement.getText(w2.elements[0]);
      w2.lastRegisteredHeaderName = x2, FilterInputElement.setPlaceholder(w2.inputElement, x2, w2.placeholderTemplate), FilterInputEvents.setEvents(D, w2, O);
    }
    static unsetFilter(D) {
      D.value !== "" && (D.value = "", D.dispatchEvent(new Event("input")));
    }
    static unsetAllFilters(D) {
      var F, W;
      let w2 = false;
      const { data: O, _visiblityInternal: x2, _tableBodyElementRef: U } = D;
      return O[0] && O[0].length !== 0 && U && ((F = x2.filters) == null || F.forEach((G) => {
        G.inputElement.value !== "" && (G.inputElement.value = "", w2 = true);
      }), w2 && ((W = x2.filters) == null || W[0].inputElement.dispatchEvent(new Event("input")))), w2;
    }
    // prettier-ignore
    static resetAllInputs(D) {
      const { data: w2, _visiblityInternal: { filters: O } } = D;
      if (!w2[0] || w2[0].length === 0 || !O)
        return FilterInputEvents.unsetEvents(O);
      O.forEach((x2) => Ne.resetInput(D, x2)), Ne.unsetAllFilters(D);
    }
    static completeReset(D) {
      const w2 = D._visiblityInternal.filters;
      w2 && (Array.isArray(D.filter) ? D.filter.forEach((O, x2) => {
        w2[x2].defaultColumnHeaderName = O.defaultColumnHeaderName;
      }) : typeof D.filter == "object" && (w2[0].defaultColumnHeaderName = D.filter.defaultColumnHeaderName), Ne.resetAllInputs(D));
    }
    static isContainerRequired(D, w2) {
      let O = false;
      if (Array.isArray(D))
        O = !!D.find((x2) => {
          const U = (x2.position || FilterElements.DEFAULT_INPUT_POSITION).indexOf(w2);
          return U !== void 0 && U >= 0;
        });
      else if (typeof D == "object") {
        const x2 = (D.position || FilterElements.DEFAULT_INPUT_POSITION).indexOf(w2);
        O = x2 !== void 0 && x2 >= 0;
      } else if (typeof D == "boolean") {
        const x2 = FilterElements.DEFAULT_INPUT_POSITION.indexOf(w2);
        O = x2 !== void 0 && x2 >= 0;
      }
      return O;
    }
    static extractUnfilteredRows(D, w2) {
      return Array.from(D.children).slice(0, w2).filter((x2) => !x2.classList.contains(Ne.HIDDEN_ROW_CLASS));
    }
    // prettier-ignore
    static wasHeaderChanged(D, w2, O, x2) {
      const U = D[O].elements, F = w2.find((W) => U === W.elements);
      return F && (F.lastRegisteredHeaderName !== CellElement.getText(U[0]) || x2);
    }
  };
  _FilterInternalUtils.ACTIVE_WORKERS = 0;
  _FilterInternalUtils.CHUNK_SIZE = 2;
  _FilterInternalUtils.HIDDEN_ROW_CLASS = "filter-hidden-row";
  var FilterInternalUtils = _FilterInternalUtils;
  var FileImportInputElement = class {
    // always created as the user may want to trigger the importCSV method without the CSV buttons and need this to work
    static create(D) {
      const w2 = document.createElement("input");
      return w2.type = "file", w2.hidden = true, setTimeout(() => {
        var O;
        (O = D._tableElementRef) == null || O.appendChild(w2);
      }), w2;
    }
  };
  var FilesUtils = class {
    static processStyles(D) {
      const w2 = { default: {}, hover: { backgroundColor: "#f0f0f0" }, click: { backgroundColor: "#e4e4e4" } };
      return D && (Object.assign(w2.default, D.default), Object.assign(w2.hover, D.hover), Object.assign(w2.click, D.click)), w2;
    }
    static createDefault(D) {
      return { inputElementRef: FileImportInputElement.create(D) };
    }
  };
  FilesUtils.DEFAULT_BUTTON_POSITION = "bottom-left";
  var _OuterContainerElements = class se {
    // REF-38
    static getColumnContentContainer(D) {
      return D.children[0].children[0];
    }
    static setContainerHeightBasedOnMiddleColumn(D) {
      if (D.getBoundingClientRect().height === 0) {
        const w2 = se.getColumnContentContainer(D.children[1]);
        D.style.height = `${w2.getBoundingClientRect().height}px`;
      }
    }
    static setHeightsWhenOnlyMiddleColumns(D) {
      setTimeout(() => {
        D.top && se.setContainerHeightBasedOnMiddleColumn(D.top), D.bottom && se.setContainerHeightBasedOnMiddleColumn(D.bottom);
      });
    }
    // REF-38
    static appendChildToColumn(D, w2) {
      se.getColumnContentContainer(D).appendChild(w2);
    }
    // REF-38
    static addToContainer(D, w2, O) {
      const x2 = D.indexOf("top") >= 0 ? w2.top : w2.bottom;
      D.indexOf("left") >= 0 ? se.appendChildToColumn(x2.children[0], O) : D.indexOf("center") >= 0 ? se.appendChildToColumn(x2.children[1], O) : se.appendChildToColumn(x2.children[2], O);
    }
    // REF-38
    // need an inner divs in order for the inserted components 'width' properties to work as CONTAINER_CLASS has width: 0px
    static createContainerColumn(D, w2) {
      const O = document.createElement("div");
      O.classList.add(se.COLUMN_CLASS, D);
      const x2 = document.createElement("div");
      x2.classList.add(se.COLUMN_INNER_CLASS);
      const U = document.createElement("div");
      return U.classList.add(se.COLUMN_CONTENT_CLASS), x2.appendChild(U), O.appendChild(x2), O.style.gridColumn = w2, O;
    }
    static createContainerElement() {
      const D = document.createElement("div");
      D.classList.add(se.CONTAINER_CLASS);
      const w2 = se.createContainerColumn(se.LEFT_COLUMN_CLASS, "1");
      D.appendChild(w2);
      const O = se.createContainerColumn(se.CENTER_COLUMN_CLASS, "2");
      D.appendChild(O);
      const x2 = se.createContainerColumn(se.RIGHT_COLUMN_CLASS, "3");
      return D.appendChild(x2), D;
    }
    static addContainer(D, w2, O) {
      const x2 = se.createContainerElement();
      x2.id = w2, O != null && O.style.fontFamily && (x2.style.fontFamily = O.style.fontFamily);
      const U = w2 === se.TOP_CONTAINER_ID ? "beforebegin" : "afterend";
      return D.insertAdjacentElement(U, x2), x2;
    }
    // can be reused for other positional components
    static isRequired(D, w2) {
      return !!Object.keys(D).find((O) => {
        const { position: x2 } = D[O];
        return x2.indexOf(w2) >= 0;
      });
    }
    static isContainerRequired(D, w2) {
      var x2;
      let O = false;
      return D.pagination && (O = se.isRequired(D._pagination.positions, w2)), !O && ((x2 = D.files) != null && x2.buttons) && (O = !!D.files.buttons.find((U) => (U.position || FilesUtils.DEFAULT_BUTTON_POSITION).indexOf(w2) >= 0)), !O && D.filter && (O = FilterInternalUtils.isContainerRequired(D.filter, w2)), O;
    }
    // we create a top and a bottom container only if they are required
    static create(D) {
      var W;
      const w2 = {}, O = se.isContainerRequired(D, "top"), x2 = se.isContainerRequired(D, "bottom"), { _tableElementRef: U } = D, F = ((W = D._overflow) == null ? void 0 : W.overflowContainer) || U;
      if (!F)
        return w2;
      if (O) {
        const G = se.addContainer(F, se.TOP_CONTAINER_ID, U);
        w2.top = G;
      }
      if (x2) {
        const G = se.addContainer(F, se.BOTTOM_CONTAINER_ID, U);
        w2.bottom = G;
      }
      return se.setHeightsWhenOnlyMiddleColumns(w2), w2;
    }
  };
  _OuterContainerElements.ABSOULUTE_FULL_TABLE_CLASS = "absolute-container";
  _OuterContainerElements.CONTAINER_CLASS = "outer-container";
  _OuterContainerElements.TOP_CONTAINER_ID = "outer-top-container";
  _OuterContainerElements.BOTTOM_CONTAINER_ID = "outer-bottom-container";
  _OuterContainerElements.COLUMN_CLASS = "outer-container-column";
  _OuterContainerElements.COLUMN_INNER_CLASS = "outer-container-column-inner";
  _OuterContainerElements.COLUMN_CONTENT_CLASS = "outer-container-column-content";
  _OuterContainerElements.LEFT_COLUMN_CLASS = "outer-container-left-column";
  _OuterContainerElements.CENTER_COLUMN_CLASS = "outer-container-center-column";
  _OuterContainerElements.RIGHT_COLUMN_CLASS = "outer-container-right-column";
  var OuterContainerElements = _OuterContainerElements;
  var _OuterDropdownButtonUtils = class ot {
    static processStatefulStyle(D) {
      D.hover ?? (D.hover = D.default), D.click ?? (D.click = D.hover);
    }
    static processAndApplyDefaultStyle(D, w2) {
      w2 && (ot.processStatefulStyle(w2), Object.assign(D.style, w2.default));
    }
    static createArrow(D, w2) {
      const O = document.createElement("div");
      O.classList.add(ot.ARROW_CONTAINER_CLASS, GenericElementUtils.NOT_SELECTABLE_CLASS), D && O.classList.add(...D);
      const x2 = SVGIconUtils.createSVGElement(ARROW_DOWN_SVG_STRING);
      return x2.classList.add(ot.ARROW_ICON_CLASS), w2 && x2.classList.add(...w2), O.appendChild(x2), O;
    }
  };
  _OuterDropdownButtonUtils.ARROW_CONTAINER_CLASS = "outer-dropdown-button-arrow-container";
  _OuterDropdownButtonUtils.ARROW_ICON_CLASS = "outer-dropdown-button-arrow-icon";
  var OuterDropdownButtonUtils = _OuterDropdownButtonUtils;
  var RowsPerPageSelectButtonEvents = class _RowsPerPageSelectButtonEvents {
    static mouseDown(D, w2) {
      var U, F, W, G, X, K;
      Object.assign(w2.style, (F = (U = D.styles.rowsPerPageSelect) == null ? void 0 : U.button) == null ? void 0 : F.click);
      const O = w2.children[0];
      Object.assign(O.style, (G = (W = D.styles.rowsPerPageSelect) == null ? void 0 : W.buttonText) == null ? void 0 : G.click);
      const x2 = w2.children[1];
      Object.assign(x2.style, (K = (X = D.styles.rowsPerPageSelect) == null ? void 0 : X.buttonArrow) == null ? void 0 : K.click);
    }
    static mouseLeave(D, w2) {
      RowsPerPageSelectButtonElement.applyStylesOnElements(w2, "default", D.rowsPerPageSelect);
    }
    static mouseEnter(D, w2) {
      RowsPerPageSelectButtonElement.applyStylesOnElements(w2, "hover", D.rowsPerPageSelect);
    }
    static setEvents(D, w2) {
      w2.onmouseenter = _RowsPerPageSelectButtonEvents.mouseEnter.bind(this, D._pagination.styles, w2), w2.onmouseleave = _RowsPerPageSelectButtonEvents.mouseLeave.bind(this, D._pagination.styles, w2), w2.onmousedown = _RowsPerPageSelectButtonEvents.mouseDown.bind(this, D._pagination, w2), w2.onmouseup = _RowsPerPageSelectButtonEvents.mouseEnter.bind(this, D._pagination.styles, w2);
    }
  };
  var _RowsPerPageSelectButtonElement = class ze {
    // prettier-ignore
    static applyStylesOnElements(D, w2, O) {
      if (!O)
        return;
      const { button: x2, buttonText: U, buttonArrow: F } = O;
      if (x2 && StatefulCSSEvents.apply(x2, x2[w2], D), U) {
        const W = D.children[0];
        StatefulCSSEvents.apply(U, U[w2], W);
      }
      if (F) {
        const W = D.children[1];
        StatefulCSSEvents.apply(F, F[w2], W);
      }
    }
    static createButtonArrow(D) {
      var O;
      const w2 = OuterDropdownButtonUtils.createArrow();
      return OuterDropdownButtonUtils.processAndApplyDefaultStyle(w2, (O = D.styles.rowsPerPageSelect) == null ? void 0 : O.buttonArrow), w2;
    }
    static updateButtonText(D, w2) {
      const O = D.children[0];
      O.innerText = w2;
    }
    static createButtonText(D) {
      var W;
      const { isAllRowsOptionSelected: w2, rowsPerPageOptionsItemText: O, rowsPerPage: x2, styles: U } = D, F = document.createElement("div");
      return F.id = ze.TEXT_ID, F.classList.add(GenericElementUtils.NOT_SELECTABLE_CLASS), OuterDropdownButtonUtils.processAndApplyDefaultStyle(F, (W = U.rowsPerPageSelect) == null ? void 0 : W.buttonText), F.innerText = w2 ? O[0] : String(x2), F;
    }
    static createOptionsButton(D) {
      var O;
      const w2 = document.createElement("div");
      return w2.id = ze.BUTTON_ID, OuterDropdownButtonUtils.processAndApplyDefaultStyle(w2, (O = D.styles.rowsPerPageSelect) == null ? void 0 : O.button), w2;
    }
    static create(D) {
      const w2 = ze.createOptionsButton(D._pagination);
      return w2.appendChild(ze.createButtonText(D._pagination)), w2.appendChild(ze.createButtonArrow(D._pagination)), setTimeout(() => RowsPerPageSelectButtonEvents.setEvents(D, w2)), w2;
    }
  };
  _RowsPerPageSelectButtonElement.BUTTON_ID = "rows-per-page-select-button";
  _RowsPerPageSelectButtonElement.TEXT_ID = "rows-per-page-select-button-text";
  var RowsPerPageSelectButtonElement = _RowsPerPageSelectButtonElement;
  var RowsPerPageDropdown = class _RowsPerPageDropdown {
    static getLeftPropertyToCenterDropdown(D, w2) {
      return `${D.offsetLeft + D.offsetWidth / 2 - w2 / 2}px`;
    }
    static display(D, w2, O) {
      const { dropdownWidth: x2 } = w2._pagination, { element: U } = O;
      U.style.left = _RowsPerPageDropdown.getLeftPropertyToCenterDropdown(D, x2), OuterDropdownSimpleUtils.display(D, w2, O);
    }
    static setWidth(D, w2) {
      const x2 = w2.rowsPerPageOptionsItemText.reduce((U, F) => isNaN(Number(F)) ? U : Math.max(U, F.length), 1) * 8;
      w2.dropdownWidth = w2.dropdownWidth + x2, D.style.width = `${w2.dropdownWidth}px`;
    }
    static create(D, w2) {
      const O = OuterDropdownSimpleUtils.hide.bind(this, D._activeOverlayElements), x2 = _RowsPerPageDropdown.display.bind(this, w2), U = OuterDropdownElement.create(D, w2, "bottom-center", {}, [], O, x2);
      return RowsPerPageDropdownItem.populate(D, U.element, w2), _RowsPerPageDropdown.setWidth(U.element, D._pagination), U;
    }
  };
  var _RowsPerPageSelectElement = class qe {
    static createText(D) {
      var O;
      const w2 = document.createElement("div");
      return w2.id = qe.TEXT_ID, w2.style.marginRight = "8px", Object.assign(w2.style, (O = D.styles.rowsPerPageSelect) == null ? void 0 : O.prefixText), w2.innerText = D.rowsPerPageSelect.prefixText, w2;
    }
    static createContainer(D) {
      var O;
      const w2 = document.createElement("div");
      return w2.id = qe.ID, w2.classList.add(PaginationElements.PAGINATION_TEXT_COMPONENT_CLASS), w2.style.order = String(D.positions.rowsPerPageSelect.order), Object.assign(w2.style, (O = D.styles.rowsPerPageSelect) == null ? void 0 : O.container), w2;
    }
    // prettier-ignore
    static create(D, w2) {
      const O = qe.createContainer(D._pagination);
      O.appendChild(qe.createText(D._pagination));
      const x2 = RowsPerPageSelectButtonElement.create(D), U = RowsPerPageDropdown.create(D, x2);
      return O.appendChild(x2), O.appendChild(U.element), OuterContainerElements.addToContainer(
        D._pagination.positions.rowsPerPageSelect.position,
        w2,
        O
      ), O;
    }
  };
  _RowsPerPageSelectElement.ID = "pagination-number-of-rows-select";
  _RowsPerPageSelectElement.TEXT_ID = "pagination-number-of-rows-select-text";
  var RowsPerPageSelectElement = _RowsPerPageSelectElement;
  var PaginationElements = class {
    static create(D, w2) {
      D._pagination.buttonContainer = PageButtonContainerElement.create(D), PageButtonContainerElement.addInitialElements(D, w2), D._pagination.rowsPerPageOptionsItemText && RowsPerPageSelectElement.create(D, w2), D._pagination.displayNumberOfVisibleRows && (D._pagination.numberOfVisibleRowsElement = NumberOfVisibleRowsElement.create(D, w2));
    }
  };
  PaginationElements.PAGINATION_TEXT_COMPONENT_CLASS = "pagination-text-component";
  var _NumberOfVisibleRowsElement = class Ze {
    static updateForRelativeRowNumber(D, w2) {
      const { activePageNumber: O, rowsPerPage: x2, numberOfVisibleRowsElement: U } = D, F = O * x2, W = w2 < 1 ? 0 : Math.max(F - x2 + 1, 1), G = Math.min(w2, F);
      U.innerText = `${W}-${G} of ${w2}`;
    }
    static updateForAllRows(D, w2) {
      D.innerText = `${Math.min(w2, 1)}-${w2} of ${w2}`;
    }
    static update(D) {
      var G, X;
      const { _pagination: w2, data: O, dataStartsAtHeader: x2 } = D, { numberOfVisibleRowsElement: U, isAllRowsOptionSelected: F } = w2;
      if (!U)
        return;
      const W = ((X = (G = D._pagination) == null ? void 0 : G.asyncStartData) == null ? void 0 : X.totalDataRows) || Math.max(x2 ? O.length : O.length - 1, 0);
      F ? Ze.updateForAllRows(U, W) : Ze.updateForRelativeRowNumber(D._pagination, W);
    }
    static create(D, w2) {
      const O = document.createElement("div");
      O.id = Ze.ID, O.classList.add(PaginationElements.PAGINATION_TEXT_COMPONENT_CLASS);
      const { styles: x2, positions: U } = D._pagination;
      return O.style.order = String(U.numberOfVisibleRows.order), Object.assign(O.style, x2.numberOfVisibleRows), OuterContainerElements.addToContainer(U.numberOfVisibleRows.position, w2, O), setTimeout(() => Ze.update(D)), O;
    }
  };
  _NumberOfVisibleRowsElement.ID = "pagination-number-of-visible-rows";
  var NumberOfVisibleRowsElement = _NumberOfVisibleRowsElement;
  var PageNumberButtonEvents = class _PageNumberButtonEvents {
    // REF-30
    static markClick(D) {
      D.clickedPageNumberButton = true, setTimeout(() => D.clickedPageNumberButton = false);
    }
    static buttonMouseUp(D, w2) {
      _PageNumberButtonEvents.markClick(this._pagination);
      const O = w2.target, { pageButtons: x2 } = this._pagination.styles;
      this._pagination.activePageNumber === D || PaginationUtils.getAndApplyDataOnButtonClick(this, D), PageButtonStyle.mouseEnter(O, x2, false);
    }
    static setEvents(D, w2, O) {
      O.onmouseup = _PageNumberButtonEvents.buttonMouseUp.bind(D, w2);
    }
  };
  var PageNumberButtonElement = class {
    static create(D, w2) {
      const O = PageButtonElement.create(D._pagination.styles.pageButtons, false);
      return O.innerHTML = String(w2), setTimeout(() => PageNumberButtonEvents.setEvents(D, w2, O)), O;
    }
  };
  var PaginationUpdatePageButtons = class _PaginationUpdatePageButtons {
    static removeLastNumberButton(D, w2) {
      w2[w2.length - 1].remove();
      const O = w2[0], x2 = Number(O.innerText);
      if (x2 > 1) {
        const U = PageNumberButtonElement.create(D, x2 - 1);
        O.insertAdjacentElement("beforebegin", U);
      }
    }
    static updateOnRowRemove(D) {
      const w2 = PaginationUtils.getPageNumberButtons(D._pagination), O = w2[w2.length - 1];
      Number(O.innerText) > PaginationUtils.getLastPossiblePageNumber(D) ? w2.length > 1 && _PaginationUpdatePageButtons.removeLastNumberButton(D, w2) : D.data.length < (D.dataStartsAtHeader ? 1 : 2) && PageButtonElement.setDisabled(D._pagination);
    }
    static addNewNumberButtonAtEndIfNeeded(D, w2) {
      const O = w2[w2.length - 1], x2 = PaginationUtils.getLastPossiblePageNumber(D, true);
      if (Number(O.innerText) < x2) {
        const U = PageNumberButtonElement.create(D, x2);
        O.insertAdjacentElement("afterend", U);
      }
    }
    static updateOnRowInsert(D) {
      const w2 = D.dataStartsAtHeader ? 0 : 1;
      if (D.data.length === w2)
        PageButtonElement.unsetDisabled(D._pagination);
      else {
        const O = PaginationUtils.getPageNumberButtons(D._pagination);
        O.length < D._pagination.maxNumberOfVisiblePageButtons && _PaginationUpdatePageButtons.addNewNumberButtonAtEndIfNeeded(D, O);
      }
    }
    // prettier-ignore
    static shiftLeftwards(D, w2, O) {
      const { activePageNumber: x2 } = D._pagination, U = w2[0], F = Number(U.innerText);
      let W = x2 <= w2.length / 2 ? F - 1 : O - x2, G = F;
      W > w2.length && (W = w2.length, G = w2.length + 1);
      for (let X = W - 1; X >= 0; X -= 1) {
        const K = PageNumberButtonElement.create(D, G - X - 1);
        U.insertAdjacentElement("beforebegin", K);
      }
      w2.slice(w2.length - W).forEach((X) => X.remove());
    }
    // prettier-ignore
    static shiftRightwards(D, w2, O, x2) {
      const { activePageNumber: U } = D._pagination, F = PaginationUtils.getLastPossiblePageNumber(D);
      let W = U > F - w2.length / 2 ? F - O : U - x2, G = O;
      W > w2.length && (W = w2.length, G = U - w2.length);
      const X = w2[w2.length - 1];
      for (let K = W - 1; K >= 0; K -= 1) {
        const q = PageNumberButtonElement.create(D, K + G + 1);
        X.insertAdjacentElement("afterend", q);
      }
      w2.slice(0, W).forEach((K) => K.remove());
    }
    static updateOnNewActive(D) {
      const w2 = PaginationUtils.getPageNumberButtons(D._pagination), { activePageNumber: O, maxNumberOfVisiblePageButtons: x2 } = D._pagination;
      if (w2.length < x2)
        return;
      const U = Number(w2[w2.length - 1].innerText), F = Math.floor(U - w2.length / 2) + 1;
      if (O > F)
        _PaginationUpdatePageButtons.shiftRightwards(D, w2, U, F);
      else {
        const W = Math.ceil(U - w2.length / 2);
        O < W && _PaginationUpdatePageButtons.shiftLeftwards(D, w2, W);
      }
    }
  };
  var _LoadingElement = class he {
    static createSpinner(D) {
      const w2 = document.createElement("span");
      return w2.className = "loading-spinner", Object.assign(w2.style, D), w2;
    }
    static applyTableStyles(D, w2, O) {
      D.forEach((x2) => {
        w2[x2] && (O.style[x2] = w2[x2]);
      });
    }
    static removeTableStyles(D, w2) {
      D.forEach((O) => {
        delete w2.style[O];
      });
    }
    static processCustom(D, w2) {
      return D.style.display === "none" && (D.style.display = "block"), Object.assign(D.style, w2 == null ? void 0 : w2.container), D;
    }
    // prettier-ignore
    static createContainer(D, w2) {
      const O = document.createElement("div");
      return w2 && he.applyTableStyles(
        ["width", "minWidth", "maxHeight", "height", "minHeight", "maxHeight", "border", "borderColor", "borderWidth"],
        w2,
        O
      ), Object.assign(O.style, D == null ? void 0 : D.container), O;
    }
    static createNew(D, w2) {
      const O = he.createContainer(D, w2);
      O.classList.add(he.DEFAULT_LOADING_CONTAINER_CLASS);
      const x2 = he.createSpinner(D == null ? void 0 : D.spinner);
      return O.appendChild(x2), O;
    }
    static processInitial(D) {
      const { loadingStyles: w2, tableStyle: O } = D, x2 = D.children[0];
      return x2 ? he.processCustom(x2, w2) : he.createNew(w2, O);
    }
    static addInitial(D) {
      var w2;
      D._activeOverlayElements.loading = he.processInitial(D), (w2 = D.shadowRoot) == null || w2.appendChild(D._activeOverlayElements.loading);
    }
    static update(D, w2, O) {
      D.classList.contains(he.DEFAULT_LOADING_CONTAINER_CLASS) && w2 && (he.removeTableStyles(
        ["width", "minWidth", "maxHeight", "height", "minHeight", "maxHeight", "border", "borderColor", "borderWidth"],
        D
      ), Object.assign(D.style, O == null ? void 0 : O.container)), O != null && O.loadingBackgroundColor && (D.style.backgroundColor = O == null ? void 0 : O.loadingBackgroundColor);
    }
    static addActive(D) {
      var O;
      const { loading: w2 } = D._activeOverlayElements;
      w2 && (w2.classList.contains(OuterContainerElements.ABSOULUTE_FULL_TABLE_CLASS) || (w2.classList.add(OuterContainerElements.ABSOULUTE_FULL_TABLE_CLASS), he.update(w2, D.tableStyle, D.loadingStyles)), (O = D._tableElementRef) == null || O.appendChild(w2));
    }
  };
  _LoadingElement.DEFAULT_LOADING_CONTAINER_CLASS = "default-loading-container";
  var LoadingElement = _LoadingElement;
  var ErrorElement = class {
    static create() {
      const D = document.createElement("div");
      D.id = "error-container", D.classList.add(OuterContainerElements.ABSOULUTE_FULL_TABLE_CLASS);
      const w2 = document.createElement("div");
      return w2.id = "error-text", w2.innerHTML = "Error retrieving data", D.appendChild(w2), D;
    }
    static display(D) {
      const { error: w2 } = D._activeOverlayElements;
      w2 && D._tableElementRef && D._tableElementRef.appendChild(w2);
    }
    static remove(D) {
      var w2;
      (w2 = D._activeOverlayElements.error) == null || w2.remove();
    }
  };
  var PaginationAsyncUtils = class _PaginationAsyncUtils {
    static displayError(D, w2) {
      ErrorElement.display(w2), console.error(D), console.error("Error fetching page information");
    }
    // prettier-ignore
    static setNewElementText(D, w2, O, x2, U) {
      CellEvents.updateCell(
        D,
        w2,
        U,
        x2,
        { element: O, processText: false, updateCellEvent: false, updateTableEvent: false }
      ), ColumnTypesUtils.updateDataElements(D, U, x2, O);
    }
    static insertData(D, w2, O) {
      const x2 = D.dataStartsAtHeader ? 0 : 1, U = (O - 1) * 10 + x2;
      w2.length > D._pagination.rowsPerPage && (w2 = w2.slice(0, D._pagination.rowsPerPage)), U + w2.length > D.data.length && (w2 = w2.slice(0, w2.length - (U + w2.length - D.data.length))), w2.forEach((F, W) => {
        F.forEach((G, X) => {
          const K = U + W, q = D._columnsDetails[X].elements[K];
          _PaginationAsyncUtils.setNewElementText(D, G, q, X, K);
        });
      }), UpdateIndexColumnWidth.update(D);
    }
    static async getAndApplyNewData(D, w2, O, x2) {
      var W;
      const U = x2 || O;
      D._pagination.asyncGetId = U, ErrorElement.remove(D), LoadingElement.addActive(D), PageButtonElement.setActive(D, O);
      let F = [[]];
      try {
        if (F = await w2.getPageData(O, D._pagination.rowsPerPage), D._pagination.asyncGetId !== U)
          return;
      } catch (G) {
        _PaginationAsyncUtils.displayError(G, D);
      }
      _PaginationAsyncUtils.insertData(D, F, O), (W = D._activeOverlayElements.loading) == null || W.remove(), PaginationUtils.displayRowsForDifferentButton(D, O);
    }
    static isAsyncPagination(D) {
      return typeof D == "object" && D.async;
    }
    static removeLoadingOverlay(D) {
      var w2;
      _PaginationAsyncUtils.isAsyncPagination(D.pagination) && ((w2 = D._activeOverlayElements.loading) == null || w2.remove());
    }
    static preprocessTablePropertiesIfAsync(D) {
      var w2;
      _PaginationAsyncUtils.isAsyncPagination(D.pagination) && (D.displayAddNewRow = false, D.displayAddNewColumn = false, D.rowDropdown.displaySettings.isAvailable = false, D.columnDropdown = { displaySettings: { isAvailable: false } }, D.files ?? (D.files = {}), D.files.buttons = (w2 = D.files.buttons) == null ? void 0 : w2.filter((O) => !O.import), D.files.dragAndDrop = false);
    }
  };
  var _PaginationUtils = class ne {
    static getLastPossiblePageNumber(D, w2 = false) {
      const { _pagination: O, dataStartsAtHeader: x2 } = D;
      if (O.isAllRowsOptionSelected)
        return 1;
      const U = PaginationInternalUtils.getTotalNumberOfRows(D), F = x2 ? U + 1 : U, W = w2 ? F : F - 1;
      return Math.max(Math.ceil(W / O.rowsPerPage), 1);
    }
    static getPageNumberButtons(D) {
      const { buttonContainer: w2, numberOfActionButtons: O } = D, x2 = Array.from(w2.children), U = O / 2;
      return x2.slice(U, x2.length - U);
    }
    static hideRow(D) {
      var w2;
      ((w2 = D.children[0]) == null ? void 0 : w2.tagName) === CellElement.HEADER_TAG ? D.classList.add(ne.HIDDEN_ROW_CLASS) : D.style.display = "none";
    }
    static displayRow(D, w2) {
      D.children[0].tagName === CellElement.HEADER_TAG ? D.classList.remove(ne.HIDDEN_ROW_CLASS) : D.style.display = "", w2.push(D);
    }
    // changes to the page that the row was moved to
    static updateOnRowMove(D, w2) {
      const { activePageNumber: O } = D._pagination;
      PaginationRowIndexes.getMaxVisibleRowIndex(D) <= w2 ? ne.displayRowsForDifferentButton(D, O + 1) : w2 > 0 && D._tableBodyElementRef && w2 < PaginationRowIndexes.getVisibleRowRealIndex(D._tableBodyElementRef, D._pagination, 0) && ne.displayRowsForDifferentButton(D, O - 1);
    }
    // prettier-ignore
    static getSiblingVisibleRow(D, w2) {
      const O = D == null ? void 0 : D[w2];
      if (!(!O || AddNewRowElement.isAddNewRowRow(O)))
        return O.classList.contains(FilterInternalUtils.HIDDEN_ROW_CLASS) ? ne.getSiblingVisibleRow(O, w2) : O;
    }
    static updateRowsOnRemoval(D, w2) {
      const { visibleRows: O, activePageNumber: x2 } = D._pagination;
      if (!(x2 === 1 && w2 === -1))
        if (O.splice(w2, 1), O.length > 0) {
          const U = O[O.length - 1], F = ne.getSiblingVisibleRow(U, "nextSibling");
          F && ne.displayRow(F, O);
        } else
          x2 > 1 && (ne.displayRowsForDifferentButton(D, x2 - 1), D._visiblityInternal.filters && ne.getLastPossiblePageNumber(D) !== x2 - 1 && ne.displayRowsForDifferentButton(D, x2));
    }
    static hideLastVisibleRow(D) {
      const { visibleRows: w2 } = D;
      if (w2.length === 0)
        return;
      const O = w2[w2.length - 1];
      ne.hideRow(O), D.visibleRows.splice(D.visibleRows.length - 1, 1);
    }
    static updateRowsOnNewInsert(D, w2, O) {
      const { rowsPerPage: x2, visibleRows: U, activePageNumber: F, isAllRowsOptionSelected: W } = D._pagination;
      if (PaginationRowIndexes.getMaxVisibleRowIndex(D) > w2 && D._tableBodyElementRef) {
        U.length === x2 && !W && ne.hideLastVisibleRow(D._pagination);
        const G = PaginationRowIndexes.getVisibleRowIndex(D._tableBodyElementRef, D._pagination, w2);
        U.splice(G === -1 ? U.length : G, 0, O);
      } else
        ne.hideRow(O), setTimeout(() => {
          const G = ne.getLastPossiblePageNumber(D), X = F + 1;
          G < X ? ne.setCorrectRowsAsVisible(D, G) : ne.displayRowsForDifferentButton(D, X);
        });
    }
    // for removal - we pass visible row index as when filter is set - we need to get it before the element is removed
    static updateOnRowChange(D, w2, O) {
      const { dataStartsAtHeader: x2, _pagination: U } = D;
      !x2 && w2 === 0 && PaginationInternalUtils.getTotalNumberOfRows(D) === 0 || (PaginationVisibleButtonsUtils.unsetStateAndStyles(U), O ? (PaginationUpdatePageButtons.updateOnRowInsert(D), ne.updateRowsOnNewInsert(D, w2, O)) : (PaginationUpdatePageButtons.updateOnRowRemove(D), ne.updateRowsOnRemoval(D, w2)), PaginationPageActionButtonUtils.toggleActionButtons(D), PaginationVisibleButtonsUtils.setStateAndStyles(D), setTimeout(() => NumberOfVisibleRowsElement.update(D)));
    }
    static initialRowUpdates(D, w2, O) {
      const x2 = D.dataStartsAtHeader ? w2 + 1 : w2;
      x2 > D._pagination.rowsPerPage ? ne.hideRow(O) : x2 > 0 && D._pagination.visibleRows.push(O);
    }
    // REF-32
    static updateAddRowRow(D) {
      if (D._stripedRows && D._tableBodyElementRef && D._addRowCellElementRef) {
        const w2 = D._addRowCellElementRef.parentElement, O = Array.from(D._tableBodyElementRef.children).length - 1, x2 = ne.getLastPossiblePageNumber(D) !== D._pagination.activePageNumber;
        CustomRowProperties.updateRow(D, w2, O, x2, O);
      }
    }
    // prettier-ignore
    static setCorrectRowsAsVisible(D, w2) {
      const { _pagination: { rowsPerPage: O, visibleRows: x2 }, _tableBodyElementRef: U, data: F, _visiblityInternal: W } = D, G = W != null && W.filters ? FilterInternalUtils.extractUnfilteredRows(U, F.length) : ExtractElements.textRowsArrFromTBody(U, F);
      let X = O * (w2 - 1);
      D.dataStartsAtHeader || (X += 1), G.slice(X, X + O).forEach((K) => {
        ne.displayRow(K, x2);
      });
    }
    static hideAllRows(D) {
      D.visibleRows.forEach((w2) => ne.hideRow(w2)), D.visibleRows = [];
    }
    static displayRowsForDifferentButton(D, w2) {
      ne.hideAllRows(D._pagination), ne.setCorrectRowsAsVisible(D, w2), PageButtonElement.setActive(D, w2), NumberOfVisibleRowsElement.update(D), D._frameComponents.displayAddNewRow && ne.updateAddRowRow(D);
    }
    static getFirstVisibleRow(D) {
      return D.find((w2) => !w2.classList.contains(FilterInternalUtils.HIDDEN_ROW_CLASS));
    }
    static async getAndApplyDataOnButtonClick(D, w2, O) {
      D._pagination.async ? PaginationAsyncUtils.getAndApplyNewData(D, D._pagination.async, w2, O) : ne.displayRowsForDifferentButton(D, w2);
    }
  };
  _PaginationUtils.HIDDEN_ROW_CLASS = "hidden-row";
  var PaginationUtils = _PaginationUtils;
  var PaginationPageActionButtonUtils = class _PaginationPageActionButtonUtils {
    static setButtonAsEnabled(D, w2) {
      PageButtonStyle.setDefault(D, w2, true), D.classList.remove(PageButtonElement.DISABLED_PAGINATION_BUTTON_CLASS);
    }
    static setButtonAsDisabled(D, w2) {
      PageButtonStyle.setDisabled(D, w2, true), D.classList.add(PageButtonElement.DISABLED_PAGINATION_BUTTON_CLASS);
    }
    // prettier-ignore
    static toggleRightButtons(D, w2, O) {
      const { activePageNumber: x2, styles: U } = D._pagination, F = PaginationUtils.getLastPossiblePageNumber(D), W = x2 === F ? _PaginationPageActionButtonUtils.setButtonAsDisabled : _PaginationPageActionButtonUtils.setButtonAsEnabled;
      w2.slice(w2.length - O).forEach((X) => W(X, U.pageButtons));
    }
    // prettier-ignore
    static toggleLeftButtons(D, w2, O, x2) {
      const U = w2 === 1 ? _PaginationPageActionButtonUtils.setButtonAsDisabled : _PaginationPageActionButtonUtils.setButtonAsEnabled;
      D.slice(0, O).forEach((W) => U(W, x2.pageButtons));
    }
    static toggleActionButtons(D) {
      const { activePageNumber: w2, styles: O, numberOfActionButtons: x2, buttonContainer: U } = D._pagination, F = Array.from(U.children), W = x2 / 2;
      _PaginationPageActionButtonUtils.toggleLeftButtons(F, w2, W, O), _PaginationPageActionButtonUtils.toggleRightButtons(D, F, W);
    }
  };
  var PageButtonEvents = class _PageButtonEvents {
    static buttonMouseLeave(D, w2, O) {
      const x2 = O.target;
      PageButtonStyle.mouseLeave(x2, D, w2);
    }
    static buttonMouseEnter(D, w2, O) {
      const x2 = O.target;
      PageButtonStyle.mouseEnter(x2, D, w2);
    }
    static buttonMouseDown(D, w2, O) {
      const x2 = O.target;
      PageButtonStyle.mouseDown(x2, D, w2);
    }
    static setEvents(D, w2, O) {
      D.onmousedown = _PageButtonEvents.buttonMouseDown.bind(this, w2, O), D.onmouseenter = _PageButtonEvents.buttonMouseEnter.bind(this, w2, O), D.onmouseleave = _PageButtonEvents.buttonMouseLeave.bind(this, w2, O);
    }
  };
  var _PageButtonElement = class ke {
    static unsetDisabled(D) {
      const w2 = PaginationUtils.getPageNumberButtons(D)[0], { pageButtons: O } = D.styles;
      PageButtonStyle.setActive(w2, O), w2.classList.replace(ke.DISABLED_PAGINATION_BUTTON_CLASS, O.activeButtonClass);
    }
    static setDisabled(D) {
      const { buttonContainer: w2, styles: O, numberOfActionButtons: x2 } = D, U = Array.from(w2.children);
      for (let W = 0; W < x2 / 2; W += 1)
        PageButtonStyle.setDisabled(U[W], O.pageButtons, true), PageButtonStyle.setDisabled(U[U.length - 1 - W], O.pageButtons, true);
      const F = PaginationUtils.getPageNumberButtons(D)[0];
      PageButtonStyle.setDisabled(F, O.pageButtons, false), F.classList.remove(O.pageButtons.activeButtonClass), U.forEach((W) => {
        W.classList.add(ke.DISABLED_PAGINATION_BUTTON_CLASS);
      });
    }
    // prettier-ignore
    static programmaticMouseEnterTrigger(D, w2, O) {
      const x2 = D[O], { pageButtons: U } = w2.styles;
      x2 && !x2.classList.contains(U.activeButtonClass) && (PageButtonStyle.mouseEnter(x2, U, false), w2.programaticallyHoveredPageNumberButton = x2, setTimeout(() => delete w2.programaticallyHoveredPageNumberButton));
    }
    static setNewActive(D, w2) {
      const O = PaginationUtils.getPageNumberButtons(D), x2 = Number(O[O.length - 1].innerText), U = O.length - (x2 - w2) - 1, F = O[U];
      return F.classList.add(D.styles.pageButtons.activeButtonClass), { newActiveButton: F, numberButtons: O };
    }
    static unsetPreviousActive(D, w2) {
      const O = PaginationUtils.getPageNumberButtons(D), x2 = Number(O[O.length - 1].innerText), U = O.length - (x2 - D.activePageNumber) - 1, F = O[U], W = O.length - (x2 - w2) - 1;
      return F ? (F.classList.remove(D.styles.pageButtons.activeButtonClass), { previousActiveButton: F, previousLocationOfNewIndex: W }) : { previousLocationOfNewIndex: W };
    }
    // prettier-ignore
    static setActive(D, w2) {
      const { _pagination: O } = D, { styles: { pageButtons: x2 }, clickedPageNumberButton: U } = O, { previousActiveButton: F, previousLocationOfNewIndex: W } = ke.unsetPreviousActive(
        O,
        w2
      );
      PaginationVisibleButtonsUtils.unsetStateAndStyles(D._pagination), O.activePageNumber = w2, PaginationUpdatePageButtons.updateOnNewActive(D);
      const { newActiveButton: G, numberButtons: X } = ke.setNewActive(O, w2);
      PageButtonStyle.setActive(G, x2, F), PaginationPageActionButtonUtils.toggleActionButtons(D), PaginationVisibleButtonsUtils.setStateAndStyles(D), U && ke.programmaticMouseEnterTrigger(X, O, W);
    }
    static create(D, w2) {
      const O = document.createElement("div");
      return O.classList.add(
        ke.PAGINATION_BUTTON_CLASS,
        PaginationElements.PAGINATION_TEXT_COMPONENT_CLASS,
        GenericElementUtils.NOT_SELECTABLE_CLASS
      ), PageButtonStyle.setDefault(O, D, w2), setTimeout(() => PageButtonEvents.setEvents(O, D, w2)), O;
    }
  };
  _PageButtonElement.PAGINATION_BUTTON_CLASS = "pagination-button";
  _PageButtonElement.DISABLED_PAGINATION_BUTTON_CLASS = "pagination-button-disabled";
  _PageButtonElement.ACTIVE_PAGINATION_BUTTON_CLASS = "pagination-button-active";
  _PageButtonElement.PRECEDENCE_ACTIVE_PAGINATION_BUTTON_CLASS = "pagination-button-active-precedence";
  var PageButtonElement = _PageButtonElement;
  var _PaginationVisibleButtonsUtils = class ie {
    static getRightBorderWidthInStyleOverride(D) {
      return D.borderRightWidth ? Number.parseInt(D.borderRightWidth) : D.borderRight ? Number.parseInt(D.borderRight.split(" ")[0]) : -1;
    }
    // if the last button is active page (no action buttons displayed) and it has precedence, the override right border
    // will not take place and it will either have no right border or active style right border:
    // this is problematic as the border difference will cause the entire container to have a different width
    // which will in turn cause the pagination components to shift when the last button is clicked,
    // to prevent this we add the border style that would have been overriden
    static setBorderPaddingForLastPrecedence(D, w2) {
      const O = ie.getRightBorderWidthInStyleOverride(w2);
      if (isNaN(O) || O === 0)
        return;
      const x2 = Number.parseInt(getComputedStyle(D).borderRightWidth);
      x2 > 0 ? D.style.borderRightWidth = `${x2 + O}px` : D.style.borderRight = `${O}px solid #fafafa01`;
    }
    static setStyle(D, w2, O, x2) {
      if (!x2)
        return;
      const U = new Set(Object.keys(x2)), F = D.classList.contains(PageButtonElement.PRECEDENCE_ACTIVE_PAGINATION_BUTTON_CLASS);
      F && w2.forEach((W) => U.delete(W)), U.forEach((W) => {
        ElementStyle.setStyle(D, W, x2[W]);
      }), O && F && ie.setBorderPaddingForLastPrecedence(D, x2);
    }
    // prettier-ignore
    static overrideOnMouseEvent(D, w2) {
      const { firstVisibleButtonOverride: O, lastVisibleButtonOverride: x2 } = w2;
      D.classList.contains(ie.FIRST_VISIBLE_CLASS) && ie.setStyle(
        D,
        ie.FIRST_PRECEDENCE_VALUES,
        false,
        O
      ), D.classList.contains(ie.LAST_VISIBLE_CLASS) && ie.setStyle(
        D,
        ie.LAST_PRECEDENCE_VALUES,
        true,
        x2
      );
    }
    // prettier-ignore
    static unsetStateAndStyles(D) {
      const {
        styles: { pageButtons: { firstVisibleButtonOverride: w2, lastVisibleButtonOverride: O } },
        visibleEdgeButtons: x2
      } = D;
      x2.length !== 0 && (w2 && ElementStyle.unsetStyle(x2[0], w2), x2[0].classList.remove(ie.FIRST_VISIBLE_CLASS), O && ElementStyle.unsetStyle(x2[1], O), x2[1].classList.remove(ie.LAST_VISIBLE_CLASS), D.visibleEdgeButtons = []);
    }
    // when the button display property is false - clientWidth is 0
    static isButtonVisible(D) {
      return D.clientWidth > 0 && D.style.visibility !== "hidden";
    }
    // prettier-ignore
    static set(D, w2, O) {
      const { styles: { pageButtons: { firstVisibleButtonOverride: x2, lastVisibleButtonOverride: U } } } = O, F = D[w2];
      if (!F)
        return;
      F.classList.contains(ie.FIRST_VISIBLE_CLASS) || (ie.setStyle(
        F,
        ie.FIRST_PRECEDENCE_VALUES,
        false,
        x2
      ), F.classList.add(ie.FIRST_VISIBLE_CLASS));
      const W = D.findLastIndex(ie.isButtonVisible), G = D[W];
      G.classList.contains(ie.LAST_VISIBLE_CLASS) || (ie.setStyle(
        G,
        ie.LAST_PRECEDENCE_VALUES,
        true,
        U
      ), G.classList.add(ie.LAST_VISIBLE_CLASS)), O.visibleEdgeButtons = [F, G];
    }
    static setStateAndStyles(D) {
      const { _pagination: w2, displayAddNewRow: O } = D, x2 = Array.from(w2.buttonContainer.children), U = x2.findIndex(ie.isButtonVisible);
      U === -1 ? setTimeout(() => {
        const F = x2.findIndex(ie.isButtonVisible);
        ie.set(x2, F, w2);
      }) : ie.set(x2, U, w2), O || RowElement.toggleLastRowClass(D);
    }
  };
  _PaginationVisibleButtonsUtils.FIRST_VISIBLE_CLASS = "pagination-first-visible-button";
  _PaginationVisibleButtonsUtils.LAST_VISIBLE_CLASS = "pagination-last-visible-button";
  _PaginationVisibleButtonsUtils.FIRST_PRECEDENCE_VALUES = ["borderLeft", "borderLeftWidth", "borderLeftColor"];
  _PaginationVisibleButtonsUtils.LAST_PRECEDENCE_VALUES = ["borderRight", "borderRightWidth", "borderRightColor"];
  var PaginationVisibleButtonsUtils = _PaginationVisibleButtonsUtils;
  function buildIcon$1(Y) {
    return `<?xml version="1.0" encoding="utf-8"?>
    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="transform: ${Y}">
      <path d="M5.5 5L11.7929 11.2929C12.1834 11.6834 12.1834 12.3166 11.7929 12.7071L5.5 19" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>`;
  }
  var PREVIOUS_PAGE_ICON_SVG_STRING = buildIcon$1("rotate(180deg)");
  var NEXT_PAGE_ICON_SVG_STRING = buildIcon$1("");
  var PreviousPageButtonEvents = class _PreviousPageButtonEvents {
    static buttonMouseUp(D) {
      const { activePageNumber: w2, styles: O } = this._pagination;
      if (w2 === 1)
        return;
      PaginationUtils.getAndApplyDataOnButtonClick(this, w2 - 1);
      const x2 = D.target;
      PageButtonStyle.mouseEnter(x2, O.pageButtons, true);
    }
    static setEvents(D, w2) {
      w2.onmouseup = _PreviousPageButtonEvents.buttonMouseUp.bind(D);
    }
  };
  var PreviousPageButtonElement = class _PreviousPageButtonElement {
    static populate(D, w2) {
      if (w2)
        D.innerHTML = String(w2);
      else {
        const O = SVGIconUtils.createSVGElement(PREVIOUS_PAGE_ICON_SVG_STRING);
        O.classList.add("pagination-prev-next-button"), D.appendChild(O);
      }
    }
    static create(D) {
      const { pageButtons: w2 } = D._pagination.styles, O = PageButtonElement.create(w2, true);
      return _PreviousPageButtonElement.populate(O, w2.actionButtons.previousText), setTimeout(() => PreviousPageButtonEvents.setEvents(D, O)), O;
    }
  };
  function buildIcon(Y) {
    return `<?xml version="1.0" encoding="utf-8"?>
    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="transform: ${Y}">
      <path d="M5.5 5L11.7929 11.2929C12.1834 11.6834 12.1834 12.3166 11.7929 12.7071L5.5 19" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="M13.5 5L19.7929 11.2929C20.1834 11.6834 20.1834 12.3166 19.7929 12.7071L13.5 19" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>`;
  }
  var FIRST_PAGE_ICON_SVG_STRING = buildIcon("rotate(180deg)");
  var LAST_PAGE_ICON_SVG_STRING = buildIcon("");
  var FirstPageButtonEvents = class _FirstPageButtonEvents {
    static buttonMouseUp(D) {
      const w2 = D.target;
      PageButtonStyle.mouseEnter(w2, this._pagination.styles.pageButtons, true), this._pagination.activePageNumber !== 1 && PaginationUtils.getAndApplyDataOnButtonClick(this, 1);
    }
    static setEvents(D, w2) {
      w2.onmouseup = _FirstPageButtonEvents.buttonMouseUp.bind(D);
    }
  };
  var FirstPageButtonElement = class _FirstPageButtonElement {
    static populate(D, w2) {
      if (w2)
        D.innerHTML = String(w2);
      else {
        const O = SVGIconUtils.createSVGElement(FIRST_PAGE_ICON_SVG_STRING);
        O.classList.add("pagination-first-last-button"), D.appendChild(O);
      }
    }
    static create(D) {
      const { pageButtons: w2 } = D._pagination.styles, O = PageButtonElement.create(w2, true);
      return _FirstPageButtonElement.populate(O, w2.actionButtons.firstText), setTimeout(() => FirstPageButtonEvents.setEvents(D, O)), O;
    }
  };
  var LastPageButtonEvents = class _LastPageButtonEvents {
    static buttonMouseUp(D) {
      const w2 = D.target, { activePageNumber: O, styles: x2 } = this._pagination;
      PageButtonStyle.mouseEnter(w2, x2.pageButtons, true);
      const U = PaginationUtils.getLastPossiblePageNumber(this);
      U <= O || PaginationUtils.getAndApplyDataOnButtonClick(this, U);
    }
    static setEvents(D, w2) {
      w2.onmouseup = _LastPageButtonEvents.buttonMouseUp.bind(D);
    }
  };
  var LastPageButtonElement = class _LastPageButtonElement {
    static populate(D, w2) {
      if (w2)
        D.innerHTML = String(w2);
      else {
        const O = SVGIconUtils.createSVGElement(LAST_PAGE_ICON_SVG_STRING);
        O.classList.add("pagination-first-last-button"), D.appendChild(O);
      }
    }
    static create(D) {
      const { pageButtons: w2 } = D._pagination.styles, O = PageButtonElement.create(w2, true);
      return _LastPageButtonElement.populate(O, w2.actionButtons.lastText), setTimeout(() => LastPageButtonEvents.setEvents(D, O)), O;
    }
  };
  var NextPageButtonEvents = class _NextPageButtonEvents {
    static buttonMouseUp(D) {
      const { activePageNumber: w2, styles: O } = this._pagination;
      if (PaginationUtils.getLastPossiblePageNumber(this) <= w2)
        return;
      PaginationUtils.getAndApplyDataOnButtonClick(this, w2 + 1);
      const x2 = D.target;
      PageButtonStyle.mouseEnter(x2, O.pageButtons, true);
    }
    static setEvents(D, w2) {
      w2.onmouseup = _NextPageButtonEvents.buttonMouseUp.bind(D);
    }
  };
  var NextPageButtonElement = class _NextPageButtonElement {
    static populate(D, w2) {
      if (w2)
        D.innerHTML = String(w2);
      else {
        const O = SVGIconUtils.createSVGElement(NEXT_PAGE_ICON_SVG_STRING);
        O.classList.add("pagination-prev-next-button"), D.appendChild(O);
      }
    }
    static create(D) {
      const { pageButtons: w2 } = D._pagination.styles, O = PageButtonElement.create(w2, true);
      return _NextPageButtonElement.populate(O, w2.actionButtons.nextText), setTimeout(() => NextPageButtonEvents.setEvents(D, O)), O;
    }
  };
  var PageButtonContainerEvents = class _PageButtonContainerEvents {
    // REF-31
    static containerMouseLeave(D) {
      const { clickedPageNumberButton: w2, programaticallyHoveredPageNumberButton: O, styles: x2 } = D;
      w2 && O && PageButtonStyle.mouseLeave(O, x2.pageButtons, false);
    }
    static setEvents(D, w2) {
      D.onmouseleave = _PageButtonContainerEvents.containerMouseLeave.bind(this, w2);
    }
  };
  var _PageButtonContainerElement = class fe {
    static shouldButtonsBeActive(D) {
      const w2 = D.dataStartsAtHeader ? 1 : 2;
      return D.data.length >= w2;
    }
    static setStyle(D, w2) {
      fe.shouldButtonsBeActive(D) ? PageButtonElement.setActive(D, w2 ?? 1) : PageButtonElement.setDisabled(D._pagination);
    }
    static addNumberButtons(D) {
      const w2 = PaginationUtils.getLastPossiblePageNumber(D), { maxNumberOfVisiblePageButtons: O, buttonContainer: x2 } = D._pagination;
      for (let U = 0; U < Math.min(w2, O); U += 1) {
        const F = PageNumberButtonElement.create(D, U + 1);
        x2.appendChild(F);
      }
    }
    static addButton(D, w2) {
      D.buttonContainer.appendChild(w2), D.numberOfActionButtons += 1;
    }
    static addButtons(D) {
      const { displayPrevNext: w2, displayFirstLast: O } = D._pagination;
      O && fe.addButton(D._pagination, FirstPageButtonElement.create(D)), w2 && fe.addButton(D._pagination, PreviousPageButtonElement.create(D)), fe.addNumberButtons(D), w2 && fe.addButton(D._pagination, NextPageButtonElement.create(D)), O && fe.addButton(D._pagination, LastPageButtonElement.create(D));
    }
    static resetState(D) {
      D.activePageNumber = 1, D.numberOfActionButtons = 0, D.visibleEdgeButtons = [];
    }
    static repopulateButtons(D) {
      fe.resetState(D._pagination), D._pagination.buttonContainer.replaceChildren(), fe.addButtons(D), fe.setStyle(D);
    }
    static addInitialElements(D, w2) {
      fe.repopulateButtons(D), PaginationVisibleButtonsUtils.setStateAndStyles(D);
      const { positions: O, buttonContainer: x2 } = D._pagination;
      OuterContainerElements.addToContainer(O.pageButtons.position, w2, x2);
    }
    static create(D) {
      const w2 = document.createElement("div");
      w2.id = fe.PAGINATION_BUTTON_CONTAINER_ID;
      const { styles: O, positions: x2 } = D._pagination;
      return w2.style.order = String(x2.pageButtons.order), Object.assign(w2.style, O.pageButtons.container), PageButtonContainerEvents.setEvents(w2, D._pagination), w2;
    }
  };
  _PageButtonContainerElement.PAGINATION_BUTTON_CONTAINER_ID = "pagination-button-container";
  var PageButtonContainerElement = _PageButtonContainerElement;
  var InitialDataProcessing = class _InitialDataProcessing {
    static cleanupDataThatDidNotGetAdded(D, w2) {
      var O;
      ((O = D[0]) == null ? void 0 : O.length) - w2.length > 0 && D.forEach((x2) => x2.splice(w2.length)), w2.length === 0 ? D.splice(0, D.length) : D.length > w2[0].elements.length && D.splice(w2[0].elements.length);
    }
    static postProcess(D, w2) {
      setTimeout(() => _InitialDataProcessing.cleanupDataThatDidNotGetAdded(D, w2));
    }
    static fillRow(D, w2) {
      const O = new Array(w2 - D.length).fill(EMPTY_STRING);
      D.splice(D.length, w2 - D.length, ...O);
    }
    static processRowDataByLength(D, w2) {
      w2 === 0 && D.splice(0, D.length), D.forEach((O) => {
        O.length < w2 && _InitialDataProcessing.fillRow(O, w2);
      });
    }
    static getMaxRowLength(D) {
      return D.reduce((w2, O) => Math.max(w2, O.length), 0);
    }
    static removeRowsExceedingLimit(D, w2) {
      w2 !== void 0 && w2 > 0 && D.length > w2 && D.splice(w2, D.length - 1);
    }
    static removeDuplicateHeaders(D, w2) {
      const O = D[0];
      O.reduce((x2, U, F) => (x2.has(U) ? O[F] = w2 || "" : x2.add(U), x2), /* @__PURE__ */ new Set());
    }
    static preProcess(D, w2) {
      const { maxRows: O, allowDuplicateHeaders: x2, _defaultColumnsSettings: U } = D;
      _InitialDataProcessing.removeRowsExceedingLimit(w2, O);
      const F = _InitialDataProcessing.getMaxRowLength(w2);
      _InitialDataProcessing.processRowDataByLength(w2, F), !x2 && w2.length > 0 && _InitialDataProcessing.removeDuplicateHeaders(w2, U.defaultText);
    }
  };
  var PaginationAsyncStartData = class _PaginationAsyncStartData {
    static fillTotalDataRows(D, w2) {
      var F;
      const { totalDataRows: O, data: x2, failed: U } = w2;
      if (D.data.length < O || U) {
        const W = Math.max(((F = D.data[0]) == null ? void 0 : F.length) || 0, InitialDataProcessing.getMaxRowLength(x2)), G = +!D.dataStartsAtHeader, X = new Array(O - D.data.length + G).fill(
          new Array(W).fill(EMPTY_STRING)
        ), K = D.data.length;
        D.data.splice(D.data.length, 0, ...X), X.forEach((q, Q) => {
          const le = InsertNewRow.insertNewRow(D, K + Q, false, q);
          setTimeout(() => {
            UpdateCellsForRows.updateRowCells(D, le, K + Q, CELL_UPDATE_TYPE.UPDATE, false);
          });
        }), PageButtonContainerElement.repopulateButtons(D);
      }
    }
    static populate(D, w2) {
      const { data: O, totalDataRows: x2, failed: U } = w2;
      O.length > 0 && x2 > 0 && (D.data.length > 0 || InitialDataProcessing.getMaxRowLength(O) > 0) && (_PaginationAsyncStartData.fillTotalDataRows(D, w2), U || PaginationAsyncUtils.insertData(D, O, 1));
    }
    static async get(D, w2, O) {
      const { async: x2, rowsPerPage: U } = w2;
      if (!x2)
        return;
      const { rowsPerPage: F } = O, W = typeof U == "number" ? U : F;
      try {
        const [G, X] = await Promise.all([x2.getTotalRows(), x2.getPageData(1, W)]);
        return { totalDataRows: G, data: X };
      } catch (G) {
        return setTimeout(() => PaginationAsyncUtils.displayError(G, D)), { totalDataRows: 0, data: [["", ""]], failed: true };
      }
    }
  };
  var FrameComponentsElements = class {
    // index and add column cells are added on row insertion
    // CAUTION-4
    static addFrameBodyElements(D) {
      var w2, O;
      (O = D._tableBodyElementRef) == null || O.appendChild((w2 = D._addRowCellElementRef) == null ? void 0 : w2.parentElement), ToggleAdditionElements.update(D, true, AddNewRowElement.toggle);
    }
  };
  var _SheetJSInternalUtils = class Dt {
    // REF-17
    static async execFuncWithExtractorModule(D) {
      const w2 = window.XLSX;
      w2 ? D(w2) : console.error(Dt.MODULE_NOT_FOUND_ERROR);
    }
  };
  _SheetJSInternalUtils.MODULE_NOT_FOUND_ERROR = "xlsx module was not found";
  var SheetJSInternalUtils = _SheetJSInternalUtils;
  var UpdateAllTableData = class _UpdateAllTableData {
    static toggleAdditionalElements(D) {
      FilterInternalUtils.completeReset(D), ToggleAdditionElements.update(D, true, AddNewRowElement.toggle), setTimeout(() => {
        D._pagination && D._pagination.activePageNumber !== 1 && PaginationUtils.displayRowsForDifferentButton(D, 1);
      });
    }
    static insertData(D, w2, O) {
      InsertMatrix.insert(D, w2, O, 0, true), O === 0 && RootCellElement.convertFromRootCell(D);
    }
    static changeTableData(D, w2, O, x2) {
      for (let U = D.data.length - 1; U >= O; U -= 1)
        RemoveRow.remove(D, U);
      InitialDataProcessing.preProcess(D, w2), D._isPopulatingTable = true, x2 ? (_UpdateAllTableData.insertData(D, w2, O), _UpdateAllTableData.toggleAdditionalElements(D), D._isPopulatingTable = true) : (setTimeout(() => {
        _UpdateAllTableData.insertData(D, w2, O);
      }), setTimeout(() => {
        _UpdateAllTableData.toggleAdditionalElements(D), D._isPopulatingTable = true;
      }, 6));
    }
    static update(D, w2, O, x2 = false) {
      if (!Array.isArray(w2))
        return;
      let U = false;
      D._visiblityInternal.filters && (U = FilterInternalUtils.unsetAllFilters(D)), !x2 && U ? setTimeout(() => _UpdateAllTableData.changeTableData(D, w2, O, x2), 40) : _UpdateAllTableData.changeTableData(D, w2, O, x2);
    }
  };
  var CSVImport = class _CSVImport {
    static getPaddedArray(D, w2) {
      return D.map((O) => O.concat(Array(w2).fill("")).slice(0, w2));
    }
    static splitRow(D) {
      const w2 = /("[^"]*"|[^,]+)(,|$)/g, O = [];
      return D.replace(w2, (x2, U) => (O.push(U), "")), O;
    }
    static parseDataFromRow(D, w2, O) {
      const x2 = _CSVImport.splitRow(D);
      return x2.length > 0 && (w2.push(x2), x2.length > O && (O = x2.length)), O;
    }
    // TO-DO validation and error handling
    static parseCSV(D) {
      try {
        const w2 = D.split(/\r\n|\n/), O = [];
        let x2 = 0;
        return w2.forEach((U) => {
          x2 = _CSVImport.parseDataFromRow(U, O, x2);
        }), _CSVImport.getPaddedArray(O, x2);
      } catch {
        return console.error("Incorrect format"), null;
      }
    }
    static getStartRowIndex(D, w2) {
      return w2 && typeof w2.tableRowStartIndex == "number" ? w2.tableRowStartIndex < 0 || w2.tableRowStartIndex > D ? D : w2.tableRowStartIndex : 0;
    }
    static processFile(D, w2, O) {
      const x2 = _CSVImport.parseCSV(w2);
      if (x2 && O && typeof O.importRowStartIndex == "number" && x2.splice(0, O.importRowStartIndex), !x2 || x2.length === 0)
        return;
      const U = _CSVImport.getStartRowIndex(D.data.length, O);
      UpdateAllTableData.update(D, x2, U);
    }
    static import(D, w2, O) {
      const x2 = new FileReader();
      x2.readAsText(w2), x2.onload = (U) => {
        var F;
        return _CSVImport.processFile(D, (F = U.target) == null ? void 0 : F.result, O);
      };
    }
  };
  var SheetJSImport = class {
    static import(D, w2, O) {
      const x2 = new FileReader();
      x2.readAsBinaryString(w2), x2.onload = (U) => {
        var W;
        const F = O.read((W = U.target) == null ? void 0 : W.result, { type: "binary" });
        F.SheetNames.forEach((G) => {
          const X = O.utils.sheet_to_csv(F.Sheets[G]);
          CSVImport.processFile(D, X);
        });
      };
    }
  };
  var ACCEPTED_FILE_FORMATS = ["csv", "xls", "xlsx", "ods", "txt"];
  var DEFAULT_FILE_FORMATS = ["csv"];
  var FileImportButtonEvents = class _FileImportButtonEvents {
    static importFile(D, w2, O, x2) {
      O.find((U) => w2.name.endsWith(U)) && (w2.name.endsWith(".csv") ? CSVImport.import(D, w2, x2) : SheetJSInternalUtils.execFuncWithExtractorModule(SheetJSImport.import.bind(this, D, w2)));
    }
    static inputChange(D, w2, O) {
      var F;
      const x2 = O.target, U = (F = x2.files) == null ? void 0 : F[0];
      _FileImportButtonEvents.importFile(D, U, ACCEPTED_FILE_FORMATS, w2), x2.value = "";
    }
    static getAcceptedFormats(D) {
      return D != null && D.formats && D.formats.length > 0 ? D.formats : DEFAULT_FILE_FORMATS;
    }
    static triggerImportPrompt(D, w2) {
      const O = D._files.inputElementRef, x2 = _FileImportButtonEvents.getAcceptedFormats(w2);
      O.accept = x2.map((U) => `.${U}`).join(","), O.onchange = _FileImportButtonEvents.inputChange.bind(this, D, w2 == null ? void 0 : w2.overwriteOptions), O.click();
    }
    static setEvents(D, w2, O) {
      w2.onclick = _FileImportButtonEvents.triggerImportPrompt.bind(this, D, O);
    }
  };
  var DragAndDropEvents = class _DragAndDropEvents {
    static async uploadFile(D, w2, O) {
      var F, W, G;
      const x2 = (W = (F = O.dataTransfer) == null ? void 0 : F.files) == null ? void 0 : W[0], U = typeof ((G = D.files) == null ? void 0 : G.dragAndDrop) == "object" ? D.files.dragAndDrop.overwriteOptions : void 0;
      FileImportButtonEvents.importFile(D, x2, w2, U);
    }
    static toggleOverlayElement(D, w2) {
      D.style.display = w2 ? "block" : "none";
    }
    static getAcceptedFileFormats(D) {
      var O;
      if (typeof (D == null ? void 0 : D.dragAndDrop) == "object" && D.dragAndDrop.formats)
        return D.dragAndDrop.formats;
      const w2 = (O = D == null ? void 0 : D.buttons) == null ? void 0 : O.filter((x2) => x2.import).map((x2) => typeof x2.import == "object" && x2.import.formats ? x2.import.formats : DEFAULT_FILE_FORMATS).flat(1);
      return w2 && w2.length > 0 ? Array.from(new Set(w2)) : DEFAULT_FILE_FORMATS;
    }
    static setEvents(D, w2, O) {
      const x2 = _DragAndDropEvents.getAcceptedFileFormats(D.files);
      w2.ondragenter = (U) => {
        U.preventDefault(), _DragAndDropEvents.toggleOverlayElement(O, true);
      }, O.ondragleave = (U) => {
        U.preventDefault(), _DragAndDropEvents.toggleOverlayElement(O, false);
      }, O.ondragover = (U) => {
        U.preventDefault();
      }, O.ondrop = (U) => {
        U.preventDefault(), _DragAndDropEvents.uploadFile(D, x2, U), _DragAndDropEvents.toggleOverlayElement(O, false);
      };
    }
  };
  var DragAndDropElement = class _DragAndDropElement {
    static createOverlayElement(D) {
      const w2 = document.createElement("div");
      return w2.id = "drag-and-drop-overlay", typeof D.dragAndDrop == "object" && Object.assign(w2.style, D.dragAndDrop.overlayStyle), w2;
    }
    static append(D, w2) {
      const O = _DragAndDropElement.createOverlayElement(D.files);
      DragAndDropEvents.setEvents(D, w2, O), w2.appendChild(O);
    }
    static isEnabled(D) {
      var w2;
      return (D == null ? void 0 : D.dragAndDrop) !== void 0 ? !!D.dragAndDrop : !!((w2 = D == null ? void 0 : D.buttons) != null && w2.find((O) => O.import));
    }
  };
  var _StickyPropsUtils = class vt {
    static process(D) {
      var w2;
      typeof D.stickyHeader == "boolean" ? D._stickyProps.header = D.stickyHeader : (w2 = D.overflow) != null && w2.maxHeight && (D._stickyProps.header = true);
    }
    // REF-37
    // prettier-ignore
    static moveTopBorderToHeaderCells(D) {
      const { _tableElementRef: w2, _tableBodyElementRef: O } = D;
      !w2 || !O || (O.classList.add(vt.NO_OVERFLOW_STICKY_HEADER_BODY_CLASS), w2.style.border && (O.style.borderTop = w2.style.border), w2.style.borderColor && (O.style.borderTopColor = w2.style.borderColor), ElementStyle.moveStyles(
        w2,
        O,
        "borderTop",
        "borderTopColor",
        "borderTopWidth",
        "borderTopStyle"
      ), w2.style.borderTop = "unset");
    }
  };
  _StickyPropsUtils.NO_OVERFLOW_STICKY_HEADER_BODY_CLASS = "no-overflow-sticky-header-body";
  var StickyPropsUtils = _StickyPropsUtils;
  var ColumnSizerSetWidth = class _ColumnSizerSetWidth {
    static getWidthDelta(D, w2) {
      return D < w2.left ? w2.left : D > w2.right ? w2.right : D;
    }
    static getNewColumnWidth(D, w2) {
      const { moveLimits: O, mouseMoveOffset: x2, initialOffset: U } = D, F = _ColumnSizerSetWidth.getWidthDelta(x2, O) - U;
      return Math.max(0, Number.parseFloat(w2.style.width) + F);
    }
    static setColumnWidth(D, w2) {
      const O = _ColumnSizerSetWidth.getNewColumnWidth(D, w2);
      w2.style.width = `${O}px`;
    }
    // when the user moves the sizer to the start/end of a column in an attempt to completely crush the column,
    // the dom will not allow that and will leave enough space for the column to display its text,
    // the problem is that the widths will be set incorrectly and need to be corrected
    // prettier-ignore
    static correctWidths(D, w2, O, x2) {
      if (w2.offsetWidth !== Math.round(Number.parseFloat(w2.style.width))) {
        const U = `${w2.offsetWidth}px`, F = `${x2 - w2.offsetWidth}px`;
        w2.style.width = U, O.style.width = F, D.wasAutoresized = true, setTimeout(() => D.wasAutoresized = false);
      }
    }
    // prettier-ignore
    static setWidths(D, w2, O, x2) {
      const U = _ColumnSizerSetWidth.getNewColumnWidth(D, w2), F = Math.max(0, x2 - U);
      w2.style.width = `${U}px`, O.style.width = `${F}px`;
    }
    // prettier-ignore
    static setColumnsWidths(D, w2, O) {
      const x2 = Number.parseFloat(w2.style.width), U = Number.parseFloat(O.style.width), F = x2 + U;
      _ColumnSizerSetWidth.setWidths(D, w2, O, F), U > x2 ? _ColumnSizerSetWidth.correctWidths(D, w2, O, F) : _ColumnSizerSetWidth.correctWidths(D, O, w2, F);
    }
    // left or right header in respect to the position of the sizer element
    // prettier-ignore
    static set(D, w2, O, x2, U) {
      U && StaticTable.isStaticTableWidth(w2, O) ? _ColumnSizerSetWidth.setColumnsWidths(D, x2, U) : _ColumnSizerSetWidth.setColumnWidth(D, x2), setTimeout(() => D.fireColumnsUpdate());
    }
  };
  var ColumnSizerExtrinsicEvents = class _ColumnSizerExtrinsicEvents {
    static moveMovableElement(D, w2, O) {
      const { columnSizer: x2 } = ColumnSizerGenericUtils.getSizerDetailsViaElementId(D.id, w2);
      x2.movableElement.style.left = `${O}px`;
    }
    // prettier-ignore
    static windowMouseMove(D, w2) {
      const { _activeOverlayElements: { selectedColumnSizer: O }, _columnsDetails: x2 } = D;
      if (O) {
        const { moveLimits: U, element: F } = O;
        O.mouseMoveOffset += w2, O.mouseMoveOffset >= U.left && O.mouseMoveOffset <= U.right && _ColumnSizerExtrinsicEvents.moveMovableElement(F, x2, O.mouseMoveOffset);
      }
    }
    // prettier-ignore
    static setWidth(D, w2, O, x2, U) {
      ColumnSizerElement.unsetTransitionTime(D.element), ColumnSizerSetWidth.set(D, w2, O, x2, U);
    }
    // prettier-ignore
    static mouseUp(D) {
      var K;
      const { _activeOverlayElements: w2, _columnsDetails: O, _tableDimensions: x2, _tableElementRef: U } = D, F = w2.selectedColumnSizer, { columnSizer: W, headerCell: G, sizerNumber: X } = ColumnSizerGenericUtils.getSizerDetailsViaElementId(
        F.element.id,
        O
      );
      _ColumnSizerExtrinsicEvents.setWidth(
        F,
        U,
        x2,
        G,
        ColumnSizerGenericUtils.findNextResizableColumnHeader(O, X)
      ), MovableColumnSizerElement.hide(W.movableElement), UpdateRowElement.updateHeaderRowHeight((K = W.element.parentElement) == null ? void 0 : K.parentElement);
    }
    static setSizerStyleToHoverNoAnimation(D, w2) {
      const { width: O } = D.styles.hover;
      ColumnSizerElement.setHoverStyle(D, O, false, w2), ColumnSizerElement.unsetBackgroundImage(D.element);
    }
    static mouseUpNotOnSizer(D) {
      const { element: w2, styles: O, movableElement: x2 } = D;
      _ColumnSizerExtrinsicEvents.setSizerStyleToHoverNoAnimation(D, x2.style.backgroundColor), setTimeout(() => {
        ColumnSizerElement.setTransitionTime(w2), ColumnSizerElement.unsetElementsToDefault(w2, O.default.width, false), ColumnSizerElement.hideWhenCellNotHovered(D, true);
      }), setTimeout(() => {
        ColumnSizerElement.setBackgroundImage(w2, O.default.backgroundImage), ColumnSizerElement.setBackgroundColor(w2, SEMI_TRANSPARENT_COLOR);
      }, ColumnSizerElement.TRANSITION_TIME_ML);
    }
    // if the user clicks mouse up on the table first - this will not be activated as columnSizer selected will be removed
    // prettier-ignore
    static windowMouseUp(D) {
      const { columnSizer: w2 } = ColumnSizerGenericUtils.getSizerDetailsViaElementId(
        D._activeOverlayElements.selectedColumnSizer.element.id,
        D._columnsDetails
      );
      _ColumnSizerExtrinsicEvents.mouseUp(D), _ColumnSizerExtrinsicEvents.mouseUpNotOnSizer(w2), delete D._activeOverlayElements.selectedColumnSizer;
    }
    static mouseUpOnSizer(D) {
      _ColumnSizerExtrinsicEvents.setSizerStyleToHoverNoAnimation(D), D.isMouseUpOnSizer = true, setTimeout(() => {
        D.isMouseUpOnSizer = false, ColumnSizerElement.setTransitionTime(D.element);
      });
    }
    // this method is used to get what exact element was clicked on as window events just returns the component as the target
    // prettier-ignore
    static tableMouseUp(D, w2) {
      const O = D._activeOverlayElements.selectedColumnSizer, { columnSizer: x2 } = ColumnSizerGenericUtils.getSizerDetailsViaElementId(
        O.element.id,
        D._columnsDetails
      );
      _ColumnSizerExtrinsicEvents.mouseUp(D), MovableColumnSizerElement.isMovableColumnSizer(w2) && !O.wasAutoresized ? _ColumnSizerExtrinsicEvents.mouseUpOnSizer(x2) : _ColumnSizerExtrinsicEvents.mouseUpNotOnSizer(x2), delete D._activeOverlayElements.selectedColumnSizer;
    }
  };
  var TableEvents = class _TableEvents {
    // not using hoveredElements state as the targetElement will be the element clicked, hence need to use
    // activeOverlayElements.datePickerCell to get the cell of the date picker input
    static closeDatePicker(D, w2) {
      D.datePickerCell && (D.datePickerCell !== CellElement.getCellElement(w2) && DateCellInputElement.toggle(D.datePickerCell, false), delete D.datePickerCell);
    }
    // REF-44
    // text blur will not activate when the dropdown has been clicked and will not close if its scrollbar, padding
    // or delete category buttons are clicked. If the user clicks elsewhere on the table, the dropdown is closed
    // programmatically as follows
    // prettier-ignore
    static closeCellDropdown(D, w2) {
      const { _focusedElements: O } = D;
      O.cellDropdown && !Dropdown.isPartOfDropdownElement(w2) && !w2.classList.contains(OptionColorButton.COLOR_BUTTON_CLASS) && O.cell.element !== CellElement.getCellElement(w2) && CellWithTextEvents.programmaticBlur(D);
    }
    static onMouseDown(D) {
      const w2 = D.target;
      UserKeyEventsStateUtils.temporarilyIndicateEvent(this._userKeyEventsState, MOUSE_EVENT.DOWN), _TableEvents.closeCellDropdown(this, w2), _TableEvents.closeDatePicker(this._activeOverlayElements, D.target);
    }
    static onMouseUp(D) {
      this._activeOverlayElements.selectedColumnSizer && ColumnSizerExtrinsicEvents.tableMouseUp(this, D.target);
    }
  };
  var TableElement = class _TableElement {
    static changeStaticWidthTotal(D, w2) {
      D.staticWidth += w2;
    }
    // prettier-ignore
    static setStaticWidthContentTotal(D) {
      const { _frameComponents: { displayAddNewColumn: w2, displayIndexColumn: O }, _tableDimensions: x2 } = D;
      x2.staticWidth = x2.border.leftWidth + x2.border.rightWidth, w2 && (x2.staticWidth += AddNewColumnElement.DEFAULT_WIDTH), O && (x2.staticWidth += IndexColumn.DEFAULT_WIDTH);
    }
    // prettier-ignore
    static addOverlayElements(D, w2, O) {
      var W;
      const x2 = FullTableOverlayElement.create(D);
      O.fullTableOverlay = x2;
      const U = ((W = D._overflow) == null ? void 0 : W.overflowContainer) || w2;
      U.appendChild(x2), DragAndDropElement.isEnabled(D.files) && DragAndDropElement.append(D, U);
      const F = ColumnDropdown.create(D);
      if (w2.appendChild(F), O.columnDropdown = F, D.rowDropdown.displaySettings.isAvailable) {
        const G = RowDropdown.create(D);
        w2.appendChild(G), O.rowDropdown = G;
      }
    }
    static addCells(D) {
      MaximumColumns.canAddMore(D) && (StaticTableWidthUtils.toggleWidthUsingMaxWidth(D, true), D.data.map((w2, O) => InsertNewRow.insert(D, O, false, w2)), D._pagination.asyncStartData && PaginationAsyncStartData.populate(D, D._pagination.asyncStartData), StaticTableWidthUtils.toggleWidthUsingMaxWidth(D, false));
    }
    static postProcessColumns(D) {
      StaticTableWidthUtils.changeWidthsBasedOnColumnInsertRemove(D, true), InitialDataProcessing.postProcess(D.data, D._columnsDetails), setTimeout(() => {
        FireEvents.onColumnsUpdate(D), InsertRemoveColumnSizer.cleanUpCustomColumnSizers(D, D._columnsDetails.length - 1);
      });
    }
    static populateBody(D) {
      var w2;
      (w2 = D._tableBodyElementRef) == null || w2.replaceChildren(), StaticTableWidthUtils.setTableWidth(D), _TableElement.addCells(D), _TableElement.postProcessColumns(D), FrameComponentsElements.addFrameBodyElements(D), D._frameComponents.displayIndexColumn && UpdateIndexColumnWidth.update(D), ToggleAdditionElements.update(D, true, AddNewColumnElement.toggle), CustomRowProperties.update(D);
    }
    static createTableBody(D) {
      const w2 = document.createElement("tbody");
      return D && w2.classList.add("sticky-header-body"), w2;
    }
    static createTableElement(D) {
      var x2;
      const w2 = document.createElement("table");
      w2.classList.add("table-controlled-width");
      const O = StringDimensionUtils.removeAllDimensions(JSON.parse(JSON.stringify(D.tableStyle)));
      return Object.assign(w2.style, O), (x2 = w2.style).fontFamily || (x2.fontFamily = "Inter, sans-serif, Avenir, Helvetica, Arial"), w2.onmousedown = TableEvents.onMouseDown.bind(D), w2.onmouseup = TableEvents.onMouseUp.bind(D), w2;
    }
    // CAUTION-4 - add row cell is created and ref assigned here - then it is added post render in addFrameBodyElements
    static createInfrastructureElements(D) {
      return FrameComponentsColors.setEventColors(D), D._tableElementRef = _TableElement.createTableElement(D), D._tableBodyElementRef = _TableElement.createTableBody(D._stickyProps.header), D._addRowCellElementRef = AddNewRowElement.create(D), D._tableElementRef.appendChild(D._tableBodyElementRef), D._cellDropdownContainer = CellDropdown.createContainerElement(), D._tableElementRef.appendChild(D._cellDropdownContainer), !D.overflow && D._stickyProps.header && StickyPropsUtils.moveTopBorderToHeaderCells(D), D._tableDimensions.border = TableBorderDimensionsUtils.generateUsingElement(D._tableElementRef), D._tableElementRef;
    }
  };
  var _OverflowUtils = class De {
    static isOverflowElement(D) {
      return (D == null ? void 0 : D.id) === De.ID;
    }
    // a simple way to not take the border into consideration when doing table width calculation, however if there are issues
    // feel free to investigate a better way
    static unsetBorderDimensions(D, w2) {
      w2.number -= D.border.leftWidth + D.border.rightWidth, TableElement.changeStaticWidthTotal(D, -D.border.leftWidth), TableElement.changeStaticWidthTotal(D, -D.border.rightWidth), D.border.leftWidth = 0, D.border.rightWidth = 0, D.border.topWidth = 0, D.border.bottomWidth = 0;
    }
    static processNumberDimension(D, w2) {
      De.unsetBorderDimensions(D, w2), w2.number -= De.SCROLLBAR_WIDTH;
    }
    // prettier-ignore
    static moveBorderToOverflowContainer(D, w2) {
      ElementStyle.moveStyles(
        w2,
        D,
        "borderRight",
        "borderLeft",
        "borderTop",
        "borderBottom",
        "borderRadius",
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomLeftRadius",
        "borderBottomRightRadius"
      ), w2.style.border = "unset";
    }
    static adjustStyleForScrollbarWidth(D) {
      (Browser.IS_SAFARI || Browser.IS_FIREFOX) && D.maxHeight && !D.maxWidth && (D.overflowContainer.style.paddingRight = `${De.SCROLLBAR_WIDTH}px`);
    }
    static setDimensions(D, { width: w2, height: O }) {
      w2 && (D.style.overflowX = "auto", D.style.maxWidth = `${w2}px`), O && (D.style.overflowY = "auto", D.style.maxHeight = `${O}px`);
    }
    // prettier-ignore
    static getDimensions(D, w2) {
      const O = StringDimensionUtils.generateNumberDimensionFromClientString(
        D.parentElement,
        w2,
        "maxWidth",
        true
      );
      O.number -= D._tableDimensions.border.leftWidth + D._tableDimensions.border.rightWidth, O.isPercentage && (w2.isWidthPercentage = true);
      const x2 = StringDimensionUtils.generateNumberDimensionFromClientString(
        D.parentElement,
        w2,
        "maxHeight",
        false
      );
      return x2.number -= D._tableDimensions.border.topWidth + D._tableDimensions.border.bottomWidth, x2.isPercentage && (w2.isHeightPercentage = true), { width: O.number, height: x2.number };
    }
    static applyDimensions(D) {
      const { _overflow: w2 } = D;
      if (!w2)
        return;
      const O = De.getDimensions(D, w2);
      De.setDimensions(w2.overflowContainer, O), De.adjustStyleForScrollbarWidth(w2);
    }
    static setupContainer(D, w2) {
      const O = document.createElement("div");
      D._overflow = { overflowContainer: O, ...D.overflow }, O.id = De.ID, De.moveBorderToOverflowContainer(O, w2), O.appendChild(w2);
    }
  };
  _OverflowUtils.ID = "overflow-container";
  _OverflowUtils.SCROLLBAR_WIDTH = 15;
  var OverflowUtils = _OverflowUtils;
  var ElementVisibility = class {
    // prettier-ignore
    static getDetailsInWindow(D, w2, O = true) {
      const { topWidth: x2, leftWidth: U } = O ? w2 : { topWidth: 0, leftWidth: 0 }, F = D.getBoundingClientRect(), W = (Browser.IS_CHROMIUM ? F.top - x2 : F.top) + window.scrollY, G = (Browser.IS_CHROMIUM ? F.left - U : F.left) + window.scrollX, X = D.offsetWidth, K = D.offsetHeight, q = document.body, Q = /* @__PURE__ */ new Set();
      W < window.pageYOffset && Q.add(SIDE.TOP);
      const le = q.clientWidth < q.scrollWidth ? OverflowUtils.SCROLLBAR_WIDTH : 0;
      W + K + x2 > window.pageYOffset + window.innerHeight - le && Q.add(SIDE.BOTTOM), G < window.pageXOffset && Q.add(SIDE.LEFT);
      const re = q.clientHeight < q.scrollHeight ? OverflowUtils.SCROLLBAR_WIDTH : 0;
      return G + X + U > window.pageXOffset + window.innerWidth - re && Q.add(SIDE.RIGHT), Q.size > 0 ? { isFullyVisible: false, blockingSides: Q } : { isFullyVisible: true };
    }
    // no real need to take care of multiple blockages for now
    static isVerticallyVisibleInsideParent(D, w2) {
      const O = D.parentElement || w2, x2 = O.scrollTop, U = x2 + O.clientHeight, F = D.offsetTop, W = F + D.clientHeight;
      return F < x2 ? { isFullyVisible: false, blockingSides: /* @__PURE__ */ new Set([SIDE.TOP]) } : W > U ? { isFullyVisible: false, blockingSides: /* @__PURE__ */ new Set([SIDE.BOTTOM]) } : { isFullyVisible: true };
    }
  };
  var OuterDropdownEvents = class _OuterDropdownEvents {
    static windowOnMouseDown(D) {
      D._activeOverlayElements.outerContainerDropdown && D._activeOverlayElements.outerContainerDropdown.hide();
    }
    static focusSiblingItem(D, w2, O) {
      const x2 = w2 == null ? void 0 : w2[O];
      if (x2)
        DropdownItemNavigation.focusSiblingItem(x2, D, true, true);
      else if (O === "nextSibling") {
        const U = D.children[0];
        U && DropdownItemNavigation.focusSiblingItem(U, D, true, true);
      } else {
        const U = D.children[D.children.length - 1];
        U && DropdownItemNavigation.focusSiblingItem(U, D, false, true);
      }
    }
    // prettier-ignore
    static windowOnKeyDownNavigation(D, w2) {
      const O = D.getElementsByClassName(DropdownItem.ACTIVE_ITEM_CLASS)[0];
      w2 === KEYBOARD_KEY.TAB || w2 === KEYBOARD_KEY.ARROW_DOWN ? O ? _OuterDropdownEvents.focusSiblingItem(D, O, "nextSibling") : DropdownItemNavigation.focusSiblingItem(D.children[0], D, true, true) : w2 === KEYBOARD_KEY.ARROW_UP && (O ? _OuterDropdownEvents.focusSiblingItem(D, O, "previousSibling") : DropdownItemNavigation.focusSiblingItem(
        D.children[D.children.length - 1],
        D,
        false,
        true
      ));
    }
    // the reason why we track window key events is because the table is not actually focused when it is displayed,
    // (unlike column dropdown which has an input), hence initially clicking tab does not focus the dropdown and
    // instead we need to focus it programmatically here. Once focused, the actual dropdown events can take over.
    // prettier-ignore
    static windowOnKeyDown(D, w2) {
      const { shadowRoot: O, _activeOverlayElements: { outerContainerDropdown: x2 } } = D;
      if (!x2)
        return;
      w2.preventDefault();
      const { element: U, hide: F } = x2;
      w2.key === KEYBOARD_KEY.ENTER || w2.key === KEYBOARD_KEY.ESCAPE ? F() : O != null && O.activeElement || _OuterDropdownEvents.windowOnKeyDownNavigation(U, w2.key);
    }
    static dropdownOnKeyDown(D, w2) {
      w2.preventDefault(), w2.key === KEYBOARD_KEY.ENTER ? w2.target.dispatchEvent(new MouseEvent("mousedown")) : w2.key === KEYBOARD_KEY.ESCAPE && D.hide(), DropdownEvents.itemKeyNavigation(this.shadowRoot, D.element, w2);
    }
    static set(D, w2) {
      w2.element.onkeydown = _OuterDropdownEvents.dropdownOnKeyDown.bind(D, w2);
    }
  };
  var _OuterDropdownElement = class Ye {
    static hide(D, w2) {
      const O = D.outerContainerDropdown;
      O && (Dropdown.hide(O.element), O.button.classList.contains(ToggleableElement.AUTO_STYLING_CLASS) && ToggleableElement.unsetActive(O.button, w2), delete D.outerContainerDropdown, DropdownItemHighlightUtils.fadeCurrentlyHighlighted(D));
    }
    static display(D, w2) {
      w2.button.classList.contains(ToggleableElement.AUTO_STYLING_CLASS) && ToggleableElement.setActive(w2.button, w2.activeButtonStyle), Dropdown.display(w2.element), D._activeOverlayElements.outerContainerDropdown = w2;
    }
    static displayReactToBottomVisibility(D, w2) {
      w2.element.classList.remove(Ye.DROPUP_CLASS), Ye.display(D, w2);
      const O = ElementVisibility.getDetailsInWindow(w2.element, D._tableDimensions.border, false);
      !O.isFullyVisible && O.blockingSides.has(SIDE.BOTTOM) && w2.element.classList.add(Ye.DROPUP_CLASS);
    }
    static setOrientation(D, w2) {
      w2.endsWith("right") && (D.style.right = "0px");
    }
    static createElement(D) {
      const w2 = Dropdown.createBase();
      return w2.style.width = "", w2.classList.add("outer-container-dropdown"), D && w2.classList.add(...D), w2;
    }
    // prettier-ignore
    static create(D, w2, O, x2, U, F, W) {
      const G = Ye.createElement(U), X = { element: G, hide: F, button: w2, activeButtonStyle: x2 };
      return Ye.setOrientation(G, O), OuterDropdownButtonEvents.set(D, w2, O, X, W), OuterDropdownEvents.set(D, X), X;
    }
  };
  _OuterDropdownElement.DROPUP_CLASS = "active-table-dropup";
  var OuterDropdownElement = _OuterDropdownElement;
  var OuterDropdownSimpleUtils = class _OuterDropdownSimpleUtils {
    static hide(D, w2) {
      var x2;
      OuterDropdownElement.hide(D, {});
      const O = (x2 = D.outerContainerDropdown) == null ? void 0 : x2.element;
      if (O) {
        const U = w2 || Array.from(O.children);
        OuterDropdownItem.unsetHoverColors(U);
      }
    }
    static getDropdownTopPosition(D) {
      return `${D.offsetTop + D.offsetHeight}px`;
    }
    // this is a custom display function used by dropdowns that do not populate items on display (export, rows per page)
    static display(D, w2, O) {
      const { element: x2 } = O;
      x2.style.bottom = "", x2.style.top = _OuterDropdownSimpleUtils.getDropdownTopPosition(D), OuterDropdownElement.displayReactToBottomVisibility(w2, O);
    }
  };
  var RowsPerPageDropdownItemUtil = class _RowsPerPageDropdownItemUtil {
    static updateRowsAndPaginationComponents(D, w2, O) {
      RowsPerPageSelectButtonElement.updateButtonText(w2, O), PageButtonContainerElement.shouldButtonsBeActive(D) && (PageButtonContainerElement.repopulateButtons(D), PaginationUtils.getAndApplyDataOnButtonClick(D, 1, O));
    }
    static getNewRowsPerPage(D, w2) {
      const { _pagination: O, data: x2, dataStartsAtHeader: U } = D;
      return O.isAllRowsOptionSelected ? U ? x2.length : x2.length - 1 : Number(w2);
    }
    static setNewRowsPerPage(D, w2, O) {
      D._pagination.isAllRowsOptionSelected = O.toLocaleLowerCase() === RowsPerPageDropdownItem.ALL_ITEM_TEXT, D._pagination.rowsPerPage = _RowsPerPageDropdownItemUtil.getNewRowsPerPage(D, O), _RowsPerPageDropdownItemUtil.updateRowsAndPaginationComponents(D, w2, O);
    }
  };
  var RowsPerPageDropdownItemEvents = class _RowsPerPageDropdownItemEvents {
    static action(D, w2, O, x2) {
      D.rowsPerPage !== Number(x2) && RowsPerPageDropdownItemUtil.setNewRowsPerPage(O, w2, x2);
    }
    static setEvents(D, w2, O) {
      const x2 = _RowsPerPageDropdownItemEvents.action.bind(this, D._pagination, O), U = OuterDropdownSimpleUtils.hide;
      w2.onmousedown = OuterDropdownItemEvents.itemMouseDownCommon.bind(D, x2, U);
    }
  };
  var _RowsPerPageDropdownItem = class wt {
    // lower case as it will be compared against user set text
    static populate(D, w2, O) {
      D._pagination.rowsPerPageOptionsItemText.forEach((U) => {
        const F = { text: String(U) }, W = DropdownItem.addButtonItem(D, w2, F, wt.ITEM_CLASS);
        RowsPerPageDropdownItemEvents.setEvents(D, W, O);
      });
      const x2 = String(D._pagination.rowsPerPage);
      OuterDropdownItem.setActive(Array.from(w2.children), x2);
    }
  };
  _RowsPerPageDropdownItem.ITEM_CLASS = "number-of-rows-dropdown-item";
  _RowsPerPageDropdownItem.ALL_ITEM_TEXT = "all";
  var RowsPerPageDropdownItem = _RowsPerPageDropdownItem;
  var _PaginationInternalUtils = class oe {
    static getTotalNumberOfRows(D) {
      const { data: w2, _visiblityInternal: O, _tableBodyElementRef: x2 } = D;
      return O != null && O.filters ? FilterInternalUtils.extractUnfilteredRows(x2, w2.length).length : w2.length;
    }
    static insertNewRowsPerPageOption(D, w2) {
      let O = w2.findIndex((x2) => {
        const U = Number.parseInt(x2);
        return isNaN(U) || D < U;
      });
      O === -1 && (O = 0), w2.splice(O, 0, String(D));
    }
    static setFirstOptionAsRowsPerPage(D) {
      const { _pagination: w2, dataStartsAtHeader: O } = D, x2 = w2.rowsPerPageOptionsItemText[0];
      if (x2.toLocaleLowerCase() === RowsPerPageDropdownItem.ALL_ITEM_TEXT) {
        w2.isAllRowsOptionSelected = true;
        const U = oe.getTotalNumberOfRows(D);
        w2.rowsPerPage = O ? U : U - 1;
      } else
        w2.rowsPerPage = Number(x2);
    }
    static processRowsPerPage(D, w2) {
      const { rowsPerPageSelect: O } = w2;
      if (D._pagination.rowsPerPage = Number.parseInt(String(D._pagination.rowsPerPage)), O || O === void 0) {
        const { rowsPerPageOptionsItemText: x2, rowsPerPage: U } = D._pagination;
        if (!x2.find((F) => F === String(U))) {
          const F = Number.parseInt(String(U));
          isNaN(F) ? oe.setFirstOptionAsRowsPerPage(D) : oe.insertNewRowsPerPageOption(F, x2);
        }
      }
    }
    static processOptionsItemText(D) {
      const w2 = Number(D);
      return !isNaN(w2) && w2 < 1 ? "2" : String(D);
    }
    // REF-32
    static changeOptionNumberToEven(D) {
      return D.map((w2) => {
        const O = Number(w2);
        return Number.isNaN(O) ? w2 : O % 2 === 1 ? O + 1 : O;
      });
    }
    // prettier-ignore
    static setRowsPerPageOptionsText(D) {
      const w2 = D.pagination, { rowsPerPageSelect: O } = w2;
      if (O || O === void 0) {
        const x2 = D._pagination.rowsPerPageSelect.options;
        let U = O === void 0 || O === true || !O.options || O.options.length === 0 ? x2 : O.options;
        D.stripedRows && (U = oe.changeOptionNumberToEven(U)), D._pagination.rowsPerPageOptionsItemText = U.map((F) => oe.processOptionsItemText(F));
      }
    }
    static processRowsPerPageOptions(D) {
      const w2 = D.pagination, { rowsPerPageSelect: O } = w2;
      O !== void 0 && typeof O != "boolean" && O.prefixText && (D._pagination.rowsPerPageSelect.prefixText = O.prefixText), oe.setRowsPerPageOptionsText(D), delete w2.rowsPerPageSelect;
    }
    static setDefaultBackgroundColors(D, w2) {
      var F, W, G;
      const { def: O, hover: x2, click: U } = w2;
      (F = D.click).backgroundColor ?? (F.backgroundColor = D.hover.backgroundColor || D.default.backgroundColor || U), (W = D.hover).backgroundColor ?? (W.backgroundColor = D.default.backgroundColor || x2), (G = D.default).backgroundColor ?? (G.backgroundColor = O), ["click", "hover", "default"].forEach((X) => {
        D[X].backgroundColor === void 0 && delete D[X].backgroundColor;
      });
    }
    static setStatefulCSS(D, w2) {
      var O, x2, U;
      D[w2] ?? (D[w2] = {}), (O = D[w2]).click ?? (O.click = JSON.parse(JSON.stringify(D[w2].hover || D[w2].default || {}))), (x2 = D[w2]).hover ?? (x2.hover = JSON.parse(JSON.stringify(D[w2].default || {}))), (U = D[w2]).default ?? (U.default = {});
    }
    // prettier-ignore
    static setRowsPerPageOptionsStyle(D) {
      var O;
      oe.setStatefulCSS(D.rowsPerPageSelect, "button");
      const w2 = { def: "", hover: "#f5f5f5", click: "#f5f5f5" };
      oe.setDefaultBackgroundColors(
        (O = D.rowsPerPageSelect) == null ? void 0 : O.button,
        w2
      );
    }
    // activeButtons reuse buttons style
    static mergeButtonsStyleWithActiveStyle(D) {
      const { buttons: w2, actionButtons: O, activeButton: x2 } = D, U = JSON.parse(JSON.stringify(w2));
      return U.default.backgroundColor = "#e8e8e8", U.hover.backgroundColor = "#d6d6d6", U.click.backgroundColor = "#c8c8c8", x2 && (Object.assign(U.default, x2.default), U.hover = x2.hover, U.click = x2.click), U;
    }
    // actionButtons reuse buttons style
    static mergeButtonsStylesWithActionStyles(D) {
      D.actionButtons ?? (D.actionButtons = {});
      const { buttons: w2, actionButtons: O } = D, x2 = JSON.parse(JSON.stringify(w2));
      return Object.assign(x2.default, O.default), Object.assign(x2.hover, O.hover), Object.assign(x2.click, O.click), x2.previousText = O.previousText, x2.nextText = O.nextText, x2.firstText = O.firstText, x2.lastText = O.lastText, x2;
    }
    // prettier-ignore
    static processPageButtonStyles(D) {
      var G, X, K, q;
      (G = D.styles).pageButtons ?? (G.pageButtons = {});
      const w2 = D.styles.pageButtons, O = { def: "white", hover: "#f5f5f5", click: "#c8c8c8" };
      oe.setStatefulCSS(w2, "buttons"), oe.setDefaultBackgroundColors(D.styles.pageButtons.buttons, O), oe.setStatefulCSS(w2, "actionButtons"), oe.setDefaultBackgroundColors(
        D.styles.pageButtons.actionButtons,
        {}
      );
      const x2 = oe.mergeButtonsStylesWithActionStyles(w2);
      D.styles.pageButtons.actionButtons = x2;
      const U = oe.mergeButtonsStyleWithActiveStyle(w2);
      D.styles.pageButtons.activeButton = U, (X = D.styles.pageButtons).disabledButtons ?? (X.disabledButtons = { backgroundColor: "#f9f9f9", color: "#9d9d9d", stroke: "#9d9d9d" });
      const F = {
        borderLeft: "1px solid #0000004d",
        borderTopLeftRadius: "2px",
        borderBottomLeftRadius: "2px"
      };
      (K = D.styles.pageButtons).firstVisibleButtonOverride ?? (K.firstVisibleButtonOverride = F);
      const W = {
        borderRight: "1px solid #0000004d",
        borderTopRightRadius: "2px",
        borderBottomRightRadius: "2px"
      };
      (q = D.styles.pageButtons).lastVisibleButtonOverride ?? (q.lastVisibleButtonOverride = W), D.styles.pageButtons.activeButtonClass = D.styles.pageButtons.activeButtonPrecedence ? PageButtonElement.PRECEDENCE_ACTIVE_PAGINATION_BUTTON_CLASS : PageButtonElement.ACTIVE_PAGINATION_BUTTON_CLASS;
    }
    static processStyle(D, w2) {
      var O, x2;
      D.styles && Object.assign(w2.styles, D.styles), oe.processPageButtonStyles(w2), D.rowsPerPageSelect !== false && ((O = w2.styles).rowsPerPageSelect ?? (O.rowsPerPageSelect = {}), oe.setRowsPerPageOptionsStyle(w2.styles)), (x2 = w2.styles).numberOfVisibleRows ?? (x2.numberOfVisibleRows = {}), delete D.styles;
    }
    static processPositions(D) {
      Object.keys(D).forEach((w2) => {
        const O = D[w2];
        oe.POSITIONS.has(O.position) || (O.position = oe.DEFAULT_POSITION);
      });
    }
    static processPosition(D, w2) {
      D.positions && Object.assign(w2.positions, D.positions), oe.processPositions(w2.positions), delete D.positions;
    }
    static async process(D) {
      const { _pagination: w2, _activeOverlayElements: O } = D;
      if (!D.pagination)
        return;
      const x2 = typeof D.pagination == "boolean" ? {} : D.pagination;
      x2.async && (LoadingElement.addInitial(D), O.error = ErrorElement.create(), w2.asyncStartData = await PaginationAsyncStartData.get(D, x2, w2)), x2.maxNumberOfVisiblePageButtons !== void 0 && x2.maxNumberOfVisiblePageButtons < 1 && (x2.maxNumberOfVisiblePageButtons = 1), oe.processPosition(x2, w2), oe.processStyle(x2, w2), x2.rowsPerPageSelect !== false && oe.processRowsPerPageOptions(D), Object.assign(w2, x2), x2.displayNumberOfVisibleRows !== false && oe.processRowsPerPage(D, x2);
    }
    static getDefault() {
      return {
        rowsPerPage: 10,
        rowsPerPageSelect: {
          options: [10, 25, 50, "All"],
          prefixText: "Rows per page:"
        },
        maxNumberOfVisiblePageButtons: 8,
        displayPrevNext: true,
        displayFirstLast: true,
        displayNumberOfVisibleRows: true,
        styles: {},
        // this is going to be populated during the call of processInternal method
        visibleEdgeButtons: [],
        numberOfActionButtons: 0,
        dropdownWidth: 24,
        positions: {
          pageButtons: {
            position: oe.DEFAULT_POSITION,
            order: 3
          },
          numberOfVisibleRows: {
            position: oe.DEFAULT_POSITION,
            order: 2
          },
          rowsPerPageSelect: {
            position: oe.DEFAULT_POSITION,
            order: 1
          }
        },
        visibleRows: [],
        activePageNumber: 1,
        isAllRowsOptionSelected: false
      };
    }
  };
  _PaginationInternalUtils.DEFAULT_POSITION = "bottom-right";
  _PaginationInternalUtils.POSITIONS = /* @__PURE__ */ new Set([
    "top-left",
    "top-center",
    "top-right",
    "bottom-left",
    "bottom-center",
    _PaginationInternalUtils.DEFAULT_POSITION
  ]);
  var PaginationInternalUtils = _PaginationInternalUtils;
  var ActiveOverlayElementsUtils = class {
    static createNew() {
      return {};
    }
  };
  var ProgrammaticStructureUpdate = class _ProgrammaticStructureUpdate {
    static processData(D, w2) {
      if (w2)
        return D > w2.length ? w2.concat(DataUtils.createEmptyStringDataArray(D - w2.length)) : D < w2.length ? w2.slice(0, D) : w2;
    }
    // if -1 - last row, if above last index - last row, otherwise use the given index
    static processIndex(D, w2, O) {
      return D = D > -1 ? D : O, D = D > O ? O : D, !w2 && D === O ? O - 1 : D;
    }
    // prettier-ignore
    static updateColumn(D, w2, O, x2) {
      var U;
      O = _ProgrammaticStructureUpdate.processIndex(O, w2, ((U = D.data[0]) == null ? void 0 : U.length) || 0), D.data.length === 0 ? x2 && UpdateAllTableData.update(D, x2.map((F) => [F]), 0, true) : w2 ? (x2 = _ProgrammaticStructureUpdate.processData(D.data.length || 0, x2), InsertNewColumn.insert(D, O, x2)) : D.data.length > 0 && RemoveColumn.remove(D, O);
    }
    static updatePaginationAsync(D, w2) {
      setTimeout(() => {
        var O;
        if (D._pagination) {
          const x2 = (O = D._pagination) == null ? void 0 : O.activePageNumber;
          w2 !== x2 ? PaginationUtils.displayRowsForDifferentButton(D, w2) : w2 !== 1 && (PaginationUtils.displayRowsForDifferentButton(D, 1), PaginationUtils.displayRowsForDifferentButton(D, w2));
        }
      });
    }
    static updateRow(D, w2, O, x2) {
      var U, F;
      if (O = _ProgrammaticStructureUpdate.processIndex(O, w2, D.data.length), D.data.length === 0)
        x2 && UpdateAllTableData.update(D, [x2], 0, true);
      else if (w2) {
        const W = (U = D._pagination) == null ? void 0 : U.activePageNumber;
        x2 = _ProgrammaticStructureUpdate.processData(((F = D.data[0]) == null ? void 0 : F.length) || 0, x2), InsertNewRow.insert(D, O, true, x2), setTimeout(() => _ProgrammaticStructureUpdate.updatePaginationAsync(D, W));
      } else
        RemoveRow.remove(D, O);
    }
    static update(D, w2) {
      const { structure: O, isInsert: x2, index: U, data: F } = w2;
      typeof x2 != "boolean" || typeof U != "number" || (O === "row" ? _ProgrammaticStructureUpdate.updateRow(D, x2, U, F) : O === "column" && _ProgrammaticStructureUpdate.updateColumn(D, x2, U, F));
    }
  };
  var FrameComponentsInternalUtils = class {
    static set(D) {
      const { frameComponentsStyles: w2, _frameComponents: O } = D;
      O.displayAddNewColumn = D.displayAddNewColumn, O.displayAddNewRow = D.displayAddNewRow, O.displayIndexColumn = D.displayIndexColumn, O.styles = w2.styles, O.inheritHeaderColors = w2.inheritHeaderColors ?? true;
    }
    static getDefault() {
      return {
        displayAddNewColumn: true,
        displayAddNewRow: true,
        displayIndexColumn: true,
        cellColors: FrameComponentsColors.getDefaultCellColors()
      };
    }
  };
  var RowDropdownSettingsUtil = class _RowDropdownSettingsUtil {
    static postprocessOpenMethod(D, w2) {
      var O, x2;
      !w2.displayIndexColumn && ((O = D.displaySettings.openMethod) != null && O.cellClick) && ((x2 = D.displaySettings.openMethod) == null || delete x2.cellClick, D.displaySettings.openMethod.overlayClick = true);
    }
    // prettier-ignore
    static preprocessOpenMethod(D, w2) {
      w2 && (D.displaySettings.openMethod === void 0 || Object.keys(D.displaySettings.openMethod).length === 0) && w2.openMethod && (D.displaySettings.openMethod = JSON.parse(JSON.stringify(w2.openMethod)));
    }
    static process(D) {
      var U;
      const { rowDropdown: w2, _frameComponents: O, _defaultColumnsSettings: x2 } = D;
      w2.isInsertUpAvailable ?? (w2.isInsertUpAvailable = true), w2.isInsertDownAvailable ?? (w2.isInsertDownAvailable = true), w2.isMoveAvailable ?? (w2.isMoveAvailable = true), w2.canEditHeaderRow ?? (w2.canEditHeaderRow = true), w2.isDeleteAvailable ?? (w2.isDeleteAvailable = true), w2.displaySettings ?? (w2.displaySettings = {}), _RowDropdownSettingsUtil.preprocessOpenMethod(w2, (U = x2.columnDropdown) == null ? void 0 : U.displaySettings), DropdownDisplaySettingsUtil.process(w2.displaySettings), _RowDropdownSettingsUtil.postprocessOpenMethod(w2, O);
    }
  };
  var ProgrammaticCellUpdate = class {
    static updateText(D, w2) {
      var W;
      const { newText: O, rowIndex: x2, columnIndex: U } = w2;
      if (!ObjectUtils.areValuesFullyDefined(O, x2, U) || typeof O != "string" && typeof O != "number")
        return;
      const F = (W = D._columnsDetails[U]) == null ? void 0 : W.elements[x2];
      !F || O === CellElement.getText(F) || (CellEvents.updateCell(D, O, x2, U, { element: F, processText: x2 > 0 }), ColumnTypesUtils.updateDataElements(D, x2, U, F), x2 === 0 && (Dropdown.isDisplayed(D._activeOverlayElements.columnDropdown) && ColumnDropdown.processTextAndHide(D), HeaderText.onAttemptChange(D, F, U)));
    }
  };
  var SheetJSExport = class _SheetJSExport {
    static getFileName(D, w2) {
      return w2 ? w2.endsWith(`.${D}`) ? w2 : `${w2}.${D}` : `table_data.${D}`;
    }
    // not csv
    static export(D, w2, O, x2) {
      const U = x2.utils.book_new(), F = x2.utils.aoa_to_sheet(D.data);
      x2.utils.book_append_sheet(U, F, "Sheet");
      const W = _SheetJSExport.getFileName(w2, O);
      x2.writeFile(U, W, { bookType: w2 });
    }
  };
  var CSVExport = class {
    static export(D, w2) {
      const O = "data:text/csv;charset=utf-8," + D.data.map((F) => F.join(",")).join(`
`), x2 = encodeURI(O), U = document.createElement("a");
      U.setAttribute("href", x2), U.setAttribute("download", w2 || "table_data.csv"), document.body.appendChild(U), U.click();
    }
  };
  var FileExportEvents = class _FileExportEvents {
    static export(D, w2) {
      const O = (w2 == null ? void 0 : w2.format) || "csv";
      if (ACCEPTED_FILE_FORMATS.find((x2) => O === x2)) {
        const x2 = w2 == null ? void 0 : w2.fileName;
        O === "csv" ? CSVExport.export(D, x2) : SheetJSInternalUtils.execFuncWithExtractorModule(SheetJSExport.export.bind(this, D, O, x2));
      }
    }
    static setEvents(D, w2, O) {
      var U;
      const x2 = O ? { format: (U = O.formats) == null ? void 0 : U[0], fileName: O.fileName } : void 0;
      w2.onclick = _FileExportEvents.export.bind(this, D, x2);
    }
  };
  var FileExportDropdownItemEvents = class _FileExportDropdownItemEvents {
    static action(D, w2) {
      const O = w2.toLowerCase();
      FileExportEvents.export(D, { format: O });
    }
    static setEvents(D, w2) {
      const O = _FileExportDropdownItemEvents.action, x2 = OuterDropdownSimpleUtils.hide;
      w2.onmousedown = OuterDropdownItemEvents.itemMouseDownCommon.bind(D, O, x2);
    }
  };
  var _FileExportDropdownItem = class bt {
    // prettier-ignore
    static populate(D, w2, O) {
      O.forEach((x2) => {
        const U = { text: x2.toUpperCase() }, F = DropdownItem.addButtonItem(
          D,
          w2,
          U,
          bt.ITEM_CLASS,
          StaticDropdown.ITEM_CLASS
        );
        FileExportDropdownItemEvents.setEvents(D, F);
      });
    }
  };
  _FileExportDropdownItem.ITEM_CLASS = "export-formats-dropdown-item";
  var FileExportDropdownItem = _FileExportDropdownItem;
  var FileExportDropdown = class {
    static create(D, w2, O) {
      const x2 = OuterDropdownSimpleUtils.hide.bind(this, D._activeOverlayElements), U = OuterDropdownSimpleUtils.display.bind(this, w2), F = OuterDropdownElement.create(D, w2, "bottom-right", {}, [], x2, U);
      return F.element.classList.add(StaticDropdown.DROPDOWN_CLASS), FileExportDropdownItem.populate(D, F.element, O), F;
    }
  };
  var _FileExportButtonElement = class Qe {
    static createButtonArrow(D, w2) {
      const O = OuterDropdownButtonUtils.createArrow(
        [Qe.ARROW_CONTAINER_CLASS],
        [Qe.ARROW_ICON_CLASS]
      ), x2 = typeof w2 == "object" && w2.formats && w2.buttonArrowStyles;
      return x2 && (OuterDropdownButtonUtils.processAndApplyDefaultStyle(O, x2), setTimeout(() => StatefulCSSEvents.setEvents(D, x2, void 0, O))), O;
    }
    // if there is more than 1 format - automatically create a dropdown
    static getDropdownFormats(D) {
      if (typeof D == "object" && D.formats) {
        const { formats: w2 } = D, O = w2.filter((x2) => Qe.VALID_FORMATS[x2.toLocaleLowerCase()]);
        if (O.length > 1)
          return O;
      }
    }
    // prettier-ignore
    static applyDropdown(D, w2, O, x2, U) {
      const F = FileExportDropdown.create(D, w2, x2);
      O.appendChild(F.element), w2.appendChild(Qe.createButtonArrow(w2, U));
    }
  };
  _FileExportButtonElement.ARROW_CONTAINER_CLASS = "file-button-arrow-container";
  _FileExportButtonElement.ARROW_ICON_CLASS = "file-button-arrow-container-icon";
  _FileExportButtonElement.VALID_FORMATS = ["csv", "xls", "xlsx", "ods", "txt"].reduce((Y, D) => (Y[D] = true, Y), {});
  var FileExportButtonElement = _FileExportButtonElement;
  var _FileButtonElements = class Xe {
    static setEvents(D, w2, O) {
      w2.import ? FileImportButtonEvents.setEvents(D, O, typeof w2.import == "object" ? w2.import : void 0) : w2.export && FileExportEvents.setEvents(D, O, typeof w2.export == "object" ? w2.export : void 0);
    }
    // the main reason for this is to display a dropdown
    static wrapInRelativeContainer(D) {
      const w2 = document.createElement("div");
      return w2.classList.add(Xe.BUTTON_CONTAINER_CLASS), w2.appendChild(D), w2;
    }
    static createElement(D, w2) {
      const { text: O, order: x2, styles: U } = D, F = document.createElement("div");
      F.classList.add(Xe.BUTTON_CLASS), F.textContent = O || w2, F.style.order = String(x2 || 0);
      const W = FilesUtils.processStyles(U);
      return Object.assign(F.style, W.default), setTimeout(() => StatefulCSSEvents.setEvents(F, W)), F;
    }
    static create(D, w2) {
      var O, x2;
      (x2 = (O = D.files) == null ? void 0 : O.buttons) == null || x2.forEach((U) => {
        if (!U.export && !U.import)
          return;
        const F = Xe.createElement(U, U.import ? "Import" : "Export"), W = Xe.wrapInRelativeContainer(F), G = U.export && FileExportButtonElement.getDropdownFormats(U.export);
        G ? FileExportButtonElement.applyDropdown(D, F, W, G, U.export) : setTimeout(() => Xe.setEvents(D, U, F));
        const X = U.position || FilesUtils.DEFAULT_BUTTON_POSITION;
        OuterContainerElements.addToContainer(X, w2, W);
      });
    }
  };
  _FileButtonElements.BUTTON_CLASS = "file-button";
  _FileButtonElements.BUTTON_CONTAINER_CLASS = "file-button-container";
  var FileButtonElements = _FileButtonElements;
  var OuterTableComponents = class {
    static create(D) {
      const w2 = OuterContainerElements.create(D);
      D.pagination && PaginationElements.create(D, w2), D.files && FileButtonElements.create(D, w2), D.filter && FilterElements.create(D, w2);
    }
  };
  var WebComponentStyleUtils = class _WebComponentStyleUtils {
    static add(D, w2) {
      if (!(!w2 || !D))
        try {
          _WebComponentStyleUtils.addStyleSheet(D, w2);
        } catch {
          _WebComponentStyleUtils.addStyleElement(D, w2);
        }
    }
    static addStyleSheet(D, w2) {
      const O = new CSSStyleSheet();
      O.replaceSync(D), w2.adoptedStyleSheets.push(O);
    }
    static addStyleElement(D, w2) {
      const O = document.createElement("style");
      O.innerHTML = D, w2.appendChild(O);
    }
  };
  var FocusedElementsUtils = class {
    static createEmpty() {
      return { cell: FocusedCellUtils.createEmpty() };
    }
  };
  var t$2 = (Y) => (D, w2) => {
    w2 !== void 0 ? w2.addInitializer(() => {
      customElements.define(Y, D);
    }) : customElements.define(Y, D);
  };
  var t$1 = globalThis;
  var e$2 = t$1.ShadowRoot && (t$1.ShadyCSS === void 0 || t$1.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
  var s$2 = Symbol();
  var o$4 = /* @__PURE__ */ new WeakMap();
  var n$3 = class {
    constructor(D, w2, O) {
      if (this._$cssResult$ = true, O !== s$2)
        throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
      this.cssText = D, this.t = w2;
    }
    get styleSheet() {
      let D = this.o;
      const w2 = this.t;
      if (e$2 && D === void 0) {
        const O = w2 !== void 0 && w2.length === 1;
        O && (D = o$4.get(w2)), D === void 0 && ((this.o = D = new CSSStyleSheet()).replaceSync(this.cssText), O && o$4.set(w2, D));
      }
      return D;
    }
    toString() {
      return this.cssText;
    }
  };
  var r$4 = (Y) => new n$3(typeof Y == "string" ? Y : Y + "", void 0, s$2);
  var i$3 = (Y, ...D) => {
    const w2 = Y.length === 1 ? Y[0] : D.reduce((O, x2, U) => O + ((F) => {
      if (F._$cssResult$ === true)
        return F.cssText;
      if (typeof F == "number")
        return F;
      throw Error("Value passed to 'css' function must be a 'css' function result: " + F + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
    })(x2) + Y[U + 1], Y[0]);
    return new n$3(w2, Y, s$2);
  };
  var S$1 = (Y, D) => {
    if (e$2)
      Y.adoptedStyleSheets = D.map((w2) => w2 instanceof CSSStyleSheet ? w2 : w2.styleSheet);
    else
      for (const w2 of D) {
        const O = document.createElement("style"), x2 = t$1.litNonce;
        x2 !== void 0 && O.setAttribute("nonce", x2), O.textContent = w2.cssText, Y.appendChild(O);
      }
  };
  var c$2 = e$2 ? (Y) => Y : (Y) => Y instanceof CSSStyleSheet ? ((D) => {
    let w2 = "";
    for (const O of D.cssRules)
      w2 += O.cssText;
    return r$4(w2);
  })(Y) : Y;
  var { is: i$2, defineProperty: e$1, getOwnPropertyDescriptor: h$1, getOwnPropertyNames: r$3, getOwnPropertySymbols: o$3, getPrototypeOf: n$2 } = Object;
  var a$1 = globalThis;
  var c$1 = a$1.trustedTypes;
  var l$1 = c$1 ? c$1.emptyScript : "";
  var p$1 = a$1.reactiveElementPolyfillSupport;
  var d$1 = (Y, D) => Y;
  var u$1 = { toAttribute(Y, D) {
    switch (D) {
      case Boolean:
        Y = Y ? l$1 : null;
        break;
      case Object:
      case Array:
        Y = Y == null ? Y : JSON.stringify(Y);
    }
    return Y;
  }, fromAttribute(Y, D) {
    let w2 = Y;
    switch (D) {
      case Boolean:
        w2 = Y !== null;
        break;
      case Number:
        w2 = Y === null ? null : Number(Y);
        break;
      case Object:
      case Array:
        try {
          w2 = JSON.parse(Y);
        } catch {
          w2 = null;
        }
    }
    return w2;
  } };
  var f$1 = (Y, D) => !i$2(Y, D);
  var b = { attribute: true, type: String, converter: u$1, reflect: false, useDefault: false, hasChanged: f$1 };
  Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), a$1.litPropertyMetadata ?? (a$1.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
  var y = class extends HTMLElement {
    static addInitializer(D) {
      this._$Ei(), (this.l ?? (this.l = [])).push(D);
    }
    static get observedAttributes() {
      return this.finalize(), this._$Eh && [...this._$Eh.keys()];
    }
    static createProperty(D, w2 = b) {
      if (w2.state && (w2.attribute = false), this._$Ei(), this.prototype.hasOwnProperty(D) && ((w2 = Object.create(w2)).wrapped = true), this.elementProperties.set(D, w2), !w2.noAccessor) {
        const O = Symbol(), x2 = this.getPropertyDescriptor(D, O, w2);
        x2 !== void 0 && e$1(this.prototype, D, x2);
      }
    }
    static getPropertyDescriptor(D, w2, O) {
      const { get: x2, set: U } = h$1(this.prototype, D) ?? { get() {
        return this[w2];
      }, set(F) {
        this[w2] = F;
      } };
      return { get: x2, set(F) {
        const W = x2 == null ? void 0 : x2.call(this);
        U == null || U.call(this, F), this.requestUpdate(D, W, O);
      }, configurable: true, enumerable: true };
    }
    static getPropertyOptions(D) {
      return this.elementProperties.get(D) ?? b;
    }
    static _$Ei() {
      if (this.hasOwnProperty(d$1("elementProperties")))
        return;
      const D = n$2(this);
      D.finalize(), D.l !== void 0 && (this.l = [...D.l]), this.elementProperties = new Map(D.elementProperties);
    }
    static finalize() {
      if (this.hasOwnProperty(d$1("finalized")))
        return;
      if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d$1("properties"))) {
        const w2 = this.properties, O = [...r$3(w2), ...o$3(w2)];
        for (const x2 of O)
          this.createProperty(x2, w2[x2]);
      }
      const D = this[Symbol.metadata];
      if (D !== null) {
        const w2 = litPropertyMetadata.get(D);
        if (w2 !== void 0)
          for (const [O, x2] of w2)
            this.elementProperties.set(O, x2);
      }
      this._$Eh = /* @__PURE__ */ new Map();
      for (const [w2, O] of this.elementProperties) {
        const x2 = this._$Eu(w2, O);
        x2 !== void 0 && this._$Eh.set(x2, w2);
      }
      this.elementStyles = this.finalizeStyles(this.styles);
    }
    static finalizeStyles(D) {
      const w2 = [];
      if (Array.isArray(D)) {
        const O = new Set(D.flat(1 / 0).reverse());
        for (const x2 of O)
          w2.unshift(c$2(x2));
      } else
        D !== void 0 && w2.push(c$2(D));
      return w2;
    }
    static _$Eu(D, w2) {
      const O = w2.attribute;
      return O === false ? void 0 : typeof O == "string" ? O : typeof D == "string" ? D.toLowerCase() : void 0;
    }
    constructor() {
      super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
    }
    _$Ev() {
      var D;
      this._$ES = new Promise((w2) => this.enableUpdating = w2), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (D = this.constructor.l) == null || D.forEach((w2) => w2(this));
    }
    addController(D) {
      var w2;
      (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(D), this.renderRoot !== void 0 && this.isConnected && ((w2 = D.hostConnected) == null || w2.call(D));
    }
    removeController(D) {
      var w2;
      (w2 = this._$EO) == null || w2.delete(D);
    }
    _$E_() {
      const D = /* @__PURE__ */ new Map(), w2 = this.constructor.elementProperties;
      for (const O of w2.keys())
        this.hasOwnProperty(O) && (D.set(O, this[O]), delete this[O]);
      D.size > 0 && (this._$Ep = D);
    }
    createRenderRoot() {
      const D = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
      return S$1(D, this.constructor.elementStyles), D;
    }
    connectedCallback() {
      var D;
      this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), (D = this._$EO) == null || D.forEach((w2) => {
        var O;
        return (O = w2.hostConnected) == null ? void 0 : O.call(w2);
      });
    }
    enableUpdating(D) {
    }
    disconnectedCallback() {
      var D;
      (D = this._$EO) == null || D.forEach((w2) => {
        var O;
        return (O = w2.hostDisconnected) == null ? void 0 : O.call(w2);
      });
    }
    attributeChangedCallback(D, w2, O) {
      this._$AK(D, O);
    }
    _$ET(D, w2) {
      var U;
      const O = this.constructor.elementProperties.get(D), x2 = this.constructor._$Eu(D, O);
      if (x2 !== void 0 && O.reflect === true) {
        const F = (((U = O.converter) == null ? void 0 : U.toAttribute) !== void 0 ? O.converter : u$1).toAttribute(w2, O.type);
        this._$Em = D, F == null ? this.removeAttribute(x2) : this.setAttribute(x2, F), this._$Em = null;
      }
    }
    _$AK(D, w2) {
      var U, F;
      const O = this.constructor, x2 = O._$Eh.get(D);
      if (x2 !== void 0 && this._$Em !== x2) {
        const W = O.getPropertyOptions(x2), G = typeof W.converter == "function" ? { fromAttribute: W.converter } : ((U = W.converter) == null ? void 0 : U.fromAttribute) !== void 0 ? W.converter : u$1;
        this._$Em = x2, this[x2] = G.fromAttribute(w2, W.type) ?? ((F = this._$Ej) == null ? void 0 : F.get(x2)) ?? null, this._$Em = null;
      }
    }
    requestUpdate(D, w2, O) {
      var x2;
      if (D !== void 0) {
        const U = this.constructor, F = this[D];
        if (O ?? (O = U.getPropertyOptions(D)), !((O.hasChanged ?? f$1)(F, w2) || O.useDefault && O.reflect && F === ((x2 = this._$Ej) == null ? void 0 : x2.get(D)) && !this.hasAttribute(U._$Eu(D, O))))
          return;
        this.C(D, w2, O);
      }
      this.isUpdatePending === false && (this._$ES = this._$EP());
    }
    C(D, w2, { useDefault: O, reflect: x2, wrapped: U }, F) {
      O && !(this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Map())).has(D) && (this._$Ej.set(D, F ?? w2 ?? this[D]), U !== true || F !== void 0) || (this._$AL.has(D) || (this.hasUpdated || O || (w2 = void 0), this._$AL.set(D, w2)), x2 === true && this._$Em !== D && (this._$Eq ?? (this._$Eq = /* @__PURE__ */ new Set())).add(D));
    }
    async _$EP() {
      this.isUpdatePending = true;
      try {
        await this._$ES;
      } catch (w2) {
        Promise.reject(w2);
      }
      const D = this.scheduleUpdate();
      return D != null && await D, !this.isUpdatePending;
    }
    scheduleUpdate() {
      return this.performUpdate();
    }
    performUpdate() {
      var O;
      if (!this.isUpdatePending)
        return;
      if (!this.hasUpdated) {
        if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
          for (const [U, F] of this._$Ep)
            this[U] = F;
          this._$Ep = void 0;
        }
        const x2 = this.constructor.elementProperties;
        if (x2.size > 0)
          for (const [U, F] of x2) {
            const { wrapped: W } = F, G = this[U];
            W !== true || this._$AL.has(U) || G === void 0 || this.C(U, void 0, F, G);
          }
      }
      let D = false;
      const w2 = this._$AL;
      try {
        D = this.shouldUpdate(w2), D ? (this.willUpdate(w2), (O = this._$EO) == null || O.forEach((x2) => {
          var U;
          return (U = x2.hostUpdate) == null ? void 0 : U.call(x2);
        }), this.update(w2)) : this._$EM();
      } catch (x2) {
        throw D = false, this._$EM(), x2;
      }
      D && this._$AE(w2);
    }
    willUpdate(D) {
    }
    _$AE(D) {
      var w2;
      (w2 = this._$EO) == null || w2.forEach((O) => {
        var x2;
        return (x2 = O.hostUpdated) == null ? void 0 : x2.call(O);
      }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(D)), this.updated(D);
    }
    _$EM() {
      this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
    }
    get updateComplete() {
      return this.getUpdateComplete();
    }
    getUpdateComplete() {
      return this._$ES;
    }
    shouldUpdate(D) {
      return true;
    }
    update(D) {
      this._$Eq && (this._$Eq = this._$Eq.forEach((w2) => this._$ET(w2, this[w2]))), this._$EM();
    }
    updated(D) {
    }
    firstUpdated(D) {
    }
  };
  y.elementStyles = [], y.shadowRootOptions = { mode: "open" }, y[d$1("elementProperties")] = /* @__PURE__ */ new Map(), y[d$1("finalized")] = /* @__PURE__ */ new Map(), p$1 == null || p$1({ ReactiveElement: y }), (a$1.reactiveElementVersions ?? (a$1.reactiveElementVersions = [])).push("2.1.0");
  var o$2 = { attribute: true, type: String, converter: u$1, reflect: false, hasChanged: f$1 };
  var r$2 = (Y = o$2, D, w2) => {
    const { kind: O, metadata: x2 } = w2;
    let U = globalThis.litPropertyMetadata.get(x2);
    if (U === void 0 && globalThis.litPropertyMetadata.set(x2, U = /* @__PURE__ */ new Map()), O === "setter" && ((Y = Object.create(Y)).wrapped = true), U.set(w2.name, Y), O === "accessor") {
      const { name: F } = w2;
      return { set(W) {
        const G = D.get.call(this);
        D.set.call(this, W), this.requestUpdate(F, G, Y);
      }, init(W) {
        return W !== void 0 && this.C(F, void 0, Y, W), W;
      } };
    }
    if (O === "setter") {
      const { name: F } = w2;
      return function(W) {
        const G = this[F];
        D.call(this, W), this.requestUpdate(F, G, Y);
      };
    }
    throw Error("Unsupported decorator location: " + O);
  };
  function n$1(Y) {
    return (D, w2) => typeof w2 == "object" ? r$2(Y, D, w2) : ((O, x2, U) => {
      const F = x2.hasOwnProperty(U);
      return x2.constructor.createProperty(U, O), F ? Object.getOwnPropertyDescriptor(x2, U) : void 0;
    })(Y, D, w2);
  }
  function r$1(Y) {
    return n$1({ ...Y, state: true, attribute: false });
  }
  var WindowEvents = class {
    static onKeyDown(D) {
      var U, F;
      Dropdown.isDisplayed((U = this._activeOverlayElements.outerContainerDropdown) == null ? void 0 : U.element) && OuterDropdownEvents.windowOnKeyDown(this, D), Dropdown.isDisplayed(this._activeOverlayElements.rowDropdown) && RowDropdownEvents.windowOnKeyDown(this, D);
      const { rowIndex: w2, columnIndex: O, element: x2 } = this._focusedElements.cell;
      if (!(w2 === void 0 || O === void 0)) {
        if (w2 === 0 && !Dropdown.isDisplayed(this._activeOverlayElements.columnDropdown)) {
          if (D.key === KEYBOARD_KEY.ESCAPE)
            return HeaderText.onAttemptChange(this, x2, O);
        } else if (Dropdown.isDisplayed(this._activeOverlayElements.columnDropdown) && !((F = this.shadowRoot) != null && F.activeElement))
          return ColumnDropdownEvents.onKeyDown.bind(this)(this._activeOverlayElements.columnDropdown, D);
        w2 > 0 && this._columnsDetails[O].activeType.cellDropdownProps && SelectCellTextBaseEvents.keyDownText(this, w2, O, D);
      }
    }
    static onKeyUp(D) {
      D.key === KEYBOARD_KEY.ESCAPE ? (OptionColorButtonEvents.windowEventClosePicker(this._columnsDetails, this._focusedElements), DateCellInputEvents.escapeKeyInput(this)) : D.key === KEYBOARD_KEY.ENTER && OptionColorButtonEvents.windowEventClosePicker(this._columnsDetails, this._focusedElements);
    }
    // prettier-ignore
    static onMouseDown(D) {
      var U;
      if (OptionColorButtonEvents.windowEventClosePicker(this._columnsDetails, this._focusedElements), Dropdown.isDisplayed((U = this._activeOverlayElements.outerContainerDropdown) == null ? void 0 : U.element) && OuterDropdownEvents.windowOnMouseDown(this), D.target.tagName === ActiveTable._ELEMENT_TAG)
        return;
      const { _activeOverlayElements: { columnDropdown: w2, rowDropdown: O }, _focusedElements: x2 } = this;
      Dropdown.isDisplayed(O) && RowDropdown.hide(this), Dropdown.isDisplayed(w2) ? ColumnDropdown.processTextAndHide(this) : x2.cellDropdown ? CellWithTextEvents.programmaticBlur(this) : this._activeOverlayElements.datePickerCell && (DateCellInputElement.toggle(this._activeOverlayElements.datePickerCell, false), delete this._activeOverlayElements.datePickerCell);
    }
    static onMouseUp() {
      this._activeOverlayElements.selectedColumnSizer && ColumnSizerExtrinsicEvents.windowMouseUp(this), DragColumn.windowMouseUp(this), DragRow.windowMouseUp(this);
    }
    static onMouseMove(D) {
      this._activeOverlayElements.selectedColumnSizer && ColumnSizerExtrinsicEvents.windowMouseMove(this, D.movementX), this._focusedElements.colDragEl && DragColumn.windowDrag(this, this._focusedElements.colDragEl, D), this._focusedElements.rowDragEl && DragRow.windowDrag(this, D);
    }
  };
  var Render = class _Render {
    // CAUTION-4 overwriting @properties causes the whole table to refresh and subsequently - an infinite render loop
    // prettier-ignore
    static refreshTableState(D) {
      var w2;
      (w2 = D._cellDropdownContainer) == null || w2.replaceChildren(), D._columnsDetails.splice(0, D._columnsDetails.length), D._tableDimensions.indexColumnWidth = IndexColumn.DEFAULT_WIDTH, D._addColumnCellsElementsRef.splice(0, D._addColumnCellsElementsRef.length), D._overflow && (D._tableDimensions.border = TableBorderDimensionsUtils.generateUsingElement(D._overflow.overflowContainer));
    }
    static renderTable(D) {
      D._isRendering = true, TableDimensionsUtils.record(D), _Render.refreshTableState(D), D._overflow && OverflowUtils.applyDimensions(D), TableElement.setStaticWidthContentTotal(D), TableDimensionsUtils.setTableDimensions(D), TableElement.populateBody(D), setTimeout(() => D._isRendering = false);
    }
  };
  var WindowResize = class _WindowResize {
    // prettier-ignore
    static resize(D) {
      const { _tableDimensions: w2 } = this;
      (D.width && window.innerWidth !== w2.recordedWindowWidth || D.height && window.innerHeight !== w2.recordedWindowHeight) && Render.renderTable(this);
    }
    static extractPostfix(D) {
      if (typeof D == "string") {
        if (D.includes(VW))
          return VW;
        if (D.includes(VH))
          return VH;
      }
      return "";
    }
    static extractDimensionsToObserve(D) {
      const { tableStyle: w2, _overflow: O } = D, x2 = [w2.width, w2.maxWidth, O == null ? void 0 : O.maxHeight, O == null ? void 0 : O.maxWidth].map(
        (U) => _WindowResize.extractPostfix(U)
      );
      return {
        width: !!x2.find((U) => U === VW),
        height: !!x2.find((U) => U === VH)
      };
    }
    static observeIfRequired(D) {
      const w2 = _WindowResize.extractDimensionsToObserve(D);
      (w2.width || w2.height) && window.addEventListener("resize", _WindowResize.resize.bind(D, w2));
    }
  };
  var WindowElement = class {
    static setEvents(D) {
      window.addEventListener("keydown", WindowEvents.onKeyDown.bind(D)), window.addEventListener("keyup", WindowEvents.onKeyUp.bind(D)), window.addEventListener("mousedown", WindowEvents.onMouseDown.bind(D)), window.addEventListener("mouseup", WindowEvents.onMouseUp.bind(D)), window.addEventListener("mousemove", WindowEvents.onMouseMove.bind(D)), WindowResize.observeIfRequired(D);
    }
  };
  var _GoogleFont = class dt {
    static appendStyleSheetToHead() {
      const D = document.getElementsByTagName("head")[0];
      if (!Array.from(D.getElementsByTagName("link")).some(
        (O) => O.getAttribute("href") === dt.FONT_URL
      )) {
        const O = document.createElement("link");
        O.rel = "stylesheet", O.href = dt.FONT_URL, D.appendChild(O);
      }
    }
  };
  _GoogleFont.FONT_URL = "https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap";
  var GoogleFont = _GoogleFont;
  var ParentResize = class _ParentResize {
    static doesOverflowNeedRerender(D, w2) {
      if (!D._overflow)
        return false;
      const { isHeightPercentage: O, isWidthPercentage: x2 } = D._overflow;
      return O && D._tableDimensions.recordedParentHeight !== w2.offsetHeight || x2 && D._tableDimensions.recordedParentWidth !== w2.offsetWidth;
    }
    static shouldRerenderTable(D) {
      if (!D)
        return false;
      const w2 = D.parentElement;
      return w2 ? _ParentResize.doesOverflowNeedRerender(D, w2) ? true : D._tableDimensions.isPercentage && // Resize callback gets triggered on multiple occasions when the parent width has not changed:
      // on startup, after table has been resized, when parent height is changed and when column height is changed
      // This condition prevents the table from re-rendering itself when the above occurs
      D._tableDimensions.recordedParentWidth !== w2.offsetWidth && // If the parent is resized to a width that does not impact the table width, do not bother re-rendering it
      (D._tableDimensions.maxWidth === void 0 || D.offsetWidth > w2.offsetWidth) : false;
    }
    static resizeCallback() {
      const D = this;
      _ParentResize.shouldRerenderTable(D) && (D._tableDimensions.preserveNarrowColumns || (D._tableDimensions.preserveNarrowColumns = true, setTimeout(() => D._tableDimensions.preserveNarrowColumns = false)), Render.renderTable(D));
    }
  };
  var t = globalThis;
  var i$1 = t.trustedTypes;
  var s$1 = i$1 ? i$1.createPolicy("lit-html", { createHTML: (Y) => Y }) : void 0;
  var e = "$lit$";
  var h = `lit$${Math.random().toFixed(9).slice(2)}$`;
  var o$1 = "?" + h;
  var n = `<${o$1}>`;
  var r = document;
  var l = () => r.createComment("");
  var c = (Y) => Y === null || typeof Y != "object" && typeof Y != "function";
  var a = Array.isArray;
  var u = (Y) => a(Y) || typeof (Y == null ? void 0 : Y[Symbol.iterator]) == "function";
  var d = `[ 	
\f\r]`;
  var f = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
  var v = /-->/g;
  var _ = />/g;
  var m = RegExp(`>|${d}(?:([^\\s"'>=/]+)(${d}*=${d}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
  var p = /'/g;
  var g = /"/g;
  var $ = /^(?:script|style|textarea|title)$/i;
  var T = Symbol.for("lit-noChange");
  var E = Symbol.for("lit-nothing");
  var A = /* @__PURE__ */ new WeakMap();
  var C = r.createTreeWalker(r, 129);
  function P(Y, D) {
    if (!a(Y) || !Y.hasOwnProperty("raw"))
      throw Error("invalid template strings array");
    return s$1 !== void 0 ? s$1.createHTML(D) : D;
  }
  var V = (Y, D) => {
    const w2 = Y.length - 1, O = [];
    let x2, U = D === 2 ? "<svg>" : D === 3 ? "<math>" : "", F = f;
    for (let W = 0; W < w2; W++) {
      const G = Y[W];
      let X, K, q = -1, Q = 0;
      for (; Q < G.length && (F.lastIndex = Q, K = F.exec(G), K !== null); )
        Q = F.lastIndex, F === f ? K[1] === "!--" ? F = v : K[1] !== void 0 ? F = _ : K[2] !== void 0 ? ($.test(K[2]) && (x2 = RegExp("</" + K[2], "g")), F = m) : K[3] !== void 0 && (F = m) : F === m ? K[0] === ">" ? (F = x2 ?? f, q = -1) : K[1] === void 0 ? q = -2 : (q = F.lastIndex - K[2].length, X = K[1], F = K[3] === void 0 ? m : K[3] === '"' ? g : p) : F === g || F === p ? F = m : F === v || F === _ ? F = f : (F = m, x2 = void 0);
      const le = F === m && Y[W + 1].startsWith("/>") ? " " : "";
      U += F === f ? G + n : q >= 0 ? (O.push(X), G.slice(0, q) + e + G.slice(q) + h + le) : G + h + (q === -2 ? W : le);
    }
    return [P(Y, U + (Y[w2] || "<?>") + (D === 2 ? "</svg>" : D === 3 ? "</math>" : "")), O];
  };
  var N = class _N {
    constructor({ strings: D, _$litType$: w2 }, O) {
      let x2;
      this.parts = [];
      let U = 0, F = 0;
      const W = D.length - 1, G = this.parts, [X, K] = V(D, w2);
      if (this.el = _N.createElement(X, O), C.currentNode = this.el.content, w2 === 2 || w2 === 3) {
        const q = this.el.content.firstChild;
        q.replaceWith(...q.childNodes);
      }
      for (; (x2 = C.nextNode()) !== null && G.length < W; ) {
        if (x2.nodeType === 1) {
          if (x2.hasAttributes())
            for (const q of x2.getAttributeNames())
              if (q.endsWith(e)) {
                const Q = K[F++], le = x2.getAttribute(q).split(h), re = /([.?@])?(.*)/.exec(Q);
                G.push({ type: 1, index: U, name: re[2], strings: le, ctor: re[1] === "." ? H : re[1] === "?" ? I : re[1] === "@" ? L : k }), x2.removeAttribute(q);
              } else
                q.startsWith(h) && (G.push({ type: 6, index: U }), x2.removeAttribute(q));
          if ($.test(x2.tagName)) {
            const q = x2.textContent.split(h), Q = q.length - 1;
            if (Q > 0) {
              x2.textContent = i$1 ? i$1.emptyScript : "";
              for (let le = 0; le < Q; le++)
                x2.append(q[le], l()), C.nextNode(), G.push({ type: 2, index: ++U });
              x2.append(q[Q], l());
            }
          }
        } else if (x2.nodeType === 8)
          if (x2.data === o$1)
            G.push({ type: 2, index: U });
          else {
            let q = -1;
            for (; (q = x2.data.indexOf(h, q + 1)) !== -1; )
              G.push({ type: 7, index: U }), q += h.length - 1;
          }
        U++;
      }
    }
    static createElement(D, w2) {
      const O = r.createElement("template");
      return O.innerHTML = D, O;
    }
  };
  function S(Y, D, w2 = Y, O) {
    var F, W;
    if (D === T)
      return D;
    let x2 = O !== void 0 ? (F = w2._$Co) == null ? void 0 : F[O] : w2._$Cl;
    const U = c(D) ? void 0 : D._$litDirective$;
    return (x2 == null ? void 0 : x2.constructor) !== U && ((W = x2 == null ? void 0 : x2._$AO) == null || W.call(x2, false), U === void 0 ? x2 = void 0 : (x2 = new U(Y), x2._$AT(Y, w2, O)), O !== void 0 ? (w2._$Co ?? (w2._$Co = []))[O] = x2 : w2._$Cl = x2), x2 !== void 0 && (D = S(Y, x2._$AS(Y, D.values), x2, O)), D;
  }
  var M = class {
    constructor(D, w2) {
      this._$AV = [], this._$AN = void 0, this._$AD = D, this._$AM = w2;
    }
    get parentNode() {
      return this._$AM.parentNode;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    u(D) {
      const { el: { content: w2 }, parts: O } = this._$AD, x2 = ((D == null ? void 0 : D.creationScope) ?? r).importNode(w2, true);
      C.currentNode = x2;
      let U = C.nextNode(), F = 0, W = 0, G = O[0];
      for (; G !== void 0; ) {
        if (F === G.index) {
          let X;
          G.type === 2 ? X = new R(U, U.nextSibling, this, D) : G.type === 1 ? X = new G.ctor(U, G.name, G.strings, this, D) : G.type === 6 && (X = new z(U, this, D)), this._$AV.push(X), G = O[++W];
        }
        F !== (G == null ? void 0 : G.index) && (U = C.nextNode(), F++);
      }
      return C.currentNode = r, x2;
    }
    p(D) {
      let w2 = 0;
      for (const O of this._$AV)
        O !== void 0 && (O.strings !== void 0 ? (O._$AI(D, O, w2), w2 += O.strings.length - 2) : O._$AI(D[w2])), w2++;
    }
  };
  var R = class _R {
    get _$AU() {
      var D;
      return ((D = this._$AM) == null ? void 0 : D._$AU) ?? this._$Cv;
    }
    constructor(D, w2, O, x2) {
      this.type = 2, this._$AH = E, this._$AN = void 0, this._$AA = D, this._$AB = w2, this._$AM = O, this.options = x2, this._$Cv = (x2 == null ? void 0 : x2.isConnected) ?? true;
    }
    get parentNode() {
      let D = this._$AA.parentNode;
      const w2 = this._$AM;
      return w2 !== void 0 && (D == null ? void 0 : D.nodeType) === 11 && (D = w2.parentNode), D;
    }
    get startNode() {
      return this._$AA;
    }
    get endNode() {
      return this._$AB;
    }
    _$AI(D, w2 = this) {
      D = S(this, D, w2), c(D) ? D === E || D == null || D === "" ? (this._$AH !== E && this._$AR(), this._$AH = E) : D !== this._$AH && D !== T && this._(D) : D._$litType$ !== void 0 ? this.$(D) : D.nodeType !== void 0 ? this.T(D) : u(D) ? this.k(D) : this._(D);
    }
    O(D) {
      return this._$AA.parentNode.insertBefore(D, this._$AB);
    }
    T(D) {
      this._$AH !== D && (this._$AR(), this._$AH = this.O(D));
    }
    _(D) {
      this._$AH !== E && c(this._$AH) ? this._$AA.nextSibling.data = D : this.T(r.createTextNode(D)), this._$AH = D;
    }
    $(D) {
      var U;
      const { values: w2, _$litType$: O } = D, x2 = typeof O == "number" ? this._$AC(D) : (O.el === void 0 && (O.el = N.createElement(P(O.h, O.h[0]), this.options)), O);
      if (((U = this._$AH) == null ? void 0 : U._$AD) === x2)
        this._$AH.p(w2);
      else {
        const F = new M(x2, this), W = F.u(this.options);
        F.p(w2), this.T(W), this._$AH = F;
      }
    }
    _$AC(D) {
      let w2 = A.get(D.strings);
      return w2 === void 0 && A.set(D.strings, w2 = new N(D)), w2;
    }
    k(D) {
      a(this._$AH) || (this._$AH = [], this._$AR());
      const w2 = this._$AH;
      let O, x2 = 0;
      for (const U of D)
        x2 === w2.length ? w2.push(O = new _R(this.O(l()), this.O(l()), this, this.options)) : O = w2[x2], O._$AI(U), x2++;
      x2 < w2.length && (this._$AR(O && O._$AB.nextSibling, x2), w2.length = x2);
    }
    _$AR(D = this._$AA.nextSibling, w2) {
      var O;
      for ((O = this._$AP) == null ? void 0 : O.call(this, false, true, w2); D && D !== this._$AB; ) {
        const x2 = D.nextSibling;
        D.remove(), D = x2;
      }
    }
    setConnected(D) {
      var w2;
      this._$AM === void 0 && (this._$Cv = D, (w2 = this._$AP) == null || w2.call(this, D));
    }
  };
  var k = class {
    get tagName() {
      return this.element.tagName;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    constructor(D, w2, O, x2, U) {
      this.type = 1, this._$AH = E, this._$AN = void 0, this.element = D, this.name = w2, this._$AM = x2, this.options = U, O.length > 2 || O[0] !== "" || O[1] !== "" ? (this._$AH = Array(O.length - 1).fill(new String()), this.strings = O) : this._$AH = E;
    }
    _$AI(D, w2 = this, O, x2) {
      const U = this.strings;
      let F = false;
      if (U === void 0)
        D = S(this, D, w2, 0), F = !c(D) || D !== this._$AH && D !== T, F && (this._$AH = D);
      else {
        const W = D;
        let G, X;
        for (D = U[0], G = 0; G < U.length - 1; G++)
          X = S(this, W[O + G], w2, G), X === T && (X = this._$AH[G]), F || (F = !c(X) || X !== this._$AH[G]), X === E ? D = E : D !== E && (D += (X ?? "") + U[G + 1]), this._$AH[G] = X;
      }
      F && !x2 && this.j(D);
    }
    j(D) {
      D === E ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, D ?? "");
    }
  };
  var H = class extends k {
    constructor() {
      super(...arguments), this.type = 3;
    }
    j(D) {
      this.element[this.name] = D === E ? void 0 : D;
    }
  };
  var I = class extends k {
    constructor() {
      super(...arguments), this.type = 4;
    }
    j(D) {
      this.element.toggleAttribute(this.name, !!D && D !== E);
    }
  };
  var L = class extends k {
    constructor(D, w2, O, x2, U) {
      super(D, w2, O, x2, U), this.type = 5;
    }
    _$AI(D, w2 = this) {
      if ((D = S(this, D, w2, 0) ?? E) === T)
        return;
      const O = this._$AH, x2 = D === E && O !== E || D.capture !== O.capture || D.once !== O.once || D.passive !== O.passive, U = D !== E && (O === E || x2);
      x2 && this.element.removeEventListener(this.name, this, O), U && this.element.addEventListener(this.name, this, D), this._$AH = D;
    }
    handleEvent(D) {
      var w2;
      typeof this._$AH == "function" ? this._$AH.call(((w2 = this.options) == null ? void 0 : w2.host) ?? this.element, D) : this._$AH.handleEvent(D);
    }
  };
  var z = class {
    constructor(D, w2, O) {
      this.element = D, this.type = 6, this._$AN = void 0, this._$AM = w2, this.options = O;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(D) {
      S(this, D);
    }
  };
  var j = t.litHtmlPolyfillSupport;
  j == null || j(N, R), (t.litHtmlVersions ?? (t.litHtmlVersions = [])).push("3.3.0");
  var B = (Y, D, w2) => {
    const O = (w2 == null ? void 0 : w2.renderBefore) ?? D;
    let x2 = O._$litPart$;
    if (x2 === void 0) {
      const U = (w2 == null ? void 0 : w2.renderBefore) ?? null;
      O._$litPart$ = x2 = new R(D.insertBefore(l(), U), U, void 0, w2 ?? {});
    }
    return x2._$AI(Y), x2;
  };
  var s = globalThis;
  var i2 = class extends y {
    constructor() {
      super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
    }
    createRenderRoot() {
      var w2;
      const D = super.createRenderRoot();
      return (w2 = this.renderOptions).renderBefore ?? (w2.renderBefore = D.firstChild), D;
    }
    update(D) {
      const w2 = this.render();
      this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(D), this._$Do = B(w2, this.renderRoot, this.renderOptions);
    }
    connectedCallback() {
      var D;
      super.connectedCallback(), (D = this._$Do) == null || D.setConnected(true);
    }
    disconnectedCallback() {
      var D;
      super.disconnectedCallback(), (D = this._$Do) == null || D.setConnected(false);
    }
    render() {
      return T;
    }
  };
  var pt;
  i2._$litElement$ = true, i2.finalized = true, (pt = s.litElementHydrateSupport) == null || pt.call(s, { LitElement: i2 });
  var o2 = s.litElementPolyfillSupport;
  o2 == null || o2({ LitElement: i2 });
  (s.litElementVersions ?? (s.litElementVersions = [])).push("4.2.0");
  var activeTableStyle = i$3`
  /* this is used to shrink the width of the active-table element to the shadow-root width */
  :host {
    /* the following property prevents outside styles from affecting this component */
    all: initial;
    /* the following property is used to control the overall component width */
    display: inline-block;
  }

  table {
    border-spacing: 0px;
    position: relative;
    border: 1px solid #00000028;
    background-color: white;
  }

  /* REF-16 */
  .table-controlled-width {
    table-layout: fixed;
    /* fit-content does not work correctly in firefox when there are not enough columns to fit parent */
    width: min-content;
  }

  tbody {
    border-radius: inherit;
  }

  tbody > .row:first-child > *:first-child {
    border-top-left-radius: inherit;
  }

  /* using last-of-type as the last element is a divider which does not help with corner rounding */
  tbody > .row:first-child > .cell:last-of-type {
    border-top-right-radius: inherit;
  }

  #last-visible-row > *:first-child {
    border-bottom-left-radius: inherit;
  }

  #last-visible-row > .cell:last-of-type {
    border-bottom-right-radius: inherit;
  }

  .row {
    color: rgba(0, 0, 0, 0.87);
    font-size: 13px;
    font-weight: 400;
    /* the following is not supported in Firefox (on rows), hence rowHoverStyles will not have the border */
    border-radius: inherit;
  }

  tbody > .row:first-child {
    position: relative;
  }

  .row > *:first-child {
    border-left: none !important;
  }

  .row > .cell:last-of-type {
    border-right: none !important;
  }

  /* REF-25 */
  #last-visible-row > .cell {
    border-bottom: none !important;
  }

  .cell {
    text-align: left;
    padding: 11px 6px 6px;
    font-size: 14px;
    line-height: 17px;
    height: 42.5px;
    box-sizing: border-box;
    outline: none;
    overflow-wrap: anywhere;
    font-size: inherit;
    font-weight: inherit;
    border-bottom-style: solid;
    border-bottom-width: 1px;
    border-bottom-color: rgba(0, 0, 0, 0.12);
    vertical-align: top;
    text-align: left;
    border-right: 1px solid #00000021;
    color: #222222;
  }

  .cell-text-div {
    outline: none;
    overflow-wrap: anywhere;
    border-radius: 4px;
    width: fit-content;
    /* need padding for the cursor to show up */
    padding-left: 1px;
  }

  .select-cell-text {
    float: left;
  }

  .arrow-down-icon-container {
    position: relative;
  }

  .arrow-down-icon {
    position: absolute;
    right: 2px;
    top: 5px;
    text-align: center;
    cursor: pointer;
  }

  .label-cell-text {
    padding-left: 6px;
    padding-right: 6px;
    padding-top: 2px;
    padding-bottom: 2px;
  }

  .cell-divider {
    position: absolute;
    display: flex;
    justify-content: center;
  }

  .cell-divider > * {
    user-select: none;
    /* safari */
    -webkit-user-select: none;
    position: absolute;
    cursor: col-resize;
    justify-content: center;
    height: inherit;
  }

  /* this class needs to be after .cell to have style precendence */
  /* REF-1 */
  .header-cell {
    border-top: none !important;
    cursor: pointer;
    color: #626262;
    padding-top: 12px;
    padding-bottom: 12px;
    font-weight: 500;
  }

  .header-icon-container {
    float: left;
    pointer-events: none;
    /* the height is set to allow the text to be present below the icon when there is not enough space in the cell */
    height: 15px;
  }

  .header-icon-side-text {
    /* cannot use flex as pressing ENTER creates a new div */
    /* cannot use grid as it does not align in Safari */
    display: table-cell;
  }

  .not-selectable {
    user-select: none;
    /* safari */
    -webkit-user-select: none;
  }

  .column-sizer {
    /* need z-index for the sizer to display over header icon */
    z-index: 1;
    background-size: 20px 5px;
    position: absolute;
  }

  .column-sizer-filler {
    height: inherit;
    position: absolute;
    pointer-events: none;
  }

  .column-sizer-overlay {
    background-color: #ff000001;
    z-index: 1;
  }

  .movable-column-sizer {
    z-index: 1;
  }

  .movable-column-sizer-vertical-line {
    width: 1px;
    pointer-events: none;
  }

  #add-new-row-cell {
    padding-top: 8px;
    padding-left: 17px;
    min-height: 28px;
    line-height: 18px;
    font-size: 12px;
    color: #555555;
    vertical-align: middle;
    cursor: pointer;
  }

  .index-cell {
    text-align: center;
    padding: 11px 4px 0px !important;
  }

  .index-cell-overflow {
    overflow: hidden;
    overflow-wrap: normal;
  }

  #temp-invisible-index-number {
    color: #e2e2e200 !important;
  }

  .add-column-cell {
    cursor: pointer;
    text-align: center;
  }

  .header-cell-clone {
    position: absolute;
    cursor: move;
    top: 0px;
  }

  .header-cell-clone-animation {
    transition: 0.25s ease-out;
  }

  .cell-hidden {
    opacity: 0 !important;
  }

  .row-clone {
    position: absolute;
    display: flex;
    opacity: 0.8s;
  }

  .row-clone > * {
    cursor: move !important;
  }

  .row-drag-target-line {
    height: 4px;
    width: 100%;
    position: absolute;
    background-color: #69b0ff;
    pointer-events: none;
  }

  .root-cell {
    text-align: center;
    padding: 0px !important;
    border: none !important;
    // inheriting border radius as when frame components style background is set (add new row component), table border
    // radius is visibly not inherited
    border-radius: inherit;
  }

  .active-table-dropdown {
    position: absolute;
    box-shadow: rgb(15 15 15 / 5%) 0px 0px 0px 1px, rgb(15 15 15 / 10%) 0px 3px 6px, rgb(15 15 15 / 20%) 0px 9px 24px;
    border-radius: 5px;
    background-color: white;
    z-index: 1;
  }

  .active-table-dropup {
    box-shadow: rgba(15, 15, 15, 0.05) 0px 0px 0px 1px, rgba(15, 15, 15, 0.1) 0px 3px 6px,
      rgba(15, 15, 15, 0.2) 0px -2px 24px;
    top: unset !important;
    bottom: 100%;
  }

  .cell-dropdown {
    overflow: auto;
    white-space: nowrap;
  }

  .cell-dropdown::-webkit-scrollbar {
    width: 9px;
    height: 9px;
  }

  .cell-dropdown::-webkit-scrollbar-thumb {
    background-color: #aaaaaa;
    border-radius: 5px;
  }

  .cell-dropdown::-webkit-scrollbar-track {
    background-color: #f2f2f2;
  }

  .dropdown-item {
    padding-top: 3px;
    padding-bottom: 3px;
    padding-right: 5px;
    padding-left: 5px;
    color: #4b4b4b;
    position: relative;
    cursor: pointer;
    /* retaining the outline for dropdown input to make it easier to recognise */
    outline: none;
    font-size: 15px;
  }

  .cell-dropdown > .dropdown-item {
    /* the height of cell dropdown items seem to change depending on monitor size which inconsistently triggers overflow,
    this sets it to be consistent but ideally we should not do this and use a different way to allow any font sizes */
    height: 18px;
  }

  .dropdown-item-icon-container {
    display: flex;
    float: left;
    height: 90%;
    align-items: initial;
    padding-top: 2px;
    /* if items are not aligned in center - change align-items to center and revert changes
      in 0805a911cd5c7921aa05b13ffb9387d3d996c133 */
  }

  .dropdown-title-item {
    cursor: default;
    color: #7c7c7c;
    font-weight: 600;
    font-size: 0.75rem;
    margin-top: 2px;
  }

  .dropdown-input-item {
    text-align: center;
  }

  .dropdown-input {
    width: 92%;
    border: 1px solid grey;
    border-radius: 2px;
    color: #2d2d2d;
    font-size: 14px;
    padding: 3px;
    padding-top: 4px;
  }

  .dropdown-item-divider {
    border-bottom: 1px solid #d4d4d4;
    margin-top: 2px;
    margin-bottom: 2px;
  }

  .dropdown-highlightable-item:hover {
    background-color: #eaeaea;
  }

  .active-dropdown-item {
    background-color: #4a69d4;
    color: white;
  }

  /* using different class as standard dropdowns use above class in their functionality */
  .active-static-dropdown-item {
    background-color: #4a69d4;
    color: white;
  }

  .active-dropdown-item:focus {
    background-color: #2148d5 !important;
    color: white !important;
  }

  /* Do not want to set default height incase user has set a font or a font-family so
    setting a placeholder text and making it invisible */
  .dropdown-item-empty {
    color: #ffffae00 !important;
  }

  .dropdown-disabled-item {
    pointer-events: none;
    color: #9e9e9e8a;
  }

  .cell-dropdown-option-button-container {
    position: absolute;
    width: 100%;
    height: 0px;
    top: 5px;
    left: -5px;
    display: none;
  }

  .cell-dropdown-option-button {
    height: 13px;
    width: 13px;
    position: sticky;
    z-index: 1;
    border-radius: 12px;
    opacity: 0.3;
    background-color: white;
  }

  .cell-dropdown-option-button:hover {
    opacity: 1;
  }

  .cell-dropdown-option-button:active {
    background-color: #f8f8f8;
  }

  .cell-dropdown-option-button > div {
    font-size: 12px;
    height: 11px;
    pointer-events: none;
    color: black;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .cell-dropdown-option-delete-button-icon {
    font-size: 12.5px;
    width: 13px;
  }

  .cell-dropdown-option-color-button-icon {
    width: 12.5px;
  }

  .outer-container-dropdown {
    z-index: 2;
  }

  .color-input {
    width: 0px;
    height: 0px;
    padding: 0px;
    position: absolute;
    outline: none;
    pointer-events: none;
    opacity: 0;
    /* border unset stops color picker panel from appearing in safari */
  }

  .date-input-container {
    position: relative;
    float: right;
    cursor: pointer;
  }

  .date-input {
    top: 17px;
    width: 0px;
    height: 0px;
    border: unset;
    padding: 0px;
    right: 9px;
    position: absolute;
    outline: none;
  }

  .calender-icon-container {
    position: absolute;
    right: 2px;
    top: -4px;
    width: 15px;
    height: 25px;
    text-align: center;
  }

  #full-table-overlay {
    position: absolute;
    top: 0;
    width: 100%;
    height: 100%;
  }

  #drag-and-drop-overlay {
    position: absolute;
    top: 0;
    width: 100%;
    height: 100%;
    height: calc(100% - 10px);
    width: calc(100% - 10px);
    background-color: #70c6ff4d;
    border: 5px dashed #6dafff;
    display: none;
    z-index: 2;
  }

  .filter-hidden-row {
    display: none;
  }

  .dropdown-cell-overlay {
    cursor: pointer;
    background-color: grey;
  }

  .column-dropdown-cell-overlay {
    transition: height 0.2s;
    border-bottom-left-radius: 2px;
    border-bottom-right-radius: 2px;
  }

  .row-dropdown-cell-overlay {
    transition: width 0.2s;
    border-top-right-radius: 2px;
    border-bottom-right-radius: 2px;
  }

  #pagination-button-container {
    right: 0;
    display: flex;
    width: fit-content;
    height: fit-content;
  }

  .pagination-button {
    border: 1px solid #0000004d;
    border-right: unset;
    color: #353535;
    min-width: 31px;
    height: 30.5px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 15.5px;
    /* REF-40 */
    stroke: black;
  }

  .pagination-prev-next-button {
    width: 14.25px;
    padding-left: 4px;
  }

  .pagination-first-last-button {
    width: 13px;
  }

  .pagination-button > * {
    pointer-events: none;
  }

  .pagination-button-disabled {
    pointer-events: none;
    color: #7c7c7c;
    /* REF-40 */
    stroke: #7c7c7c;
  }

  .pagination-button > svg > path {
    /* REF-40 */
    stroke: inherit;
  }

  #pagination-number-of-visible-rows {
    padding-top: 6px;
    color: #252525;
    min-width: 82px;
    text-align: center;
    font-size: 15.5px;
    padding-top: 7.5px;
  }

  #pagination-number-of-rows-select {
    position: relative;
    color: #1d1d1d;
    min-width: max-content;
  }

  #pagination-number-of-rows-select-text {
    font-size: 15.5px;
    float: left;
    margin-top: 6px;
  }

  #rows-per-page-select-button {
    display: inline-block;
    background-color: white;
    border: 1px solid #0000004d;
    border-radius: 4px;
    height: 24px;
    padding-top: 3px;
    padding-bottom: 0.5px;
    padding-left: 6px;
    padding-right: 1px;
    margin-top: 1px;
    cursor: pointer;
  }

  .outer-dropdown-button-arrow-container {
    pointer-events: none;
    color: #353535;
    font-size: 16px;
    float: right;
    margin: 1px;
    margin-left: -1px;
    width: 19px;
  }

  .outer-dropdown-button-arrow-icon {
    width: 16px;
    transform: scale(0.9, 1);
    filter: brightness(0) saturate(100%) invert(11%) sepia(3%) saturate(99%) hue-rotate(157deg) brightness(97%)
      contrast(98%);
    padding-top: 2px;
    padding-left: 2px;
  }

  #rows-per-page-select-button-text {
    display: inline-block;
    pointer-events: none;
    padding-top: 1px;
  }

  .number-of-rows-dropdown-item {
    padding-right: 12.5px;
    text-align: right;
  }

  .file-button-container {
    position: relative;
  }

  .file-button {
    border: 1px solid #00000038;
    border-radius: 3px;
    color: #464646;
    text-align: center;
    cursor: pointer;
    user-select: none;
    background-color: #f8f8f9;
    font-size: 14.5px;
    align-items: center;
    display: flex;
    height: 29px;
    padding: 0px 10px 1px;
  }

  .file-button-arrow-container {
    margin-right: -5px;
  }

  .file-button-arrow-container-icon {
    width: 17px;
    padding-top: 5px;
  }

  .export-formats-dropdown-item {
    padding: 4px 10px;
    font-size: 14.5px;
  }

  .hidden-row {
    line-height: 0px;
    height: 0px !important;
    user-select: none;
    pointer-events: none;
  }

  .hidden-row > * {
    line-height: 0px;
    height: 0px;
    padding: 0px !important;
    font-size: 0px;
    border-bottom-width: 0px !important;
  }

  .hidden-row > th > * {
    display: none;
  }

  .outer-container {
    display: grid;
    position: relative;
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }

  #outer-top-container > div > div > div > * {
    margin-bottom: 13px;
  }

  #outer-bottom-container > div > div > div > * {
    margin-top: 13px;
  }

  /* REF-38 */
  .outer-container-column {
    display: flex;
    width: 0px;
  }

  .outer-container-column-inner {
    display: flex;
  }

  .outer-container-column-content {
    display: flex;
    /* use -webkit-max-content if the below does not work */
    width: max-content;
  }

  .outer-container-left-column .outer-container-column-content > div {
    margin-right: 10px;
  }

  .outer-container-center-column {
    justify-content: center;
    position: absolute;
  }

  .outer-container-center-column .outer-container-column-content > div {
    margin-left: 5px;
    margin-right: 5px;
  }

  .outer-container-right-column {
    justify-content: end;
  }

  .outer-container-right-column .outer-container-column-content > div {
    margin-left: 10px;
  }

  /* right sibling */
  .pagination-button-active-precedence + div {
    border-left-color: #fafafa01 !important;
  }

  .sticky-header-body > *:first-child {
    top: 0;
    position: sticky !important;
  }

  .sticky-header-body > *:first-child > th {
    background-color: white;
  }

  #overflow-container {
    border: 1px solid #00000026;
  }

  /* REF-37 */
  .no-overflow-sticky-header-body {
    border-top: 1px solid #00000026;
  }

  /* REF-37 */
  .no-overflow-sticky-header-body > *:first-child {
    border-top: inherit;
  }

  /* REF-37 */
  .no-overflow-sticky-header-body > *:first-child > th {
    border-top: inherit !important;
  }

  .filter-rows-container {
    position: relative;
  }

  .filter-rows-input {
    width: 150px;
    height: 20px;
    border: 1px solid #0000002b;
    border-radius: 4px;
    color: rgb(45, 45, 45);
    font-family: inherit;
    padding: 5px 6px;
    font-size: 14px;
  }

  .filter-rows-input::placeholder {
    color: var(--active-table-filter-placeholder-color);
  }

  .filter-rows-dropdown-button {
    position: absolute;
    right: 4px;
    top: 51.6%;
    transform: translateY(-50%);
    cursor: pointer;
    user-select: none;
    filter: brightness(0) saturate(100%) invert(49%) sepia(0%) saturate(974%) hue-rotate(66deg) brightness(97%)
      contrast(96%);
    width: 16px;
    height: 16px;
  }

  .filter-rows-dropdown-button + .filter-rows-case-button {
    right: 15px;
  }

  .filter-rows-case-button + .filter-rows-input {
    padding-right: 30px;
    width: 129px;
  }

  .filter-rows-dropdown-button + .filter-rows-input {
    padding-right: 22px;
    width: 137px;
  }

  .filter-rows-dropdown-button + .filter-rows-case-button + .filter-rows-input {
    padding-right: 45px;
    width: 114px;
  }

  .filter-rows-case-button {
    position: absolute;
    right: 0px;
    top: 49%;
    transform: translate(-50%, -50%);
    color: grey;
    font-size: 13px;
    cursor: pointer;
    user-select: none;
  }

  .filter-rows-dropdown {
    min-width: 100% !important;
    width: max-content !important;
  }

  .filter-rows-dropdown > .dropdown-item {
    padding-left: 8px;
    padding-right: 8px;
    padding-top: 4px;
    padding-bottom: 4px;
  }

  .default-loading-container {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 400px;
    width: 400px;
    border: 1px solid grey;
  }

  .loading-container-absolute {
    position: absolute;
    top: 0;
    height: 100%;
    width: 100%;
  }

  .absolute-container {
    position: absolute;
    top: 0;
    height: 100%;
    width: 100%;
  }

  .loading-spinner {
    width: 60px;
    height: 60px;
    border: 5px solid #38a4ff;
    border-bottom-color: transparent;
    border-radius: 50%;
    display: inline-block;
    box-sizing: border-box;
    animation: rotation 1s linear infinite;
  }

  #error-container {
    position: absolute;
    top: 0;
    height: 100%;
    width: 100%;
    background-color: #ff000006;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  #error-text {
    font-size: 24px;
    color: red;
  }

  @keyframes rotation {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }
`;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __decorateClass = (Y, D, w2, O) => {
    for (var x2 = O > 1 ? void 0 : O ? __getOwnPropDesc(D, w2) : D, U = Y.length - 1, F; U >= 0; U--)
      (F = Y[U]) && (x2 = (O ? F(D, w2, x2) : F(x2)) || x2);
    return O && x2 && __defProp2(D, w2, x2), x2;
  };
  var ActiveTable = class extends i2 {
    constructor() {
      super(), this.getData = () => JSON.parse(JSON.stringify(this.data)), this.getColumnsDetails = () => ColumnDetailsUtils.getAllColumnsDetails(this._columnsDetails), this.updateCell = (Y) => {
        ProgrammaticCellUpdate.updateText(this, Y);
      }, this.updateStructure = (Y) => {
        ProgrammaticStructureUpdate.update(this, Y);
      }, this.updateData = (Y) => {
        UpdateAllTableData.update(this, Y, 0);
      }, this.importFile = (Y) => FileImportButtonEvents.triggerImportPrompt(this, Y), this.exportFile = (Y) => FileExportEvents.export(this, Y), this.onCellUpdate = () => {
      }, this.onDataUpdate = () => {
      }, this.onColumnsUpdate = () => {
      }, this.onRender = () => {
      }, this.data = [
        // ['Planet', 'Diameter', 'Mass', 'Moons', 'Density'],
        // ['Earth', 12756, 5.97, 1, 5514],
        // ['Mars', 6792, 0.642, 2, 3934],
        // ['Jupiter', 142984, 1898, 79, 1326],
        // ['Saturn', 120536, 568, 82, 687],
        // ['Neptune', 49528, 102, 14, 1638],
      ], this.tableStyle = {}, this.allowDuplicateHeaders = true, this.displayHeaderIcons = true, this.spellCheck = false, this.customColumnsSettings = [], this.dragRows = true, this.dragColumns = true, this.preserveNarrowColumns = true, this.displayAddNewRow = true, this.displayAddNewColumn = true, this.displayIndexColumn = { wrapIndexCellText: false }, this.frameComponentsStyles = {}, this.dataStartsAtHeader = false, this.columnResizerColors = {}, this.rowDropdown = { displaySettings: { isAvailable: true, openMethod: { cellClick: true } } }, this.enterKeyMoveDown = false, this._stickyProps = { header: false }, this._defaultColumnsSettings = {}, this._customColumnsSettings = {}, this._columnsDetails = [], this._addColumnCellsElementsRef = [], this._focusedElements = FocusedElementsUtils.createEmpty(), this._hoveredElements = {}, this._activeOverlayElements = ActiveOverlayElementsUtils.createNew(), this._eventFunctions = ElementEvents.getDefault(), this._userKeyEventsState = UserKeyEventsStateUtils.createNew(), this._tableDimensions = TableDimensionsUtils.getDefault(), this._globalItemColors = LabelColorUtils.generateGlobalItemColors(), this._defaultCellHoverColors = CellHighlightUtils.getDefaultHoverProperties(), this._frameComponents = FrameComponentsInternalUtils.getDefault(), this._rowDropdownCellOverlays = [], this._pagination = PaginationInternalUtils.getDefault(), this._files = FilesUtils.createDefault(this), this._visiblityInternal = {}, this._isRendering = false, this._isPopulatingTable = false, GoogleFont.appendStyleSheetToHead();
    }
    // CAUTION-4
    render() {
      Render.renderTable(this), this.onDataUpdate(this.data), new ResizeObserver(ParentResize.resizeCallback.bind(this)).observe(this.parentElement), FireEvents.onRender(this);
    }
    async update(Y) {
      var w2, O;
      PaginationAsyncUtils.preprocessTablePropertiesIfAsync(this), this._isPopulatingTable = true, StickyPropsUtils.process(this), ColumnSettingsUtils.setUpInternalSettings(this), FrameComponentsInternalUtils.set(this), DefaultColumnTypes.createDropdownItemsForDefaultTypes(), RowDropdownSettingsUtil.process(this), this.pagination && await PaginationInternalUtils.process(this), this.stripedRows && StripedRows.process(this), this.rowHoverStyles && RowHoverEvents.process(this.rowHoverStyles, this._defaultCellHoverColors);
      const D = TableElement.createInfrastructureElements(this);
      this.overflow && OverflowUtils.setupContainer(this, D), TableElement.addOverlayElements(this, D, this._activeOverlayElements), PaginationAsyncUtils.removeLoadingOverlay(this), (O = this.shadowRoot) == null || O.appendChild(((w2 = this._overflow) == null ? void 0 : w2.overflowContainer) || D), OuterTableComponents.create(this), InitialDataProcessing.preProcess(this, this.data), WindowElement.setEvents(this), this.spellcheck = this.spellCheck, this.auxiliaryStyle && this.shadowRoot && WebComponentStyleUtils.add(this.auxiliaryStyle, this.shadowRoot), setTimeout(() => this._isPopulatingTable = false, 1), super.update(Y);
    }
    connectedCallback() {
      Browser.IS_FIREFOX ? setTimeout(() => super.connectedCallback()) : super.connectedCallback();
    }
    // this is used to prevent a bug where the update method is called again (and adds another table) when a new property is
    // added - e.g. an event listener method
    shouldUpdate() {
      return !this._tableElementRef;
    }
  };
  ActiveTable._ELEMENT_TAG = "ACTIVE-TABLE";
  ActiveTable.styles = [activeTableStyle];
  __decorateClass([
    n$1({ attribute: false })
  ], ActiveTable.prototype, "getData", 2);
  __decorateClass([
    n$1({ attribute: false })
  ], ActiveTable.prototype, "getColumnsDetails", 2);
  __decorateClass([
    n$1({ attribute: false })
  ], ActiveTable.prototype, "updateCell", 2);
  __decorateClass([
    n$1({ attribute: false })
  ], ActiveTable.prototype, "updateStructure", 2);
  __decorateClass([
    n$1({ attribute: false })
  ], ActiveTable.prototype, "updateData", 2);
  __decorateClass([
    n$1({ attribute: false })
  ], ActiveTable.prototype, "importFile", 2);
  __decorateClass([
    n$1({ attribute: false })
  ], ActiveTable.prototype, "exportFile", 2);
  __decorateClass([
    n$1({ converter: LITElementTypeConverters.convertToFunction })
  ], ActiveTable.prototype, "onCellUpdate", 2);
  __decorateClass([
    n$1({ converter: LITElementTypeConverters.convertToFunction })
  ], ActiveTable.prototype, "onDataUpdate", 2);
  __decorateClass([
    n$1({ converter: LITElementTypeConverters.convertToFunction })
  ], ActiveTable.prototype, "onColumnsUpdate", 2);
  __decorateClass([
    n$1({ converter: LITElementTypeConverters.convertToFunction })
  ], ActiveTable.prototype, "onRender", 2);
  __decorateClass([
    n$1({ type: Array })
  ], ActiveTable.prototype, "data", 2);
  __decorateClass([
    n$1({ type: Object })
  ], ActiveTable.prototype, "tableStyle", 2);
  __decorateClass([
    n$1({
      type: Boolean,
      converter: LITElementTypeConverters.convertToBoolean
    })
  ], ActiveTable.prototype, "allowDuplicateHeaders", 2);
  __decorateClass([
    n$1({
      type: Boolean,
      converter: LITElementTypeConverters.convertToBoolean
    })
  ], ActiveTable.prototype, "displayHeaderIcons", 2);
  __decorateClass([
    n$1({
      type: Boolean,
      converter: LITElementTypeConverters.convertToBoolean
    })
  ], ActiveTable.prototype, "spellCheck", 2);
  __decorateClass([
    n$1({
      type: Boolean,
      converter: LITElementTypeConverters.convertToBoolean
    })
  ], ActiveTable.prototype, "stickyHeader", 2);
  __decorateClass([
    n$1({ type: Array })
  ], ActiveTable.prototype, "customColumnsSettings", 2);
  __decorateClass([
    n$1({ type: Object })
  ], ActiveTable.prototype, "rowHoverStyles", 2);
  __decorateClass([
    n$1({
      type: Boolean,
      converter: LITElementTypeConverters.convertToBoolean
    })
  ], ActiveTable.prototype, "dragRows", 2);
  __decorateClass([
    n$1({
      type: Boolean,
      converter: LITElementTypeConverters.convertToBoolean
    })
  ], ActiveTable.prototype, "dragColumns", 2);
  __decorateClass([
    n$1({
      type: Boolean,
      converter: LITElementTypeConverters.convertToBoolean
    })
  ], ActiveTable.prototype, "preserveNarrowColumns", 2);
  __decorateClass([
    n$1({ type: Number })
  ], ActiveTable.prototype, "maxColumns", 2);
  __decorateClass([
    n$1({ type: Number })
  ], ActiveTable.prototype, "maxRows", 2);
  __decorateClass([
    n$1({
      type: Boolean,
      converter: LITElementTypeConverters.convertToBoolean
    })
  ], ActiveTable.prototype, "displayAddNewRow", 2);
  __decorateClass([
    n$1({
      type: Boolean,
      converter: LITElementTypeConverters.convertToBoolean
    })
  ], ActiveTable.prototype, "displayAddNewColumn", 2);
  __decorateClass([
    n$1({ type: Object })
  ], ActiveTable.prototype, "displayIndexColumn", 2);
  __decorateClass([
    n$1({ type: Object })
  ], ActiveTable.prototype, "frameComponentsStyles", 2);
  __decorateClass([
    n$1({
      type: Boolean,
      converter: LITElementTypeConverters.convertToBoolean
    })
  ], ActiveTable.prototype, "dataStartsAtHeader", 2);
  __decorateClass([
    n$1({ type: Object })
  ], ActiveTable.prototype, "columnResizerColors", 2);
  __decorateClass([
    n$1({ type: Object })
  ], ActiveTable.prototype, "rowDropdown", 2);
  __decorateClass([
    n$1({ type: Object })
  ], ActiveTable.prototype, "stripedRows", 2);
  __decorateClass([
    n$1({ type: Object })
  ], ActiveTable.prototype, "overflow", 2);
  __decorateClass([
    n$1({ type: String })
  ], ActiveTable.prototype, "defaultText", 2);
  __decorateClass([
    n$1({
      type: Boolean,
      converter: LITElementTypeConverters.convertToBoolean
    })
  ], ActiveTable.prototype, "isDefaultTextRemovable", 2);
  __decorateClass([
    n$1({ type: Object })
  ], ActiveTable.prototype, "cellStyle", 2);
  __decorateClass([
    n$1({ type: Object })
  ], ActiveTable.prototype, "rootCell", 2);
  __decorateClass([
    n$1({
      type: Boolean,
      converter: LITElementTypeConverters.convertToBoolean
    })
  ], ActiveTable.prototype, "isCellTextEditable", 2);
  __decorateClass([
    n$1({ type: Object })
  ], ActiveTable.prototype, "headerStyles", 2);
  __decorateClass([
    n$1({
      type: Boolean,
      converter: LITElementTypeConverters.convertToBoolean
    })
  ], ActiveTable.prototype, "isHeaderTextEditable", 2);
  __decorateClass([
    n$1({ type: Object })
  ], ActiveTable.prototype, "headerIconStyle", 2);
  __decorateClass([
    n$1({
      type: Boolean,
      converter: LITElementTypeConverters.convertToBoolean
    })
  ], ActiveTable.prototype, "isColumnResizable", 2);
  __decorateClass([
    n$1({ type: Array })
  ], ActiveTable.prototype, "availableDefaultColumnTypes", 2);
  __decorateClass([
    n$1({ type: Array })
  ], ActiveTable.prototype, "customColumnTypes", 2);
  __decorateClass([
    n$1({ type: String })
  ], ActiveTable.prototype, "defaultColumnTypeName", 2);
  __decorateClass([
    n$1({ type: Object })
  ], ActiveTable.prototype, "columnDropdown", 2);
  __decorateClass([
    n$1({
      type: Boolean,
      converter: LITElementTypeConverters.convertToBoolean
    })
  ], ActiveTable.prototype, "enterKeyMoveDown", 2);
  __decorateClass([
    n$1({ type: Object })
  ], ActiveTable.prototype, "pagination", 2);
  __decorateClass([
    n$1({ type: Object })
  ], ActiveTable.prototype, "loadingStyles", 2);
  __decorateClass([
    n$1({ type: Object })
  ], ActiveTable.prototype, "files", 2);
  __decorateClass([
    n$1({ type: Object })
  ], ActiveTable.prototype, "filter", 2);
  __decorateClass([
    n$1({ type: String })
  ], ActiveTable.prototype, "auxiliaryStyle", 2);
  __decorateClass([
    r$1()
  ], ActiveTable.prototype, "_stickyProps", 2);
  __decorateClass([
    r$1()
  ], ActiveTable.prototype, "_defaultColumnsSettings", 2);
  __decorateClass([
    r$1()
  ], ActiveTable.prototype, "_customColumnsSettings", 2);
  __decorateClass([
    r$1()
  ], ActiveTable.prototype, "_columnsDetails", 2);
  __decorateClass([
    r$1()
  ], ActiveTable.prototype, "_tableElementRef", 2);
  __decorateClass([
    r$1()
  ], ActiveTable.prototype, "_tableBodyElementRef", 2);
  __decorateClass([
    r$1()
  ], ActiveTable.prototype, "_addRowCellElementRef", 2);
  __decorateClass([
    r$1()
  ], ActiveTable.prototype, "_addColumnCellsElementsRef", 2);
  __decorateClass([
    r$1()
  ], ActiveTable.prototype, "_focusedElements", 2);
  __decorateClass([
    r$1()
  ], ActiveTable.prototype, "_hoveredElements", 2);
  __decorateClass([
    r$1()
  ], ActiveTable.prototype, "_activeOverlayElements", 2);
  __decorateClass([
    r$1()
  ], ActiveTable.prototype, "_eventFunctions", 2);
  __decorateClass([
    r$1()
  ], ActiveTable.prototype, "_userKeyEventsState", 2);
  __decorateClass([
    r$1()
  ], ActiveTable.prototype, "_tableDimensions", 2);
  __decorateClass([
    r$1()
  ], ActiveTable.prototype, "_cellDropdownContainer", 2);
  __decorateClass([
    r$1()
  ], ActiveTable.prototype, "_globalItemColors", 2);
  __decorateClass([
    r$1()
  ], ActiveTable.prototype, "_defaultCellHoverColors", 2);
  __decorateClass([
    r$1()
  ], ActiveTable.prototype, "_frameComponents", 2);
  __decorateClass([
    r$1()
  ], ActiveTable.prototype, "_rowDropdownCellOverlays", 2);
  __decorateClass([
    r$1()
  ], ActiveTable.prototype, "_stripedRows", 2);
  __decorateClass([
    r$1()
  ], ActiveTable.prototype, "_overflow", 2);
  __decorateClass([
    r$1()
  ], ActiveTable.prototype, "_pagination", 2);
  __decorateClass([
    r$1()
  ], ActiveTable.prototype, "_files", 2);
  __decorateClass([
    r$1()
  ], ActiveTable.prototype, "_visiblityInternal", 2);
  __decorateClass([
    r$1({
      hasChanged() {
        return false;
      }
    })
  ], ActiveTable.prototype, "_isRendering", 2);
  __decorateClass([
    r$1({
      hasChanged() {
        return false;
      }
    })
  ], ActiveTable.prototype, "_isPopulatingTable", 2);
  ActiveTable = __decorateClass([
    t$2("active-table")
  ], ActiveTable);

  // node_modules/@lit/reactive-element/css-tag.js
  var t2 = globalThis;
  var e2 = t2.ShadowRoot && (void 0 === t2.ShadyCSS || t2.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
  var s2 = Symbol();
  var o3 = /* @__PURE__ */ new WeakMap();
  var n2 = class {
    constructor(t7, e13, o14) {
      if (this._$cssResult$ = true, o14 !== s2)
        throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
      this.cssText = t7, this.t = e13;
    }
    get styleSheet() {
      let t7 = this.o;
      const s6 = this.t;
      if (e2 && void 0 === t7) {
        const e13 = void 0 !== s6 && 1 === s6.length;
        e13 && (t7 = o3.get(s6)), void 0 === t7 && ((this.o = t7 = new CSSStyleSheet()).replaceSync(this.cssText), e13 && o3.set(s6, t7));
      }
      return t7;
    }
    toString() {
      return this.cssText;
    }
  };
  var r2 = (t7) => new n2("string" == typeof t7 ? t7 : t7 + "", void 0, s2);
  var i3 = (t7, ...e13) => {
    const o14 = 1 === t7.length ? t7[0] : e13.reduce((e14, s6, o15) => e14 + ((t8) => {
      if (true === t8._$cssResult$)
        return t8.cssText;
      if ("number" == typeof t8)
        return t8;
      throw Error("Value passed to 'css' function must be a 'css' function result: " + t8 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
    })(s6) + t7[o15 + 1], t7[0]);
    return new n2(o14, t7, s2);
  };
  var S2 = (s6, o14) => {
    if (e2)
      s6.adoptedStyleSheets = o14.map((t7) => t7 instanceof CSSStyleSheet ? t7 : t7.styleSheet);
    else
      for (const e13 of o14) {
        const o15 = document.createElement("style"), n10 = t2.litNonce;
        void 0 !== n10 && o15.setAttribute("nonce", n10), o15.textContent = e13.cssText, s6.appendChild(o15);
      }
  };
  var c2 = e2 ? (t7) => t7 : (t7) => t7 instanceof CSSStyleSheet ? ((t8) => {
    let e13 = "";
    for (const s6 of t8.cssRules)
      e13 += s6.cssText;
    return r2(e13);
  })(t7) : t7;

  // node_modules/@lit/reactive-element/reactive-element.js
  var { is: i4, defineProperty: e3, getOwnPropertyDescriptor: h2, getOwnPropertyNames: r3, getOwnPropertySymbols: o4, getPrototypeOf: n3 } = Object;
  var a2 = globalThis;
  var c3 = a2.trustedTypes;
  var l2 = c3 ? c3.emptyScript : "";
  var p2 = a2.reactiveElementPolyfillSupport;
  var d2 = (t7, s6) => t7;
  var u2 = { toAttribute(t7, s6) {
    switch (s6) {
      case Boolean:
        t7 = t7 ? l2 : null;
        break;
      case Object:
      case Array:
        t7 = null == t7 ? t7 : JSON.stringify(t7);
    }
    return t7;
  }, fromAttribute(t7, s6) {
    let i11 = t7;
    switch (s6) {
      case Boolean:
        i11 = null !== t7;
        break;
      case Number:
        i11 = null === t7 ? null : Number(t7);
        break;
      case Object:
      case Array:
        try {
          i11 = JSON.parse(t7);
        } catch (t8) {
          i11 = null;
        }
    }
    return i11;
  } };
  var f2 = (t7, s6) => !i4(t7, s6);
  var b2 = { attribute: true, type: String, converter: u2, reflect: false, useDefault: false, hasChanged: f2 };
  Symbol.metadata ??= Symbol("metadata"), a2.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
  var y2 = class extends HTMLElement {
    static addInitializer(t7) {
      this._$Ei(), (this.l ??= []).push(t7);
    }
    static get observedAttributes() {
      return this.finalize(), this._$Eh && [...this._$Eh.keys()];
    }
    static createProperty(t7, s6 = b2) {
      if (s6.state && (s6.attribute = false), this._$Ei(), this.prototype.hasOwnProperty(t7) && ((s6 = Object.create(s6)).wrapped = true), this.elementProperties.set(t7, s6), !s6.noAccessor) {
        const i11 = Symbol(), h6 = this.getPropertyDescriptor(t7, i11, s6);
        void 0 !== h6 && e3(this.prototype, t7, h6);
      }
    }
    static getPropertyDescriptor(t7, s6, i11) {
      const { get: e13, set: r9 } = h2(this.prototype, t7) ?? { get() {
        return this[s6];
      }, set(t8) {
        this[s6] = t8;
      } };
      return { get: e13, set(s7) {
        const h6 = e13?.call(this);
        r9?.call(this, s7), this.requestUpdate(t7, h6, i11);
      }, configurable: true, enumerable: true };
    }
    static getPropertyOptions(t7) {
      return this.elementProperties.get(t7) ?? b2;
    }
    static _$Ei() {
      if (this.hasOwnProperty(d2("elementProperties")))
        return;
      const t7 = n3(this);
      t7.finalize(), void 0 !== t7.l && (this.l = [...t7.l]), this.elementProperties = new Map(t7.elementProperties);
    }
    static finalize() {
      if (this.hasOwnProperty(d2("finalized")))
        return;
      if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d2("properties"))) {
        const t8 = this.properties, s6 = [...r3(t8), ...o4(t8)];
        for (const i11 of s6)
          this.createProperty(i11, t8[i11]);
      }
      const t7 = this[Symbol.metadata];
      if (null !== t7) {
        const s6 = litPropertyMetadata.get(t7);
        if (void 0 !== s6)
          for (const [t8, i11] of s6)
            this.elementProperties.set(t8, i11);
      }
      this._$Eh = /* @__PURE__ */ new Map();
      for (const [t8, s6] of this.elementProperties) {
        const i11 = this._$Eu(t8, s6);
        void 0 !== i11 && this._$Eh.set(i11, t8);
      }
      this.elementStyles = this.finalizeStyles(this.styles);
    }
    static finalizeStyles(s6) {
      const i11 = [];
      if (Array.isArray(s6)) {
        const e13 = new Set(s6.flat(1 / 0).reverse());
        for (const s7 of e13)
          i11.unshift(c2(s7));
      } else
        void 0 !== s6 && i11.push(c2(s6));
      return i11;
    }
    static _$Eu(t7, s6) {
      const i11 = s6.attribute;
      return false === i11 ? void 0 : "string" == typeof i11 ? i11 : "string" == typeof t7 ? t7.toLowerCase() : void 0;
    }
    constructor() {
      super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
    }
    _$Ev() {
      this._$ES = new Promise((t7) => this.enableUpdating = t7), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t7) => t7(this));
    }
    addController(t7) {
      (this._$EO ??= /* @__PURE__ */ new Set()).add(t7), void 0 !== this.renderRoot && this.isConnected && t7.hostConnected?.();
    }
    removeController(t7) {
      this._$EO?.delete(t7);
    }
    _$E_() {
      const t7 = /* @__PURE__ */ new Map(), s6 = this.constructor.elementProperties;
      for (const i11 of s6.keys())
        this.hasOwnProperty(i11) && (t7.set(i11, this[i11]), delete this[i11]);
      t7.size > 0 && (this._$Ep = t7);
    }
    createRenderRoot() {
      const t7 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
      return S2(t7, this.constructor.elementStyles), t7;
    }
    connectedCallback() {
      this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t7) => t7.hostConnected?.());
    }
    enableUpdating(t7) {
    }
    disconnectedCallback() {
      this._$EO?.forEach((t7) => t7.hostDisconnected?.());
    }
    attributeChangedCallback(t7, s6, i11) {
      this._$AK(t7, i11);
    }
    _$ET(t7, s6) {
      const i11 = this.constructor.elementProperties.get(t7), e13 = this.constructor._$Eu(t7, i11);
      if (void 0 !== e13 && true === i11.reflect) {
        const h6 = (void 0 !== i11.converter?.toAttribute ? i11.converter : u2).toAttribute(s6, i11.type);
        this._$Em = t7, null == h6 ? this.removeAttribute(e13) : this.setAttribute(e13, h6), this._$Em = null;
      }
    }
    _$AK(t7, s6) {
      const i11 = this.constructor, e13 = i11._$Eh.get(t7);
      if (void 0 !== e13 && this._$Em !== e13) {
        const t8 = i11.getPropertyOptions(e13), h6 = "function" == typeof t8.converter ? { fromAttribute: t8.converter } : void 0 !== t8.converter?.fromAttribute ? t8.converter : u2;
        this._$Em = e13;
        const r9 = h6.fromAttribute(s6, t8.type);
        this[e13] = r9 ?? this._$Ej?.get(e13) ?? r9, this._$Em = null;
      }
    }
    requestUpdate(t7, s6, i11) {
      if (void 0 !== t7) {
        const e13 = this.constructor, h6 = this[t7];
        if (i11 ??= e13.getPropertyOptions(t7), !((i11.hasChanged ?? f2)(h6, s6) || i11.useDefault && i11.reflect && h6 === this._$Ej?.get(t7) && !this.hasAttribute(e13._$Eu(t7, i11))))
          return;
        this.C(t7, s6, i11);
      }
      false === this.isUpdatePending && (this._$ES = this._$EP());
    }
    C(t7, s6, { useDefault: i11, reflect: e13, wrapped: h6 }, r9) {
      i11 && !(this._$Ej ??= /* @__PURE__ */ new Map()).has(t7) && (this._$Ej.set(t7, r9 ?? s6 ?? this[t7]), true !== h6 || void 0 !== r9) || (this._$AL.has(t7) || (this.hasUpdated || i11 || (s6 = void 0), this._$AL.set(t7, s6)), true === e13 && this._$Em !== t7 && (this._$Eq ??= /* @__PURE__ */ new Set()).add(t7));
    }
    async _$EP() {
      this.isUpdatePending = true;
      try {
        await this._$ES;
      } catch (t8) {
        Promise.reject(t8);
      }
      const t7 = this.scheduleUpdate();
      return null != t7 && await t7, !this.isUpdatePending;
    }
    scheduleUpdate() {
      return this.performUpdate();
    }
    performUpdate() {
      if (!this.isUpdatePending)
        return;
      if (!this.hasUpdated) {
        if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
          for (const [t9, s7] of this._$Ep)
            this[t9] = s7;
          this._$Ep = void 0;
        }
        const t8 = this.constructor.elementProperties;
        if (t8.size > 0)
          for (const [s7, i11] of t8) {
            const { wrapped: t9 } = i11, e13 = this[s7];
            true !== t9 || this._$AL.has(s7) || void 0 === e13 || this.C(s7, void 0, i11, e13);
          }
      }
      let t7 = false;
      const s6 = this._$AL;
      try {
        t7 = this.shouldUpdate(s6), t7 ? (this.willUpdate(s6), this._$EO?.forEach((t8) => t8.hostUpdate?.()), this.update(s6)) : this._$EM();
      } catch (s7) {
        throw t7 = false, this._$EM(), s7;
      }
      t7 && this._$AE(s6);
    }
    willUpdate(t7) {
    }
    _$AE(t7) {
      this._$EO?.forEach((t8) => t8.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t7)), this.updated(t7);
    }
    _$EM() {
      this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
    }
    get updateComplete() {
      return this.getUpdateComplete();
    }
    getUpdateComplete() {
      return this._$ES;
    }
    shouldUpdate(t7) {
      return true;
    }
    update(t7) {
      this._$Eq &&= this._$Eq.forEach((t8) => this._$ET(t8, this[t8])), this._$EM();
    }
    updated(t7) {
    }
    firstUpdated(t7) {
    }
  };
  y2.elementStyles = [], y2.shadowRootOptions = { mode: "open" }, y2[d2("elementProperties")] = /* @__PURE__ */ new Map(), y2[d2("finalized")] = /* @__PURE__ */ new Map(), p2?.({ ReactiveElement: y2 }), (a2.reactiveElementVersions ??= []).push("2.1.1");

  // node_modules/lit-html/lit-html.js
  var t3 = globalThis;
  var i5 = t3.trustedTypes;
  var s3 = i5 ? i5.createPolicy("lit-html", { createHTML: (t7) => t7 }) : void 0;
  var e4 = "$lit$";
  var h3 = `lit$${Math.random().toFixed(9).slice(2)}$`;
  var o5 = "?" + h3;
  var n4 = `<${o5}>`;
  var r4 = document;
  var l3 = () => r4.createComment("");
  var c4 = (t7) => null === t7 || "object" != typeof t7 && "function" != typeof t7;
  var a3 = Array.isArray;
  var u3 = (t7) => a3(t7) || "function" == typeof t7?.[Symbol.iterator];
  var d3 = "[ 	\n\f\r]";
  var f3 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
  var v2 = /-->/g;
  var _2 = />/g;
  var m2 = RegExp(`>|${d3}(?:([^\\s"'>=/]+)(${d3}*=${d3}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
  var p3 = /'/g;
  var g2 = /"/g;
  var $2 = /^(?:script|style|textarea|title)$/i;
  var y3 = (t7) => (i11, ...s6) => ({ _$litType$: t7, strings: i11, values: s6 });
  var x = y3(1);
  var b3 = y3(2);
  var w = y3(3);
  var T2 = Symbol.for("lit-noChange");
  var E2 = Symbol.for("lit-nothing");
  var A2 = /* @__PURE__ */ new WeakMap();
  var C2 = r4.createTreeWalker(r4, 129);
  function P2(t7, i11) {
    if (!a3(t7) || !t7.hasOwnProperty("raw"))
      throw Error("invalid template strings array");
    return void 0 !== s3 ? s3.createHTML(i11) : i11;
  }
  var V2 = (t7, i11) => {
    const s6 = t7.length - 1, o14 = [];
    let r9, l6 = 2 === i11 ? "<svg>" : 3 === i11 ? "<math>" : "", c7 = f3;
    for (let i12 = 0; i12 < s6; i12++) {
      const s7 = t7[i12];
      let a5, u6, d4 = -1, y4 = 0;
      for (; y4 < s7.length && (c7.lastIndex = y4, u6 = c7.exec(s7), null !== u6); )
        y4 = c7.lastIndex, c7 === f3 ? "!--" === u6[1] ? c7 = v2 : void 0 !== u6[1] ? c7 = _2 : void 0 !== u6[2] ? ($2.test(u6[2]) && (r9 = RegExp("</" + u6[2], "g")), c7 = m2) : void 0 !== u6[3] && (c7 = m2) : c7 === m2 ? ">" === u6[0] ? (c7 = r9 ?? f3, d4 = -1) : void 0 === u6[1] ? d4 = -2 : (d4 = c7.lastIndex - u6[2].length, a5 = u6[1], c7 = void 0 === u6[3] ? m2 : '"' === u6[3] ? g2 : p3) : c7 === g2 || c7 === p3 ? c7 = m2 : c7 === v2 || c7 === _2 ? c7 = f3 : (c7 = m2, r9 = void 0);
      const x2 = c7 === m2 && t7[i12 + 1].startsWith("/>") ? " " : "";
      l6 += c7 === f3 ? s7 + n4 : d4 >= 0 ? (o14.push(a5), s7.slice(0, d4) + e4 + s7.slice(d4) + h3 + x2) : s7 + h3 + (-2 === d4 ? i12 : x2);
    }
    return [P2(t7, l6 + (t7[s6] || "<?>") + (2 === i11 ? "</svg>" : 3 === i11 ? "</math>" : "")), o14];
  };
  var N2 = class _N {
    constructor({ strings: t7, _$litType$: s6 }, n10) {
      let r9;
      this.parts = [];
      let c7 = 0, a5 = 0;
      const u6 = t7.length - 1, d4 = this.parts, [f6, v3] = V2(t7, s6);
      if (this.el = _N.createElement(f6, n10), C2.currentNode = this.el.content, 2 === s6 || 3 === s6) {
        const t8 = this.el.content.firstChild;
        t8.replaceWith(...t8.childNodes);
      }
      for (; null !== (r9 = C2.nextNode()) && d4.length < u6; ) {
        if (1 === r9.nodeType) {
          if (r9.hasAttributes())
            for (const t8 of r9.getAttributeNames())
              if (t8.endsWith(e4)) {
                const i11 = v3[a5++], s7 = r9.getAttribute(t8).split(h3), e13 = /([.?@])?(.*)/.exec(i11);
                d4.push({ type: 1, index: c7, name: e13[2], strings: s7, ctor: "." === e13[1] ? H2 : "?" === e13[1] ? I2 : "@" === e13[1] ? L2 : k2 }), r9.removeAttribute(t8);
              } else
                t8.startsWith(h3) && (d4.push({ type: 6, index: c7 }), r9.removeAttribute(t8));
          if ($2.test(r9.tagName)) {
            const t8 = r9.textContent.split(h3), s7 = t8.length - 1;
            if (s7 > 0) {
              r9.textContent = i5 ? i5.emptyScript : "";
              for (let i11 = 0; i11 < s7; i11++)
                r9.append(t8[i11], l3()), C2.nextNode(), d4.push({ type: 2, index: ++c7 });
              r9.append(t8[s7], l3());
            }
          }
        } else if (8 === r9.nodeType)
          if (r9.data === o5)
            d4.push({ type: 2, index: c7 });
          else {
            let t8 = -1;
            for (; -1 !== (t8 = r9.data.indexOf(h3, t8 + 1)); )
              d4.push({ type: 7, index: c7 }), t8 += h3.length - 1;
          }
        c7++;
      }
    }
    static createElement(t7, i11) {
      const s6 = r4.createElement("template");
      return s6.innerHTML = t7, s6;
    }
  };
  function S3(t7, i11, s6 = t7, e13) {
    if (i11 === T2)
      return i11;
    let h6 = void 0 !== e13 ? s6._$Co?.[e13] : s6._$Cl;
    const o14 = c4(i11) ? void 0 : i11._$litDirective$;
    return h6?.constructor !== o14 && (h6?._$AO?.(false), void 0 === o14 ? h6 = void 0 : (h6 = new o14(t7), h6._$AT(t7, s6, e13)), void 0 !== e13 ? (s6._$Co ??= [])[e13] = h6 : s6._$Cl = h6), void 0 !== h6 && (i11 = S3(t7, h6._$AS(t7, i11.values), h6, e13)), i11;
  }
  var M2 = class {
    constructor(t7, i11) {
      this._$AV = [], this._$AN = void 0, this._$AD = t7, this._$AM = i11;
    }
    get parentNode() {
      return this._$AM.parentNode;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    u(t7) {
      const { el: { content: i11 }, parts: s6 } = this._$AD, e13 = (t7?.creationScope ?? r4).importNode(i11, true);
      C2.currentNode = e13;
      let h6 = C2.nextNode(), o14 = 0, n10 = 0, l6 = s6[0];
      for (; void 0 !== l6; ) {
        if (o14 === l6.index) {
          let i12;
          2 === l6.type ? i12 = new R2(h6, h6.nextSibling, this, t7) : 1 === l6.type ? i12 = new l6.ctor(h6, l6.name, l6.strings, this, t7) : 6 === l6.type && (i12 = new z2(h6, this, t7)), this._$AV.push(i12), l6 = s6[++n10];
        }
        o14 !== l6?.index && (h6 = C2.nextNode(), o14++);
      }
      return C2.currentNode = r4, e13;
    }
    p(t7) {
      let i11 = 0;
      for (const s6 of this._$AV)
        void 0 !== s6 && (void 0 !== s6.strings ? (s6._$AI(t7, s6, i11), i11 += s6.strings.length - 2) : s6._$AI(t7[i11])), i11++;
    }
  };
  var R2 = class _R {
    get _$AU() {
      return this._$AM?._$AU ?? this._$Cv;
    }
    constructor(t7, i11, s6, e13) {
      this.type = 2, this._$AH = E2, this._$AN = void 0, this._$AA = t7, this._$AB = i11, this._$AM = s6, this.options = e13, this._$Cv = e13?.isConnected ?? true;
    }
    get parentNode() {
      let t7 = this._$AA.parentNode;
      const i11 = this._$AM;
      return void 0 !== i11 && 11 === t7?.nodeType && (t7 = i11.parentNode), t7;
    }
    get startNode() {
      return this._$AA;
    }
    get endNode() {
      return this._$AB;
    }
    _$AI(t7, i11 = this) {
      t7 = S3(this, t7, i11), c4(t7) ? t7 === E2 || null == t7 || "" === t7 ? (this._$AH !== E2 && this._$AR(), this._$AH = E2) : t7 !== this._$AH && t7 !== T2 && this._(t7) : void 0 !== t7._$litType$ ? this.$(t7) : void 0 !== t7.nodeType ? this.T(t7) : u3(t7) ? this.k(t7) : this._(t7);
    }
    O(t7) {
      return this._$AA.parentNode.insertBefore(t7, this._$AB);
    }
    T(t7) {
      this._$AH !== t7 && (this._$AR(), this._$AH = this.O(t7));
    }
    _(t7) {
      this._$AH !== E2 && c4(this._$AH) ? this._$AA.nextSibling.data = t7 : this.T(r4.createTextNode(t7)), this._$AH = t7;
    }
    $(t7) {
      const { values: i11, _$litType$: s6 } = t7, e13 = "number" == typeof s6 ? this._$AC(t7) : (void 0 === s6.el && (s6.el = N2.createElement(P2(s6.h, s6.h[0]), this.options)), s6);
      if (this._$AH?._$AD === e13)
        this._$AH.p(i11);
      else {
        const t8 = new M2(e13, this), s7 = t8.u(this.options);
        t8.p(i11), this.T(s7), this._$AH = t8;
      }
    }
    _$AC(t7) {
      let i11 = A2.get(t7.strings);
      return void 0 === i11 && A2.set(t7.strings, i11 = new N2(t7)), i11;
    }
    k(t7) {
      a3(this._$AH) || (this._$AH = [], this._$AR());
      const i11 = this._$AH;
      let s6, e13 = 0;
      for (const h6 of t7)
        e13 === i11.length ? i11.push(s6 = new _R(this.O(l3()), this.O(l3()), this, this.options)) : s6 = i11[e13], s6._$AI(h6), e13++;
      e13 < i11.length && (this._$AR(s6 && s6._$AB.nextSibling, e13), i11.length = e13);
    }
    _$AR(t7 = this._$AA.nextSibling, i11) {
      for (this._$AP?.(false, true, i11); t7 !== this._$AB; ) {
        const i12 = t7.nextSibling;
        t7.remove(), t7 = i12;
      }
    }
    setConnected(t7) {
      void 0 === this._$AM && (this._$Cv = t7, this._$AP?.(t7));
    }
  };
  var k2 = class {
    get tagName() {
      return this.element.tagName;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    constructor(t7, i11, s6, e13, h6) {
      this.type = 1, this._$AH = E2, this._$AN = void 0, this.element = t7, this.name = i11, this._$AM = e13, this.options = h6, s6.length > 2 || "" !== s6[0] || "" !== s6[1] ? (this._$AH = Array(s6.length - 1).fill(new String()), this.strings = s6) : this._$AH = E2;
    }
    _$AI(t7, i11 = this, s6, e13) {
      const h6 = this.strings;
      let o14 = false;
      if (void 0 === h6)
        t7 = S3(this, t7, i11, 0), o14 = !c4(t7) || t7 !== this._$AH && t7 !== T2, o14 && (this._$AH = t7);
      else {
        const e14 = t7;
        let n10, r9;
        for (t7 = h6[0], n10 = 0; n10 < h6.length - 1; n10++)
          r9 = S3(this, e14[s6 + n10], i11, n10), r9 === T2 && (r9 = this._$AH[n10]), o14 ||= !c4(r9) || r9 !== this._$AH[n10], r9 === E2 ? t7 = E2 : t7 !== E2 && (t7 += (r9 ?? "") + h6[n10 + 1]), this._$AH[n10] = r9;
      }
      o14 && !e13 && this.j(t7);
    }
    j(t7) {
      t7 === E2 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t7 ?? "");
    }
  };
  var H2 = class extends k2 {
    constructor() {
      super(...arguments), this.type = 3;
    }
    j(t7) {
      this.element[this.name] = t7 === E2 ? void 0 : t7;
    }
  };
  var I2 = class extends k2 {
    constructor() {
      super(...arguments), this.type = 4;
    }
    j(t7) {
      this.element.toggleAttribute(this.name, !!t7 && t7 !== E2);
    }
  };
  var L2 = class extends k2 {
    constructor(t7, i11, s6, e13, h6) {
      super(t7, i11, s6, e13, h6), this.type = 5;
    }
    _$AI(t7, i11 = this) {
      if ((t7 = S3(this, t7, i11, 0) ?? E2) === T2)
        return;
      const s6 = this._$AH, e13 = t7 === E2 && s6 !== E2 || t7.capture !== s6.capture || t7.once !== s6.once || t7.passive !== s6.passive, h6 = t7 !== E2 && (s6 === E2 || e13);
      e13 && this.element.removeEventListener(this.name, this, s6), h6 && this.element.addEventListener(this.name, this, t7), this._$AH = t7;
    }
    handleEvent(t7) {
      "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t7) : this._$AH.handleEvent(t7);
    }
  };
  var z2 = class {
    constructor(t7, i11, s6) {
      this.element = t7, this.type = 6, this._$AN = void 0, this._$AM = i11, this.options = s6;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(t7) {
      S3(this, t7);
    }
  };
  var Z2 = { M: e4, P: h3, A: o5, C: 1, L: V2, R: M2, D: u3, V: S3, I: R2, H: k2, N: I2, U: L2, B: H2, F: z2 };
  var j2 = t3.litHtmlPolyfillSupport;
  j2?.(N2, R2), (t3.litHtmlVersions ??= []).push("3.3.1");
  var B2 = (t7, i11, s6) => {
    const e13 = s6?.renderBefore ?? i11;
    let h6 = e13._$litPart$;
    if (void 0 === h6) {
      const t8 = s6?.renderBefore ?? null;
      e13._$litPart$ = h6 = new R2(i11.insertBefore(l3(), t8), t8, void 0, s6 ?? {});
    }
    return h6._$AI(t7), h6;
  };

  // node_modules/lit-element/lit-element.js
  var s4 = globalThis;
  var i6 = class extends y2 {
    constructor() {
      super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
    }
    createRenderRoot() {
      const t7 = super.createRenderRoot();
      return this.renderOptions.renderBefore ??= t7.firstChild, t7;
    }
    update(t7) {
      const r9 = this.render();
      this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t7), this._$Do = B2(r9, this.renderRoot, this.renderOptions);
    }
    connectedCallback() {
      super.connectedCallback(), this._$Do?.setConnected(true);
    }
    disconnectedCallback() {
      super.disconnectedCallback(), this._$Do?.setConnected(false);
    }
    render() {
      return T2;
    }
  };
  i6._$litElement$ = true, i6["finalized"] = true, s4.litElementHydrateSupport?.({ LitElement: i6 });
  var o6 = s4.litElementPolyfillSupport;
  o6?.({ LitElement: i6 });
  (s4.litElementVersions ??= []).push("4.2.1");

  // node_modules/@lit/reactive-element/decorators/property.js
  var o7 = { attribute: true, type: String, converter: u2, reflect: false, hasChanged: f2 };
  var r5 = (t7 = o7, e13, r9) => {
    const { kind: n10, metadata: i11 } = r9;
    let s6 = globalThis.litPropertyMetadata.get(i11);
    if (void 0 === s6 && globalThis.litPropertyMetadata.set(i11, s6 = /* @__PURE__ */ new Map()), "setter" === n10 && ((t7 = Object.create(t7)).wrapped = true), s6.set(r9.name, t7), "accessor" === n10) {
      const { name: o14 } = r9;
      return { set(r10) {
        const n11 = e13.get.call(this);
        e13.set.call(this, r10), this.requestUpdate(o14, n11, t7);
      }, init(e14) {
        return void 0 !== e14 && this.C(o14, void 0, t7, e14), e14;
      } };
    }
    if ("setter" === n10) {
      const { name: o14 } = r9;
      return function(r10) {
        const n11 = this[o14];
        e13.call(this, r10), this.requestUpdate(o14, n11, t7);
      };
    }
    throw Error("Unsupported decorator location: " + n10);
  };
  function n5(t7) {
    return (e13, o14) => "object" == typeof o14 ? r5(t7, e13, o14) : ((t8, e14, o15) => {
      const r9 = e14.hasOwnProperty(o15);
      return e14.constructor.createProperty(o15, t8), r9 ? Object.getOwnPropertyDescriptor(e14, o15) : void 0;
    })(t7, e13, o14);
  }

  // node_modules/@lit/reactive-element/decorators/state.js
  function r6(r9) {
    return n5({ ...r9, state: true, attribute: false });
  }

  // node_modules/@lit/reactive-element/decorators/event-options.js
  function t4(t7) {
    return (n10, o14) => {
      const c7 = "function" == typeof n10 ? n10 : n10[o14];
      Object.assign(c7, t7);
    };
  }

  // node_modules/@lit/reactive-element/decorators/base.js
  var e5 = (e13, t7, c7) => (c7.configurable = true, c7.enumerable = true, Reflect.decorate && "object" != typeof t7 && Object.defineProperty(e13, t7, c7), c7);

  // node_modules/@lit/reactive-element/decorators/query.js
  function e6(e13, r9) {
    return (n10, s6, i11) => {
      const o14 = (t7) => t7.renderRoot?.querySelector(e13) ?? null;
      if (r9) {
        const { get: e14, set: r10 } = "object" == typeof s6 ? n10 : i11 ?? (() => {
          const t7 = Symbol();
          return { get() {
            return this[t7];
          }, set(e15) {
            this[t7] = e15;
          } };
        })();
        return e5(n10, s6, { get() {
          let t7 = e14.call(this);
          return void 0 === t7 && (t7 = o14(this), (null !== t7 || this.hasUpdated) && r10.call(this, t7)), t7;
        } });
      }
      return e5(n10, s6, { get() {
        return o14(this);
      } });
    };
  }

  // node_modules/lit-html/directive-helpers.js
  var { I: t5 } = Z2;
  var e7 = (o14, t7) => void 0 === t7 ? void 0 !== o14?._$litType$ : o14?._$litType$ === t7;
  var f4 = (o14) => void 0 === o14.strings;
  var u4 = {};
  var m3 = (o14, t7 = u4) => o14._$AH = t7;

  // node_modules/lit-html/directive.js
  var t6 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
  var e8 = (t7) => (...e13) => ({ _$litDirective$: t7, values: e13 });
  var i7 = class {
    constructor(t7) {
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AT(t7, e13, i11) {
      this._$Ct = t7, this._$AM = e13, this._$Ci = i11;
    }
    _$AS(t7, e13) {
      return this.update(t7, e13);
    }
    update(t7, e13) {
      return this.render(...e13);
    }
  };

  // node_modules/lit-html/async-directive.js
  var s5 = (i11, t7) => {
    const e13 = i11._$AN;
    if (void 0 === e13)
      return false;
    for (const i12 of e13)
      i12._$AO?.(t7, false), s5(i12, t7);
    return true;
  };
  var o8 = (i11) => {
    let t7, e13;
    do {
      if (void 0 === (t7 = i11._$AM))
        break;
      e13 = t7._$AN, e13.delete(i11), i11 = t7;
    } while (0 === e13?.size);
  };
  var r7 = (i11) => {
    for (let t7; t7 = i11._$AM; i11 = t7) {
      let e13 = t7._$AN;
      if (void 0 === e13)
        t7._$AN = e13 = /* @__PURE__ */ new Set();
      else if (e13.has(i11))
        break;
      e13.add(i11), c5(t7);
    }
  };
  function h4(i11) {
    void 0 !== this._$AN ? (o8(this), this._$AM = i11, r7(this)) : this._$AM = i11;
  }
  function n6(i11, t7 = false, e13 = 0) {
    const r9 = this._$AH, h6 = this._$AN;
    if (void 0 !== h6 && 0 !== h6.size)
      if (t7)
        if (Array.isArray(r9))
          for (let i12 = e13; i12 < r9.length; i12++)
            s5(r9[i12], false), o8(r9[i12]);
        else
          null != r9 && (s5(r9, false), o8(r9));
      else
        s5(this, i11);
  }
  var c5 = (i11) => {
    i11.type == t6.CHILD && (i11._$AP ??= n6, i11._$AQ ??= h4);
  };
  var f5 = class extends i7 {
    constructor() {
      super(...arguments), this._$AN = void 0;
    }
    _$AT(i11, t7, e13) {
      super._$AT(i11, t7, e13), r7(this), this.isConnected = i11._$AU;
    }
    _$AO(i11, t7 = true) {
      i11 !== this.isConnected && (this.isConnected = i11, i11 ? this.reconnected?.() : this.disconnected?.()), t7 && (s5(this, i11), o8(this));
    }
    setValue(t7) {
      if (f4(this._$Ct))
        this._$Ct._$AI(t7, this);
      else {
        const i11 = [...this._$Ct._$AH];
        i11[this._$Ci] = t7, this._$Ct._$AI(i11, this, 0);
      }
    }
    disconnected() {
    }
    reconnected() {
    }
  };

  // node_modules/lit-html/directives/ref.js
  var e9 = () => new h5();
  var h5 = class {
  };
  var o9 = /* @__PURE__ */ new WeakMap();
  var n7 = e8(class extends f5 {
    render(i11) {
      return E2;
    }
    update(i11, [s6]) {
      const e13 = s6 !== this.G;
      return e13 && void 0 !== this.G && this.rt(void 0), (e13 || this.lt !== this.ct) && (this.G = s6, this.ht = i11.options?.host, this.rt(this.ct = i11.element)), E2;
    }
    rt(t7) {
      if (this.isConnected || (t7 = void 0), "function" == typeof this.G) {
        const i11 = this.ht ?? globalThis;
        let s6 = o9.get(i11);
        void 0 === s6 && (s6 = /* @__PURE__ */ new WeakMap(), o9.set(i11, s6)), void 0 !== s6.get(this.G) && this.G.call(this.ht, void 0), s6.set(this.G, t7), void 0 !== t7 && this.G.call(this.ht, t7);
      } else
        this.G.value = t7;
    }
    get lt() {
      return "function" == typeof this.G ? o9.get(this.ht ?? globalThis)?.get(this.G) : this.G?.value;
    }
    disconnected() {
      this.lt === this.ct && this.rt(void 0);
    }
    reconnected() {
      this.rt(this.ct);
    }
  });

  // node_modules/lodash-es/_freeGlobal.js
  var freeGlobal = typeof window == "object" && window && window.Object === Object && window;
  var freeGlobal_default = freeGlobal;

  // node_modules/lodash-es/_root.js
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal_default || freeSelf || Function("return this")();
  var root_default = root;

  // node_modules/lodash-es/_Symbol.js
  var Symbol2 = root_default.Symbol;
  var Symbol_default = Symbol2;

  // node_modules/lodash-es/_getRawTag.js
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
  function getRawTag(value2) {
    var isOwn = hasOwnProperty.call(value2, symToStringTag), tag = value2[symToStringTag];
    try {
      value2[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e13) {
    }
    var result = nativeObjectToString.call(value2);
    if (unmasked) {
      if (isOwn) {
        value2[symToStringTag] = tag;
      } else {
        delete value2[symToStringTag];
      }
    }
    return result;
  }
  var getRawTag_default = getRawTag;

  // node_modules/lodash-es/_objectToString.js
  var objectProto2 = Object.prototype;
  var nativeObjectToString2 = objectProto2.toString;
  function objectToString(value2) {
    return nativeObjectToString2.call(value2);
  }
  var objectToString_default = objectToString;

  // node_modules/lodash-es/_baseGetTag.js
  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
  function baseGetTag(value2) {
    if (value2 == null) {
      return value2 === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag2 && symToStringTag2 in Object(value2) ? getRawTag_default(value2) : objectToString_default(value2);
  }
  var baseGetTag_default = baseGetTag;

  // node_modules/lodash-es/isObject.js
  function isObject(value2) {
    var type = typeof value2;
    return value2 != null && (type == "object" || type == "function");
  }
  var isObject_default = isObject;

  // node_modules/lodash-es/isFunction.js
  var asyncTag = "[object AsyncFunction]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var proxyTag = "[object Proxy]";
  function isFunction(value2) {
    if (!isObject_default(value2)) {
      return false;
    }
    var tag = baseGetTag_default(value2);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  var isFunction_default = isFunction;

  // node_modules/lodash-es/_coreJsData.js
  var coreJsData = root_default["__core-js_shared__"];
  var coreJsData_default = coreJsData;

  // node_modules/lodash-es/_isMasked.js
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  var isMasked_default = isMasked;

  // node_modules/lodash-es/_toSource.js
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e13) {
      }
      try {
        return func + "";
      } catch (e13) {
      }
    }
    return "";
  }
  var toSource_default = toSource;

  // node_modules/lodash-es/_baseIsNative.js
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto2 = Function.prototype;
  var objectProto3 = Object.prototype;
  var funcToString2 = funcProto2.toString;
  var hasOwnProperty2 = objectProto3.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value2) {
    if (!isObject_default(value2) || isMasked_default(value2)) {
      return false;
    }
    var pattern = isFunction_default(value2) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource_default(value2));
  }
  var baseIsNative_default = baseIsNative;

  // node_modules/lodash-es/_getValue.js
  function getValue(object2, key) {
    return object2 == null ? void 0 : object2[key];
  }
  var getValue_default = getValue;

  // node_modules/lodash-es/_getNative.js
  function getNative(object2, key) {
    var value2 = getValue_default(object2, key);
    return baseIsNative_default(value2) ? value2 : void 0;
  }
  var getNative_default = getNative;

  // node_modules/lodash-es/_defineProperty.js
  var defineProperty = function() {
    try {
      var func = getNative_default(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e13) {
    }
  }();
  var defineProperty_default = defineProperty;

  // node_modules/lodash-es/_baseAssignValue.js
  function baseAssignValue(object2, key, value2) {
    if (key == "__proto__" && defineProperty_default) {
      defineProperty_default(object2, key, {
        "configurable": true,
        "enumerable": true,
        "value": value2,
        "writable": true
      });
    } else {
      object2[key] = value2;
    }
  }
  var baseAssignValue_default = baseAssignValue;

  // node_modules/lodash-es/eq.js
  function eq(value2, other) {
    return value2 === other || value2 !== value2 && other !== other;
  }
  var eq_default = eq;

  // node_modules/lodash-es/_assignValue.js
  var objectProto4 = Object.prototype;
  var hasOwnProperty3 = objectProto4.hasOwnProperty;
  function assignValue(object2, key, value2) {
    var objValue = object2[key];
    if (!(hasOwnProperty3.call(object2, key) && eq_default(objValue, value2)) || value2 === void 0 && !(key in object2)) {
      baseAssignValue_default(object2, key, value2);
    }
  }
  var assignValue_default = assignValue;

  // node_modules/lodash-es/isArray.js
  var isArray = Array.isArray;
  var isArray_default = isArray;

  // node_modules/lodash-es/isObjectLike.js
  function isObjectLike(value2) {
    return value2 != null && typeof value2 == "object";
  }
  var isObjectLike_default = isObjectLike;

  // node_modules/lodash-es/isSymbol.js
  var symbolTag = "[object Symbol]";
  function isSymbol(value2) {
    return typeof value2 == "symbol" || isObjectLike_default(value2) && baseGetTag_default(value2) == symbolTag;
  }
  var isSymbol_default = isSymbol;

  // node_modules/lodash-es/_isKey.js
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
  var reIsPlainProp = /^\w*$/;
  function isKey(value2, object2) {
    if (isArray_default(value2)) {
      return false;
    }
    var type = typeof value2;
    if (type == "number" || type == "symbol" || type == "boolean" || value2 == null || isSymbol_default(value2)) {
      return true;
    }
    return reIsPlainProp.test(value2) || !reIsDeepProp.test(value2) || object2 != null && value2 in Object(object2);
  }
  var isKey_default = isKey;

  // node_modules/lodash-es/_nativeCreate.js
  var nativeCreate = getNative_default(Object, "create");
  var nativeCreate_default = nativeCreate;

  // node_modules/lodash-es/_hashClear.js
  function hashClear() {
    this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
    this.size = 0;
  }
  var hashClear_default = hashClear;

  // node_modules/lodash-es/_hashDelete.js
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  var hashDelete_default = hashDelete;

  // node_modules/lodash-es/_hashGet.js
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var objectProto5 = Object.prototype;
  var hasOwnProperty4 = objectProto5.hasOwnProperty;
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate_default) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty4.call(data, key) ? data[key] : void 0;
  }
  var hashGet_default = hashGet;

  // node_modules/lodash-es/_hashHas.js
  var objectProto6 = Object.prototype;
  var hasOwnProperty5 = objectProto6.hasOwnProperty;
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty5.call(data, key);
  }
  var hashHas_default = hashHas;

  // node_modules/lodash-es/_hashSet.js
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  function hashSet(key, value2) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate_default && value2 === void 0 ? HASH_UNDEFINED2 : value2;
    return this;
  }
  var hashSet_default = hashSet;

  // node_modules/lodash-es/_Hash.js
  function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear_default;
  Hash.prototype["delete"] = hashDelete_default;
  Hash.prototype.get = hashGet_default;
  Hash.prototype.has = hashHas_default;
  Hash.prototype.set = hashSet_default;
  var Hash_default = Hash;

  // node_modules/lodash-es/_listCacheClear.js
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  var listCacheClear_default = listCacheClear;

  // node_modules/lodash-es/_assocIndexOf.js
  function assocIndexOf(array2, key) {
    var length = array2.length;
    while (length--) {
      if (eq_default(array2[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  var assocIndexOf_default = assocIndexOf;

  // node_modules/lodash-es/_listCacheDelete.js
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf_default(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  var listCacheDelete_default = listCacheDelete;

  // node_modules/lodash-es/_listCacheGet.js
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf_default(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  var listCacheGet_default = listCacheGet;

  // node_modules/lodash-es/_listCacheHas.js
  function listCacheHas(key) {
    return assocIndexOf_default(this.__data__, key) > -1;
  }
  var listCacheHas_default = listCacheHas;

  // node_modules/lodash-es/_listCacheSet.js
  function listCacheSet(key, value2) {
    var data = this.__data__, index = assocIndexOf_default(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value2]);
    } else {
      data[index][1] = value2;
    }
    return this;
  }
  var listCacheSet_default = listCacheSet;

  // node_modules/lodash-es/_ListCache.js
  function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear_default;
  ListCache.prototype["delete"] = listCacheDelete_default;
  ListCache.prototype.get = listCacheGet_default;
  ListCache.prototype.has = listCacheHas_default;
  ListCache.prototype.set = listCacheSet_default;
  var ListCache_default = ListCache;

  // node_modules/lodash-es/_Map.js
  var Map2 = getNative_default(root_default, "Map");
  var Map_default = Map2;

  // node_modules/lodash-es/_mapCacheClear.js
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash_default(),
      "map": new (Map_default || ListCache_default)(),
      "string": new Hash_default()
    };
  }
  var mapCacheClear_default = mapCacheClear;

  // node_modules/lodash-es/_isKeyable.js
  function isKeyable(value2) {
    var type = typeof value2;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value2 !== "__proto__" : value2 === null;
  }
  var isKeyable_default = isKeyable;

  // node_modules/lodash-es/_getMapData.js
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  var getMapData_default = getMapData;

  // node_modules/lodash-es/_mapCacheDelete.js
  function mapCacheDelete(key) {
    var result = getMapData_default(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  var mapCacheDelete_default = mapCacheDelete;

  // node_modules/lodash-es/_mapCacheGet.js
  function mapCacheGet(key) {
    return getMapData_default(this, key).get(key);
  }
  var mapCacheGet_default = mapCacheGet;

  // node_modules/lodash-es/_mapCacheHas.js
  function mapCacheHas(key) {
    return getMapData_default(this, key).has(key);
  }
  var mapCacheHas_default = mapCacheHas;

  // node_modules/lodash-es/_mapCacheSet.js
  function mapCacheSet(key, value2) {
    var data = getMapData_default(this, key), size3 = data.size;
    data.set(key, value2);
    this.size += data.size == size3 ? 0 : 1;
    return this;
  }
  var mapCacheSet_default = mapCacheSet;

  // node_modules/lodash-es/_MapCache.js
  function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear_default;
  MapCache.prototype["delete"] = mapCacheDelete_default;
  MapCache.prototype.get = mapCacheGet_default;
  MapCache.prototype.has = mapCacheHas_default;
  MapCache.prototype.set = mapCacheSet_default;
  var MapCache_default = MapCache;

  // node_modules/lodash-es/memoize.js
  var FUNC_ERROR_TEXT = "Expected a function";
  function memoize(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache_default)();
    return memoized;
  }
  memoize.Cache = MapCache_default;
  var memoize_default = memoize;

  // node_modules/lodash-es/_memoizeCapped.js
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result = memoize_default(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });
    var cache = result.cache;
    return result;
  }
  var memoizeCapped_default = memoizeCapped;

  // node_modules/lodash-es/_stringToPath.js
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped_default(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46) {
      result.push("");
    }
    string.replace(rePropName, function(match, number2, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
    });
    return result;
  });
  var stringToPath_default = stringToPath;

  // node_modules/lodash-es/_arrayMap.js
  function arrayMap(array2, iteratee) {
    var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array2[index], index, array2);
    }
    return result;
  }
  var arrayMap_default = arrayMap;

  // node_modules/lodash-es/_baseToString.js
  var INFINITY = 1 / 0;
  var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
  var symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseToString(value2) {
    if (typeof value2 == "string") {
      return value2;
    }
    if (isArray_default(value2)) {
      return arrayMap_default(value2, baseToString) + "";
    }
    if (isSymbol_default(value2)) {
      return symbolToString ? symbolToString.call(value2) : "";
    }
    var result = value2 + "";
    return result == "0" && 1 / value2 == -INFINITY ? "-0" : result;
  }
  var baseToString_default = baseToString;

  // node_modules/lodash-es/toString.js
  function toString(value2) {
    return value2 == null ? "" : baseToString_default(value2);
  }
  var toString_default = toString;

  // node_modules/lodash-es/_castPath.js
  function castPath(value2, object2) {
    if (isArray_default(value2)) {
      return value2;
    }
    return isKey_default(value2, object2) ? [value2] : stringToPath_default(toString_default(value2));
  }
  var castPath_default = castPath;

  // node_modules/lodash-es/_isIndex.js
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value2, length) {
    var type = typeof value2;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
  }
  var isIndex_default = isIndex;

  // node_modules/lodash-es/_toKey.js
  var INFINITY2 = 1 / 0;
  function toKey(value2) {
    if (typeof value2 == "string" || isSymbol_default(value2)) {
      return value2;
    }
    var result = value2 + "";
    return result == "0" && 1 / value2 == -INFINITY2 ? "-0" : result;
  }
  var toKey_default = toKey;

  // node_modules/lodash-es/_baseSet.js
  function baseSet(object2, path, value2, customizer) {
    if (!isObject_default(object2)) {
      return object2;
    }
    path = castPath_default(path, object2);
    var index = -1, length = path.length, lastIndex = length - 1, nested = object2;
    while (nested != null && ++index < length) {
      var key = toKey_default(path[index]), newValue = value2;
      if (key === "__proto__" || key === "constructor" || key === "prototype") {
        return object2;
      }
      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : void 0;
        if (newValue === void 0) {
          newValue = isObject_default(objValue) ? objValue : isIndex_default(path[index + 1]) ? [] : {};
        }
      }
      assignValue_default(nested, key, newValue);
      nested = nested[key];
    }
    return object2;
  }
  var baseSet_default = baseSet;

  // node_modules/lodash-es/set.js
  function set(object2, path, value2) {
    return object2 == null ? object2 : baseSet_default(object2, path, value2);
  }
  var set_default = set;

  // node_modules/@jsfe/form/dist/esm/triage/array.js
  var fieldArray = (schema, dataLevel, path, uiState, uiOptions, handleChange, dig, schemaPath, widgets, required = false, level = 0) => {
    if (!Array.isArray(dataLevel))
      return x``;
    const addItemClick = (_event) => {
      dataLevel ||= [];
      if (!Array.isArray(dataLevel))
        return;
      if (typeof schema.items !== "object" || Array.isArray(schema.items))
        return;
      if (schema.items?.type === "string") {
        dataLevel.push(schema.items?.default || "");
      } else if (schema.items.properties) {
        dataLevel.push(schema.items?.default || {});
      } else if (schema.items?.type === "array") {
        dataLevel.push(schema.items?.default || []);
      }
      handleChange([...path, dataLevel.length - 1], dataLevel[dataLevel.length - 1], schemaPath);
    };
    const items = (itemWrapper) => {
      return dataLevel?.map?.((_item, index) => {
        if (typeof schema.items !== "object" || Array.isArray(schema.items) || !Array.isArray(dataLevel))
          return "";
        const schemaPathAugmented = [...schemaPath];
        schemaPathAugmented.push("items");
        const widget = dig(schema.items, dataLevel[index], [...path, index], uiState, uiOptions?.[index], schemaPathAugmented, required, level + 1);
        const move = (direction) => (_event) => {
          if (!Array.isArray(dataLevel))
            return;
          const hold = dataLevel[index];
          dataLevel[index] = dataLevel[index + direction];
          dataLevel[index + direction] = hold;
          handleChange([...path], dataLevel, schemaPath);
        };
        const controls = {
          wrapper: {
            dragover: (event) => {
              event.preventDefault();
              event.stopPropagation();
              const dataTransfer = event.dataTransfer;
              if (dataTransfer)
                dataTransfer.dropEffect = "move";
            },
            dragenter: (event) => {
              event.stopPropagation();
              event.target.closest("sl-card")?.setAttribute("data-dropzone", "");
            },
            dragleave: (event) => {
              event.stopPropagation();
              event.target.closest("sl-card")?.removeAttribute("data-dropzone");
            },
            drop: (event) => {
              event.stopPropagation();
              const idx = event.dataTransfer?.getData("integer");
              if (!idx)
                return;
              const originIndex = Number.parseInt(idx, 10);
              if (!Array.isArray(dataLevel))
                return;
              const hold = dataLevel[index];
              dataLevel[index] = dataLevel[originIndex];
              dataLevel[originIndex] = hold;
              handleChange([...path], dataLevel, schemaPathAugmented);
              console.log({ originIndex, idx });
              event.target.closest("sl-card")?.removeAttribute("data-dropzone");
            }
          },
          handle: {
            mousedown: (_event) => {
            },
            dragstart: (event) => {
              console.log(event);
              if (!event.dataTransfer)
                return;
              event.dataTransfer.setData("integer", String(index));
            }
          },
          delete: {
            click: (_event) => {
              if (!Array.isArray(dataLevel))
                return;
              dataLevel = dataLevel.filter((_3, i11) => i11 !== index);
              handleChange([...path], dataLevel, schemaPath);
            }
          },
          up: {
            click: move(-1),
            disabled: typeof dataLevel?.[index - 1] === "undefined"
          },
          down: {
            click: move(1),
            disabled: typeof dataLevel?.[index + 1] === "undefined"
          }
        };
        return itemWrapper(index, widget, controls);
      });
    };
    let itemLabel;
    if (typeof schema.items === "object" && !Array.isArray(schema.items) && schema.items.title) {
      itemLabel = schema.items.title;
    }
    const arrayLabel = schema.title ?? uiOptions?.["ui:title"];
    const options = {
      label: arrayLabel,
      items,
      itemLabel,
      controls: {
        add: { click: addItemClick }
      },
      level
    };
    return widgets?.array?.(options);
  };

  // node_modules/@jsfe/form/dist/esm/triage/object.js
  var fieldObject = (schema, data, path, uiState, uiSchema, dig, schemaPath, widgets, level = 0) => {
    const error = "Wrong object field";
    if (typeof schema.properties !== "object")
      return widgets.callout?.({ id: "", message: error }) ?? x`${error}`;
    const children = Object.entries(schema.properties).map(([propName, propValue]) => {
      if (Array.isArray(propValue) || typeof propValue === "boolean")
        return x``;
      const value2 = data?.[propName];
      const subPath = [...path, propName];
      const required = schema.required?.includes(propName);
      const schemaPathAugmented = [...schemaPath];
      schemaPathAugmented.push(propName);
      return dig(propValue, value2, subPath, uiState?.[propName], uiSchema?.[propName], schemaPathAugmented, required, level + 1);
    });
    let label;
    const key = path.at(-1);
    if (schema.title) {
      label = schema.title;
    } else if (typeof key !== "number") {
      label = key;
    }
    if (typeof uiSchema?.["ui:title"] === "string")
      label = uiSchema["ui:title"];
    const options = {
      id: path.join("."),
      label,
      helpText: schema.description,
      children,
      level
    };
    return widgets?.object?.(options) ?? widgets?.callout?.({ id: "", message: error }) ?? x`${error}`;
  };

  // node_modules/@jsfe/form/dist/esm/triage/primitive.js
  var fieldPrimitive = (schema, value2, path, uiOptions, required, handleChange, handleKeydown, schemaPath, widgets) => {
    const id = path.join(".");
    function missing(widgetName) {
      const options = { id, message: `Missing ${widgetName} widget.` };
      return widgets?.callout?.(options) ?? x`<p>${options.message}</p>`;
    }
    let label = "";
    if (schema.title)
      label = schema.title;
    else if (Number.isNaN(Number(path.at(-1)))) {
      label = String(path.at(-1));
    }
    if (uiOptions?.["ui:title"]) {
      label = uiOptions?.["ui:title"];
    }
    const helpText = uiOptions?.["ui:help"] ?? uiOptions?.["ui:description"] ?? schema.description ?? "";
    const placeholder = uiOptions?.["ui:placeholder"] ?? "";
    const disabled = uiOptions?.["ui:disabled"] || false;
    const readonly = uiOptions?.["ui:readonly"] || false;
    let baseValue;
    if (value2 !== void 0) {
      baseValue = value2;
    } else if (typeof schema.default !== "undefined" && (typeof schema.default === "string" || typeof schema.default === "number" || schema.default == null || typeof schema.default === "boolean")) {
      baseValue = schema.default;
      handleChange([...path], schema.default, schemaPath);
    }
    const valueChangedCallback = (newValue) => {
      let finalValue = newValue;
      if (finalValue === "") {
        finalValue = void 0;
      }
      if (schema?.type?.includes("null") && (typeof newValue === "undefined" || newValue === "")) {
        finalValue = null;
      }
      handleChange(path, finalValue, schemaPath);
    };
    const baseOptions = {
      label,
      helpText,
      placeholder,
      valueChangedCallback,
      handleKeydown,
      id,
      required,
      disabled,
      readonly
    };
    if (schema?.enum && (schema.type === "integer" || schema.type === "number" || schema.type === "string")) {
      const options = {
        ...baseOptions,
        value: baseValue ? String(baseValue) : "",
        type: schema.type,
        enum: schema.enum
      };
      if (uiOptions?.["ui:widget"] === "radio") {
        return widgets?.radioGroup?.(options) || missing("radio group");
      }
      if (uiOptions?.["ui:widget"] === "button") {
        return widgets?.buttonGroup?.(options) || missing("button group");
      }
      return widgets?.select?.(options) || missing("select");
    }
    if (schema.type === "string" && uiOptions?.["ui:widget"] === "color") {
      const options = {
        ...baseOptions,
        value: baseValue ? String(baseValue) : ""
      };
      return widgets?.colorPicker?.(options) || missing("color picker");
    }
    if (schema.format === "date" || schema.format === "date-time" || schema.format === "time") {
      let type = schema.format;
      let date2 = baseValue;
      if (date2) {
        if (schema.format === "date") {
        }
        if (schema.format === "time") {
        }
        if (schema.format === "date-time") {
          if (date2 instanceof Date === false) {
            date2 = new Date(date2);
          }
          if (date2 instanceof Date)
            date2 = date2.toISOString().split(".")[0];
        }
      }
      if (schema.format === "date-time") {
        type = "datetime-local";
      }
      const options = {
        ...baseOptions,
        value: date2,
        type
      };
      return widgets?.date?.(options) || missing("date");
    }
    if (schema.type === "string") {
      let inputType = "text";
      if (schema.format === "password" || schema.format === "email") {
        inputType = schema.format;
      }
      if (uiOptions?.["ui:widget"] === "password") {
        inputType = "password";
      }
      if (uiOptions?.["ui:options"]?.inputType === "tel") {
        inputType = "tel";
      }
      const options = {
        ...baseOptions,
        value: baseValue ? String(baseValue) : "",
        inputType,
        minLength: schema.minLength,
        maxLength: schema.maxLength,
        pattern: schema.pattern
      };
      if (uiOptions?.["ui:widget"] === "textarea") {
        return widgets?.textarea?.(options) || missing("textarea");
      }
      if (typeof uiOptions?.["ui:widget"] === "string") {
        const customWidgetName = uiOptions?.["ui:widget"];
        if (customWidgetName !== "password") {
          return widgets?.[customWidgetName]?.(options) || missing("custom");
        }
      }
      return widgets?.text?.(options) || missing("text");
    }
    if (schema.type === "number" || schema.type === "integer") {
      let step = schema.multipleOf;
      if (typeof step === "undefined") {
        if (schema.type?.includes("integer"))
          step = 1;
        if (schema.type?.includes("number"))
          step = "any";
      }
      const options = {
        ...baseOptions,
        value: typeof baseValue !== "undefined" ? Number(baseValue) : void 0,
        min: schema.minimum,
        max: schema.maximum,
        step
      };
      if (uiOptions?.["ui:widget"] === "range") {
        return widgets?.range?.(options) || missing("range");
      }
      if (uiOptions?.["ui:widget"] === "rating") {
        return widgets?.rating?.(options) || missing("rating");
      }
      return widgets?.number?.(options) || missing("number");
    }
    if (schema.type?.includes("boolean")) {
      const options = {
        ...baseOptions,
        value: typeof baseValue !== "undefined" ? Boolean(baseValue) : void 0
      };
      if (uiOptions?.["ui:widget"] === "switch") {
        return widgets?.switch?.(options) || missing("switch");
      }
      if (uiOptions?.["ui:widget"] === "radio") {
        return widgets?.radioGroupBoolean?.(options) || missing("radio group boolean");
      }
      if (uiOptions?.["ui:widget"] === "button") {
        return widgets?.buttonGroupBoolean?.(options) || missing("button group boolean");
      }
      return widgets?.checkbox?.(options) || missing("boolean");
    }
    return missing(`Wrong input for: ${path.join("/")}`);
  };

  // node_modules/@jsfe/form/dist/esm/triage/array-primitive.js
  var fieldArrayPrimitive = (schema, dataLevel, path, uiState, uiOptions, required, handleChange, schemaPath, widgets, level = 0) => {
    const id = path.join(".");
    function missing(widgetName) {
      const options2 = { id, message: `Missing ${widgetName} widget.` };
      return widgets?.callout?.(options2) ?? x`<p>${options2.message}</p>`;
    }
    const helpText = schema.description ?? uiOptions?.["ui:help"] ?? "";
    const items = schema.items;
    if (typeof items !== "object" || Array.isArray(items))
      return;
    const valueChangedCallback = (enumValue) => {
      const schemaPathAugmented = [
        ...schemaPath,
        "items",
        "enum"
      ];
      handleChange(path, enumValue, schemaPathAugmented);
    };
    const disabled = uiOptions?.["ui:disabled"] || false;
    const options = {
      label: schema.title,
      helpText,
      value: dataLevel ?? schema?.default,
      enum: items.enum,
      disabled,
      level,
      id,
      valueChangedCallback
    };
    if (uiOptions?.["ui:widget"] === "select") {
      return widgets?.selectMultiple?.(options) || missing("multi select");
    }
    return widgets?.checkboxGroup?.(options) || missing("array primitive");
  };

  // node_modules/@jsfe/form/dist/esm/json-schema-form.js
  var __decorate = function(decorators, target, key, desc) {
    var c7 = arguments.length, r9 = c7 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d4;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r9 = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i11 = decorators.length - 1; i11 >= 0; i11--)
        if (d4 = decorators[i11])
          r9 = (c7 < 3 ? d4(r9) : c7 > 3 ? d4(target, key, r9) : d4(target, key)) || r9;
    return c7 > 3 && r9 && Object.defineProperty(target, key, r9), r9;
  };
  var Jsf = class extends i6 {
    constructor() {
      super(...arguments);
      this.schema = {};
      this.data = {};
      this.uiSchema = {};
      this.submitCallback = () => {
      };
      this.dataChangeCallback = () => {
      };
      this.widgets = {};
      this.styleSheets = [];
      this.experimental = {};
      this.submitButton = true;
      this.submitButtonText = "Submit";
      this._uiState = {};
      this.#submit = () => {
        const options = {
          id: "__submit_button",
          label: this.submitButtonLabel
        };
        const error = "Missing submit widget.";
        return this.widgets?.submit?.(options) ?? this.widgets?.callout?.({ message: error }) ?? error;
      };
      this.#formRef = e9();
    }
    _dig(node, dataLevel, path, uiState, uiSchema, schemaPath, required = false, level = 0) {
      let result;
      const currentNode = node;
      if (typeof currentNode.$ref !== "undefined" || typeof currentNode?.items === "object" && "$ref" in currentNode.items) {
        let nodeRef = currentNode.$ref;
        if (typeof currentNode.items === "object" && !Array.isArray(currentNode.items) && currentNode.items?.$ref) {
          nodeRef = currentNode.items.$ref;
        }
        if (nodeRef?.startsWith?.("#/definitions/")) {
          const reff = nodeRef.split("/")?.[2];
          if (currentNode?.properties) {
          } else {
            currentNode.items = {
              ...this.schema.definitions?.[reff]
            };
          }
        }
      }
      if (currentNode.type?.includes("boolean") || currentNode.type?.includes("string") || currentNode.type?.includes("integer") || currentNode.format === "date" || currentNode.format === "date-time" || currentNode.type?.includes("number")) {
        const schemaPathAugmented = [...schemaPath];
        result = fieldPrimitive(currentNode, dataLevel, path, uiSchema, required, this._handleChange.bind(this), this._handleKeydown.bind(this), schemaPathAugmented, this.widgets);
      }
      if (currentNode.properties || currentNode.allOf) {
        if (currentNode.allOf && this.experimental?.allOf !== true) {
          return x`Unsupported feature.`;
        }
        const nodeParsed = node;
        const schemaPathAugmented = [...schemaPath];
        schemaPathAugmented.push("properties");
        result = fieldObject(nodeParsed, dataLevel, path, uiState, uiSchema, this._dig.bind(this), schemaPathAugmented, this.widgets, level);
      }
      if (currentNode.type === "array" && typeof currentNode.items === "object" && !Array.isArray(currentNode.items) && currentNode.items.enum && currentNode.uniqueItems && (currentNode.items.type === "string" || currentNode.items.type === "number" || currentNode.items.type === "integer" || currentNode.items.type === "boolean")) {
        const schemaPathAugmented = [...schemaPath];
        result = fieldArrayPrimitive(currentNode, dataLevel, path, uiState, uiSchema, required, this._handleChange.bind(this), schemaPathAugmented, this.widgets, level);
      }
      if (typeof currentNode.items === "object") {
        if (Array.isArray(currentNode.items)) {
          const newNode = { ...node, properties: {} };
          currentNode.items.forEach((e13, i11) => {
            if (newNode.properties)
              newNode.properties[i11] = e13;
          });
          const schemaPathAugmented = [...schemaPath, "items"];
          result = fieldObject(newNode, dataLevel, path, uiState, uiSchema, this._dig.bind(this), schemaPathAugmented, this.widgets, level);
        } else if ((currentNode.items.type === "string" || currentNode.items.type === "number") && currentNode.items.enum) {
        } else {
          const schemaPathAugmented = [...schemaPath];
          dataLevel ||= [];
          result = fieldArray(node, dataLevel, path, uiState, uiSchema, this._handleChange.bind(this), this._dig.bind(this), schemaPathAugmented, this.widgets, required, level);
        }
      }
      if (result)
        return result;
      const error = `Cannot dig this level: ${path.join("/")} - (${String(currentNode.type)})`;
      return this.widgets?.callout?.({ id: "", message: error }) ?? x`<p>${error}</p>`;
    }
    _setToValue(object2, value2, path) {
      if (object2 && typeof object2 === "object") {
        set_default(object2, path, value2);
      }
    }
    _handleChange(path, value2, schemaPath) {
      if (!(this.data && typeof this.data === "object"))
        return;
      let newData = { ...this.data };
      if (path.length === 0) {
        newData = {};
      } else {
        this._setToValue(newData, value2, path);
      }
      this.data = newData;
      this.dataChangeCallback(newData, path, value2, schemaPath);
    }
    _handleKeydown(event) {
      console.log("cccccccccccccc");
      const hasModifier = event.metaKey || event.ctrlKey || event.shiftKey || event.altKey;
      if (event.key === "Enter" && !hasModifier) {
        setTimeout(() => {
          if (!event.defaultPrevented && !event.isComposing) {
            console.log({ event });
            const form = this.#formRef.value;
            let valid = true;
            let firstInvalid;
            if (!form.noValidate) {
              const elements = form.querySelectorAll("*");
              for (const element of elements) {
                if (typeof element.reportValidity === "function") {
                  if (!element.reportValidity()) {
                    valid = false;
                    if (!firstInvalid)
                      firstInvalid = element;
                  }
                }
              }
              if (firstInvalid)
                firstInvalid?.reportValidity();
            }
            this.submitCallback(this.data, valid);
          }
        });
      }
    }
    _updateUi(path, value2) {
      if (!(this._uiState && typeof this._uiState === "object"))
        return;
      const newUiState = { ...this._uiState };
      this._setToValue(newUiState, value2, path);
      this._uiState = newUiState;
    }
    #submit;
    #formRef;
    render() {
      return x`
			<style>
				${r2(this.styleSheets.join("\n"))}
			</style>

			<form
				${n7(this.#formRef)}
				part="base"
				@submit=${(event) => {
        console.log("hey");
        event.preventDefault();
        const valid = event.target.reportValidity();
        this.submitCallback(this.data, valid);
      }}
				@invalid=${(_event) => {
      }}
			>
				${this._dig(this.schema, this.data, [], this._uiState, this.uiSchema, [], false)}

				<!--  -->
				${this.submitButton ? this.#submit() : E2}
			</form>
		`;
    }
  };
  __decorate([
    n5({ type: Object })
  ], Jsf.prototype, "schema", void 0);
  __decorate([
    n5({ type: Object })
  ], Jsf.prototype, "data", void 0);
  __decorate([
    n5({ type: Object })
  ], Jsf.prototype, "uiSchema", void 0);
  __decorate([
    n5({ type: Object })
  ], Jsf.prototype, "widgets", void 0);
  __decorate([
    n5({ type: Array })
  ], Jsf.prototype, "styleSheets", void 0);
  __decorate([
    n5({ type: Object })
  ], Jsf.prototype, "experimental", void 0);
  __decorate([
    n5({ type: Boolean })
  ], Jsf.prototype, "submitButton", void 0);
  __decorate([
    n5({ type: String })
  ], Jsf.prototype, "submitButtonText", void 0);
  __decorate([
    r6()
  ], Jsf.prototype, "_uiState", void 0);

  // node_modules/@jsfe/form/dist/esm/json-schema-form.def.js
  customElements.define("json-schema-form", Jsf);

  // node_modules/@jsfe/shoelace/dist/esm/widgets/index.js
  var widgets_exports = {};
  __export(widgets_exports, {
    array: () => array,
    buttonGroup: () => buttonGroup,
    buttonGroupBoolean: () => buttonGroupBoolean,
    callout: () => callout,
    checkbox: () => checkbox,
    checkboxGroup: () => checkboxGroup,
    colorPicker: () => colorPicker,
    date: () => date,
    number: () => number,
    object: () => object,
    radioGroup: () => radioGroup,
    radioGroupBoolean: () => radioGroupBoolean,
    range: () => range,
    rating: () => rating,
    select: () => select,
    selectMultiple: () => selectMultiple,
    submit: () => submit,
    switch: () => switchh,
    text: () => text,
    textarea: () => textarea
  });

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.A5D6FTFY.js
  var card_styles_default = i3`
  :host {
    --border-color: var(--sl-color-neutral-200);
    --border-radius: var(--sl-border-radius-medium);
    --border-width: 1px;
    --padding: var(--sl-spacing-large);

    display: inline-block;
  }

  .card {
    display: flex;
    flex-direction: column;
    background-color: var(--sl-panel-background-color);
    box-shadow: var(--sl-shadow-x-small);
    border: solid var(--border-width) var(--border-color);
    border-radius: var(--border-radius);
  }

  .card__image {
    display: flex;
    border-top-left-radius: var(--border-radius);
    border-top-right-radius: var(--border-radius);
    margin: calc(-1 * var(--border-width));
    overflow: hidden;
  }

  .card__image::slotted(img) {
    display: block;
    width: 100%;
  }

  .card:not(.card--has-image) .card__image {
    display: none;
  }

  .card__header {
    display: block;
    border-bottom: solid var(--border-width) var(--border-color);
    padding: calc(var(--padding) / 2) var(--padding);
  }

  .card:not(.card--has-header) .card__header {
    display: none;
  }

  .card:not(.card--has-image) .card__header {
    border-top-left-radius: var(--border-radius);
    border-top-right-radius: var(--border-radius);
  }

  .card__body {
    display: block;
    padding: var(--padding);
  }

  .card--has-footer .card__footer {
    display: block;
    border-top: solid var(--border-width) var(--border-color);
    padding: var(--padding);
  }

  .card:not(.card--has-footer) .card__footer {
    display: none;
  }
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.NYIIDP5N.js
  var HasSlotController = class {
    constructor(host, ...slotNames) {
      this.slotNames = [];
      this.handleSlotChange = (event) => {
        const slot = event.target;
        if (this.slotNames.includes("[default]") && !slot.name || slot.name && this.slotNames.includes(slot.name)) {
          this.host.requestUpdate();
        }
      };
      (this.host = host).addController(this);
      this.slotNames = slotNames;
    }
    hasDefaultSlot() {
      return [...this.host.childNodes].some((node) => {
        if (node.nodeType === node.TEXT_NODE && node.textContent.trim() !== "") {
          return true;
        }
        if (node.nodeType === node.ELEMENT_NODE) {
          const el = node;
          const tagName = el.tagName.toLowerCase();
          if (tagName === "sl-visually-hidden") {
            return false;
          }
          if (!el.hasAttribute("slot")) {
            return true;
          }
        }
        return false;
      });
    }
    hasNamedSlot(name) {
      return this.host.querySelector(`:scope > [slot="${name}"]`) !== null;
    }
    test(slotName) {
      return slotName === "[default]" ? this.hasDefaultSlot() : this.hasNamedSlot(slotName);
    }
    hostConnected() {
      this.host.shadowRoot.addEventListener("slotchange", this.handleSlotChange);
    }
    hostDisconnected() {
      this.host.shadowRoot.removeEventListener("slotchange", this.handleSlotChange);
    }
  };

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.TUVJKY7S.js
  var component_styles_default = i3`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: inherit;
  }

  [hidden] {
    display: none !important;
  }
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.KAW7D32O.js
  var __defProp3 = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
  var __typeError = (msg) => {
    throw TypeError(msg);
  };
  var __defNormalProp = (obj, key, value2) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
  var __spreadValues = (a5, b4) => {
    for (var prop in b4 || (b4 = {}))
      if (__hasOwnProp.call(b4, prop))
        __defNormalProp(a5, prop, b4[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b4)) {
        if (__propIsEnum.call(b4, prop))
          __defNormalProp(a5, prop, b4[prop]);
      }
    return a5;
  };
  var __spreadProps = (a5, b4) => __defProps(a5, __getOwnPropDescs(b4));
  var __decorateClass2 = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc2(target, key) : target;
    for (var i11 = decorators.length - 1, decorator; i11 >= 0; i11--)
      if (decorator = decorators[i11])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp3(target, key, result);
    return result;
  };
  var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
  var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
  var __privateAdd = (obj, member, value2) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
  var __privateSet = (obj, member, value2, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
  var __await = function(promise, isYieldStar) {
    this[0] = promise;
    this[1] = isYieldStar;
  };
  var __yieldStar = (value2) => {
    var obj = value2[__knownSymbol("asyncIterator")], isAwait = false, method, it2 = {};
    if (obj == null) {
      obj = value2[__knownSymbol("iterator")]();
      method = (k3) => it2[k3] = (x2) => obj[k3](x2);
    } else {
      obj = obj.call(value2);
      method = (k3) => it2[k3] = (v3) => {
        if (isAwait) {
          isAwait = false;
          if (k3 === "throw")
            throw v3;
          return v3;
        }
        isAwait = true;
        return {
          done: false,
          value: new __await(new Promise((resolve) => {
            var x2 = obj[k3](v3);
            if (!(x2 instanceof Object))
              __typeError("Object expected");
            resolve(x2);
          }), 1)
        };
      };
    }
    return it2[__knownSymbol("iterator")] = () => it2, method("next"), "throw" in obj ? method("throw") : it2.throw = (x2) => {
      throw x2;
    }, "return" in obj && method("return"), it2;
  };

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.4TUIT776.js
  var _hasRecordedInitialProperties;
  var ShoelaceElement = class extends i6 {
    constructor() {
      super();
      __privateAdd(this, _hasRecordedInitialProperties, false);
      this.initialReflectedProperties = /* @__PURE__ */ new Map();
      Object.entries(this.constructor.dependencies).forEach(([name, component]) => {
        this.constructor.define(name, component);
      });
    }
    emit(name, options) {
      const event = new CustomEvent(name, __spreadValues({
        bubbles: true,
        cancelable: false,
        composed: true,
        detail: {}
      }, options));
      this.dispatchEvent(event);
      return event;
    }
    /* eslint-enable */
    static define(name, elementConstructor = this, options = {}) {
      const currentlyRegisteredConstructor = customElements.get(name);
      if (!currentlyRegisteredConstructor) {
        try {
          customElements.define(name, elementConstructor, options);
        } catch (_err) {
          customElements.define(name, class extends elementConstructor {
          }, options);
        }
        return;
      }
      let newVersion = " (unknown version)";
      let existingVersion = newVersion;
      if ("version" in elementConstructor && elementConstructor.version) {
        newVersion = " v" + elementConstructor.version;
      }
      if ("version" in currentlyRegisteredConstructor && currentlyRegisteredConstructor.version) {
        existingVersion = " v" + currentlyRegisteredConstructor.version;
      }
      if (newVersion && existingVersion && newVersion === existingVersion) {
        return;
      }
      console.warn(
        `Attempted to register <${name}>${newVersion}, but <${name}>${existingVersion} has already been registered.`
      );
    }
    attributeChangedCallback(name, oldValue, newValue) {
      if (!__privateGet(this, _hasRecordedInitialProperties)) {
        this.constructor.elementProperties.forEach(
          (obj, prop) => {
            if (obj.reflect && this[prop] != null) {
              this.initialReflectedProperties.set(prop, this[prop]);
            }
          }
        );
        __privateSet(this, _hasRecordedInitialProperties, true);
      }
      super.attributeChangedCallback(name, oldValue, newValue);
    }
    willUpdate(changedProperties) {
      super.willUpdate(changedProperties);
      this.initialReflectedProperties.forEach((value2, prop) => {
        if (changedProperties.has(prop) && this[prop] == null) {
          this[prop] = value2;
        }
      });
    }
  };
  _hasRecordedInitialProperties = /* @__PURE__ */ new WeakMap();
  ShoelaceElement.version = "2.20.1";
  ShoelaceElement.dependencies = {};
  __decorateClass2([
    n5()
  ], ShoelaceElement.prototype, "dir", 2);
  __decorateClass2([
    n5()
  ], ShoelaceElement.prototype, "lang", 2);

  // node_modules/lit-html/directives/class-map.js
  var e10 = e8(class extends i7 {
    constructor(t7) {
      if (super(t7), t7.type !== t6.ATTRIBUTE || "class" !== t7.name || t7.strings?.length > 2)
        throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
    }
    render(t7) {
      return " " + Object.keys(t7).filter((s6) => t7[s6]).join(" ") + " ";
    }
    update(s6, [i11]) {
      if (void 0 === this.st) {
        this.st = /* @__PURE__ */ new Set(), void 0 !== s6.strings && (this.nt = new Set(s6.strings.join(" ").split(/\s/).filter((t7) => "" !== t7)));
        for (const t7 in i11)
          i11[t7] && !this.nt?.has(t7) && this.st.add(t7);
        return this.render(i11);
      }
      const r9 = s6.element.classList;
      for (const t7 of this.st)
        t7 in i11 || (r9.remove(t7), this.st.delete(t7));
      for (const t7 in i11) {
        const s7 = !!i11[t7];
        s7 === this.st.has(t7) || this.nt?.has(t7) || (s7 ? (r9.add(t7), this.st.add(t7)) : (r9.remove(t7), this.st.delete(t7)));
      }
      return T2;
    }
  });

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.PSUCFVU6.js
  var SlCard = class extends ShoelaceElement {
    constructor() {
      super(...arguments);
      this.hasSlotController = new HasSlotController(this, "footer", "header", "image");
    }
    render() {
      return x`
      <div
        part="base"
        class=${e10({
        card: true,
        "card--has-footer": this.hasSlotController.test("footer"),
        "card--has-image": this.hasSlotController.test("image"),
        "card--has-header": this.hasSlotController.test("header")
      })}
      >
        <slot name="image" part="image" class="card__image"></slot>
        <slot name="header" part="header" class="card__header"></slot>
        <slot part="body" class="card__body"></slot>
        <slot name="footer" part="footer" class="card__footer"></slot>
      </div>
    `;
    }
  };
  SlCard.styles = [component_styles_default, card_styles_default];

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3LWOA5DF.js
  SlCard.define("sl-card");

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.V2OL7VMD.js
  var tag_styles_default = i3`
  :host {
    display: inline-block;
  }

  .tag {
    display: flex;
    align-items: center;
    border: solid 1px;
    line-height: 1;
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
  }

  .tag__remove::part(base) {
    color: inherit;
    padding: 0;
  }

  /*
   * Variant modifiers
   */

  .tag--primary {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-200);
    color: var(--sl-color-primary-800);
  }

  .tag--primary:active > sl-icon-button {
    color: var(--sl-color-primary-600);
  }

  .tag--success {
    background-color: var(--sl-color-success-50);
    border-color: var(--sl-color-success-200);
    color: var(--sl-color-success-800);
  }

  .tag--success:active > sl-icon-button {
    color: var(--sl-color-success-600);
  }

  .tag--neutral {
    background-color: var(--sl-color-neutral-50);
    border-color: var(--sl-color-neutral-200);
    color: var(--sl-color-neutral-800);
  }

  .tag--neutral:active > sl-icon-button {
    color: var(--sl-color-neutral-600);
  }

  .tag--warning {
    background-color: var(--sl-color-warning-50);
    border-color: var(--sl-color-warning-200);
    color: var(--sl-color-warning-800);
  }

  .tag--warning:active > sl-icon-button {
    color: var(--sl-color-warning-600);
  }

  .tag--danger {
    background-color: var(--sl-color-danger-50);
    border-color: var(--sl-color-danger-200);
    color: var(--sl-color-danger-800);
  }

  .tag--danger:active > sl-icon-button {
    color: var(--sl-color-danger-600);
  }

  /*
   * Size modifiers
   */

  .tag--small {
    font-size: var(--sl-button-font-size-small);
    height: calc(var(--sl-input-height-small) * 0.8);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
    padding: 0 var(--sl-spacing-x-small);
  }

  .tag--medium {
    font-size: var(--sl-button-font-size-medium);
    height: calc(var(--sl-input-height-medium) * 0.8);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
    padding: 0 var(--sl-spacing-small);
  }

  .tag--large {
    font-size: var(--sl-button-font-size-large);
    height: calc(var(--sl-input-height-large) * 0.8);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
    padding: 0 var(--sl-spacing-medium);
  }

  .tag__remove {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  /*
   * Pill modifier
   */

  .tag--pill {
    border-radius: var(--sl-border-radius-pill);
  }
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.6I2T3DLI.js
  var icon_button_styles_default = i3`
  :host {
    display: inline-block;
    color: var(--sl-color-neutral-600);
  }

  .icon-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: inherit;
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-x-fast) color;
    -webkit-appearance: none;
  }

  .icon-button:hover:not(.icon-button--disabled),
  .icon-button:focus-visible:not(.icon-button--disabled) {
    color: var(--sl-color-primary-600);
  }

  .icon-button:active:not(.icon-button--disabled) {
    color: var(--sl-color-primary-700);
  }

  .icon-button:focus {
    outline: none;
  }

  .icon-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .icon-button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .icon-button__icon {
    pointer-events: none;
  }
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3Y6SB6QS.js
  var basePath = "";
  function setBasePath(path) {
    basePath = path;
  }
  function getBasePath(subpath = "") {
    if (!basePath) {
      const scripts = [...document.getElementsByTagName("script")];
      const configScript = scripts.find((script) => script.hasAttribute("data-shoelace"));
      if (configScript) {
        setBasePath(configScript.getAttribute("data-shoelace"));
      } else {
        const fallbackScript = scripts.find((s6) => {
          return /shoelace(\.min)?\.js($|\?)/.test(s6.src) || /shoelace-autoloader(\.min)?\.js($|\?)/.test(s6.src);
        });
        let path = "";
        if (fallbackScript) {
          path = fallbackScript.getAttribute("src");
        }
        setBasePath(path.split("/").slice(0, -1).join("/"));
      }
    }
    return basePath.replace(/\/$/, "") + (subpath ? `/${subpath.replace(/^\//, "")}` : ``);
  }

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.P7ZG6EMR.js
  var library = {
    name: "default",
    resolver: (name) => getBasePath(`assets/icons/${name}.svg`)
  };
  var library_default_default = library;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3TFKS637.js
  var icons = {
    caret: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  `,
    check: `
    <svg part="checked-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor">
          <g transform="translate(3.428571, 3.428571)">
            <path d="M0,5.71428571 L3.42857143,9.14285714"></path>
            <path d="M9.14285714,0 L3.42857143,9.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
    "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
    "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
    "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
    copy: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-copy" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V2Zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H6ZM2 5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h1v1a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1v1H2Z"/>
    </svg>
  `,
    eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
    "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
    eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
    "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"></path>
    </svg>
  `,
    indeterminate: `
    <svg part="indeterminate-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <g transform="translate(2.285714, 6.857143)">
            <path d="M10.2857143,1.14285714 L1.14285714,1.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
    "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
    "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
    "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
    radio: `
    <svg part="checked-icon" class="radio__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g fill="currentColor">
          <circle cx="8" cy="8" r="3.42857143"></circle>
        </g>
      </g>
    </svg>
  `,
    "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
    "x-lg": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
      <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
    </svg>
  `,
    "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `
  };
  var systemLibrary = {
    name: "system",
    resolver: (name) => {
      if (name in icons) {
        return `data:image/svg+xml,${encodeURIComponent(icons[name])}`;
      }
      return "";
    }
  };
  var library_system_default = systemLibrary;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.ZL53POKZ.js
  var registry = [library_default_default, library_system_default];
  var watchedIcons = [];
  function watchIcon(icon) {
    watchedIcons.push(icon);
  }
  function unwatchIcon(icon) {
    watchedIcons = watchedIcons.filter((el) => el !== icon);
  }
  function getIconLibrary(name) {
    return registry.find((lib) => lib.name === name);
  }

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.QLXRCYS4.js
  var icon_styles_default = i3`
  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    box-sizing: content-box !important;
  }

  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.GMYPQTFK.js
  function watch(propertyName, options) {
    const resolvedOptions = __spreadValues({
      waitUntilFirstUpdate: false
    }, options);
    return (proto, decoratedFnName) => {
      const { update: update2 } = proto;
      const watchedProperties = Array.isArray(propertyName) ? propertyName : [propertyName];
      proto.update = function(changedProps) {
        watchedProperties.forEach((property) => {
          const key = property;
          if (changedProps.has(key)) {
            const oldValue = changedProps.get(key);
            const newValue = this[key];
            if (oldValue !== newValue) {
              if (!resolvedOptions.waitUntilFirstUpdate || this.hasUpdated) {
                this[decoratedFnName](oldValue, newValue);
              }
            }
          }
        });
        update2.call(this, changedProps);
      };
    };
  }

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.YHLNUJ7P.js
  var CACHEABLE_ERROR = Symbol();
  var RETRYABLE_ERROR = Symbol();
  var parser;
  var iconCache = /* @__PURE__ */ new Map();
  var SlIcon = class extends ShoelaceElement {
    constructor() {
      super(...arguments);
      this.initialRender = false;
      this.svg = null;
      this.label = "";
      this.library = "default";
    }
    /** Given a URL, this function returns the resulting SVG element or an appropriate error symbol. */
    async resolveIcon(url, library2) {
      var _a;
      let fileData;
      if (library2 == null ? void 0 : library2.spriteSheet) {
        this.svg = x`<svg part="svg">
        <use part="use" href="${url}"></use>
      </svg>`;
        return this.svg;
      }
      try {
        fileData = await fetch(url, { mode: "cors" });
        if (!fileData.ok)
          return fileData.status === 410 ? CACHEABLE_ERROR : RETRYABLE_ERROR;
      } catch (e13) {
        return RETRYABLE_ERROR;
      }
      try {
        const div = document.createElement("div");
        div.innerHTML = await fileData.text();
        const svg = div.firstElementChild;
        if (((_a = svg == null ? void 0 : svg.tagName) == null ? void 0 : _a.toLowerCase()) !== "svg")
          return CACHEABLE_ERROR;
        if (!parser)
          parser = new DOMParser();
        const doc = parser.parseFromString(svg.outerHTML, "text/html");
        const svgEl = doc.body.querySelector("svg");
        if (!svgEl)
          return CACHEABLE_ERROR;
        svgEl.part.add("svg");
        return document.adoptNode(svgEl);
      } catch (e13) {
        return CACHEABLE_ERROR;
      }
    }
    connectedCallback() {
      super.connectedCallback();
      watchIcon(this);
    }
    firstUpdated() {
      this.initialRender = true;
      this.setIcon();
    }
    disconnectedCallback() {
      super.disconnectedCallback();
      unwatchIcon(this);
    }
    getIconSource() {
      const library2 = getIconLibrary(this.library);
      if (this.name && library2) {
        return {
          url: library2.resolver(this.name),
          fromLibrary: true
        };
      }
      return {
        url: this.src,
        fromLibrary: false
      };
    }
    handleLabelChange() {
      const hasLabel = typeof this.label === "string" && this.label.length > 0;
      if (hasLabel) {
        this.setAttribute("role", "img");
        this.setAttribute("aria-label", this.label);
        this.removeAttribute("aria-hidden");
      } else {
        this.removeAttribute("role");
        this.removeAttribute("aria-label");
        this.setAttribute("aria-hidden", "true");
      }
    }
    async setIcon() {
      var _a;
      const { url, fromLibrary } = this.getIconSource();
      const library2 = fromLibrary ? getIconLibrary(this.library) : void 0;
      if (!url) {
        this.svg = null;
        return;
      }
      let iconResolver = iconCache.get(url);
      if (!iconResolver) {
        iconResolver = this.resolveIcon(url, library2);
        iconCache.set(url, iconResolver);
      }
      if (!this.initialRender) {
        return;
      }
      const svg = await iconResolver;
      if (svg === RETRYABLE_ERROR) {
        iconCache.delete(url);
      }
      if (url !== this.getIconSource().url) {
        return;
      }
      if (e7(svg)) {
        this.svg = svg;
        if (library2) {
          await this.updateComplete;
          const shadowSVG = this.shadowRoot.querySelector("[part='svg']");
          if (typeof library2.mutator === "function" && shadowSVG) {
            library2.mutator(shadowSVG);
          }
        }
        return;
      }
      switch (svg) {
        case RETRYABLE_ERROR:
        case CACHEABLE_ERROR:
          this.svg = null;
          this.emit("sl-error");
          break;
        default:
          this.svg = svg.cloneNode(true);
          (_a = library2 == null ? void 0 : library2.mutator) == null ? void 0 : _a.call(library2, this.svg);
          this.emit("sl-load");
      }
    }
    render() {
      return this.svg;
    }
  };
  SlIcon.styles = [component_styles_default, icon_styles_default];
  __decorateClass2([
    r6()
  ], SlIcon.prototype, "svg", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlIcon.prototype, "name", 2);
  __decorateClass2([
    n5()
  ], SlIcon.prototype, "src", 2);
  __decorateClass2([
    n5()
  ], SlIcon.prototype, "label", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlIcon.prototype, "library", 2);
  __decorateClass2([
    watch("label")
  ], SlIcon.prototype, "handleLabelChange", 1);
  __decorateClass2([
    watch(["name", "src", "library"])
  ], SlIcon.prototype, "setIcon", 1);

  // node_modules/lit-html/static.js
  var a4 = Symbol.for("");
  var o10 = (t7) => {
    if (t7?.r === a4)
      return t7?._$litStatic$;
  };
  var i8 = (t7, ...r9) => ({ _$litStatic$: r9.reduce((r10, e13, a5) => r10 + ((t8) => {
    if (void 0 !== t8._$litStatic$)
      return t8._$litStatic$;
    throw Error(`Value passed to 'literal' function must be a 'literal' result: ${t8}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
  })(e13) + t7[a5 + 1], t7[0]), r: a4 });
  var l4 = /* @__PURE__ */ new Map();
  var n8 = (t7) => (r9, ...e13) => {
    const a5 = e13.length;
    let s6, i11;
    const n10 = [], u6 = [];
    let c7, $4 = 0, f6 = false;
    for (; $4 < a5; ) {
      for (c7 = r9[$4]; $4 < a5 && void 0 !== (i11 = e13[$4], s6 = o10(i11)); )
        c7 += s6 + r9[++$4], f6 = true;
      $4 !== a5 && u6.push(i11), n10.push(c7), $4++;
    }
    if ($4 === a5 && n10.push(r9[a5]), f6) {
      const t8 = n10.join("$$lit$$");
      void 0 === (r9 = l4.get(t8)) && (n10.raw = n10, l4.set(t8, r9 = n10)), e13 = u6;
    }
    return t7(r9, ...e13);
  };
  var u5 = n8(x);
  var c6 = n8(b3);
  var $3 = n8(w);

  // node_modules/lit-html/directives/if-defined.js
  var o11 = (o14) => o14 ?? E2;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7E4JTYWU.js
  var SlIconButton = class extends ShoelaceElement {
    constructor() {
      super(...arguments);
      this.hasFocus = false;
      this.label = "";
      this.disabled = false;
    }
    handleBlur() {
      this.hasFocus = false;
      this.emit("sl-blur");
    }
    handleFocus() {
      this.hasFocus = true;
      this.emit("sl-focus");
    }
    handleClick(event) {
      if (this.disabled) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
    /** Simulates a click on the icon button. */
    click() {
      this.button.click();
    }
    /** Sets focus on the icon button. */
    focus(options) {
      this.button.focus(options);
    }
    /** Removes focus from the icon button. */
    blur() {
      this.button.blur();
    }
    render() {
      const isLink = this.href ? true : false;
      const tag = isLink ? i8`a` : i8`button`;
      return u5`
      <${tag}
        part="base"
        class=${e10({
        "icon-button": true,
        "icon-button--disabled": !isLink && this.disabled,
        "icon-button--focused": this.hasFocus
      })}
        ?disabled=${o11(isLink ? void 0 : this.disabled)}
        type=${o11(isLink ? void 0 : "button")}
        href=${o11(isLink ? this.href : void 0)}
        target=${o11(isLink ? this.target : void 0)}
        download=${o11(isLink ? this.download : void 0)}
        rel=${o11(isLink && this.target ? "noreferrer noopener" : void 0)}
        role=${o11(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-label="${this.label}"
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @click=${this.handleClick}
      >
        <sl-icon
          class="icon-button__icon"
          name=${o11(this.name)}
          library=${o11(this.library)}
          src=${o11(this.src)}
          aria-hidden="true"
        ></sl-icon>
      </${tag}>
    `;
    }
  };
  SlIconButton.styles = [component_styles_default, icon_button_styles_default];
  SlIconButton.dependencies = { "sl-icon": SlIcon };
  __decorateClass2([
    e6(".icon-button")
  ], SlIconButton.prototype, "button", 2);
  __decorateClass2([
    r6()
  ], SlIconButton.prototype, "hasFocus", 2);
  __decorateClass2([
    n5()
  ], SlIconButton.prototype, "name", 2);
  __decorateClass2([
    n5()
  ], SlIconButton.prototype, "library", 2);
  __decorateClass2([
    n5()
  ], SlIconButton.prototype, "src", 2);
  __decorateClass2([
    n5()
  ], SlIconButton.prototype, "href", 2);
  __decorateClass2([
    n5()
  ], SlIconButton.prototype, "target", 2);
  __decorateClass2([
    n5()
  ], SlIconButton.prototype, "download", 2);
  __decorateClass2([
    n5()
  ], SlIconButton.prototype, "label", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlIconButton.prototype, "disabled", 2);

  // node_modules/@shoelace-style/localize/dist/index.js
  var connectedElements = /* @__PURE__ */ new Set();
  var translations = /* @__PURE__ */ new Map();
  var fallback;
  var documentDirection = "ltr";
  var documentLanguage = "en";
  var isClient = typeof MutationObserver !== "undefined" && typeof document !== "undefined" && typeof document.documentElement !== "undefined";
  if (isClient) {
    const documentElementObserver = new MutationObserver(update);
    documentDirection = document.documentElement.dir || "ltr";
    documentLanguage = document.documentElement.lang || navigator.language;
    documentElementObserver.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["dir", "lang"]
    });
  }
  function registerTranslation(...translation2) {
    translation2.map((t7) => {
      const code = t7.$code.toLowerCase();
      if (translations.has(code)) {
        translations.set(code, Object.assign(Object.assign({}, translations.get(code)), t7));
      } else {
        translations.set(code, t7);
      }
      if (!fallback) {
        fallback = t7;
      }
    });
    update();
  }
  function update() {
    if (isClient) {
      documentDirection = document.documentElement.dir || "ltr";
      documentLanguage = document.documentElement.lang || navigator.language;
    }
    [...connectedElements.keys()].map((el) => {
      if (typeof el.requestUpdate === "function") {
        el.requestUpdate();
      }
    });
  }
  var LocalizeController = class {
    constructor(host) {
      this.host = host;
      this.host.addController(this);
    }
    hostConnected() {
      connectedElements.add(this.host);
    }
    hostDisconnected() {
      connectedElements.delete(this.host);
    }
    dir() {
      return `${this.host.dir || documentDirection}`.toLowerCase();
    }
    lang() {
      return `${this.host.lang || documentLanguage}`.toLowerCase();
    }
    getTranslationData(lang) {
      var _a, _b;
      const locale = new Intl.Locale(lang.replace(/_/g, "-"));
      const language = locale === null || locale === void 0 ? void 0 : locale.language.toLowerCase();
      const region = (_b = (_a = locale === null || locale === void 0 ? void 0 : locale.region) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : "";
      const primary = translations.get(`${language}-${region}`);
      const secondary = translations.get(language);
      return { locale, language, region, primary, secondary };
    }
    exists(key, options) {
      var _a;
      const { primary, secondary } = this.getTranslationData((_a = options.lang) !== null && _a !== void 0 ? _a : this.lang());
      options = Object.assign({ includeFallback: false }, options);
      if (primary && primary[key] || secondary && secondary[key] || options.includeFallback && fallback && fallback[key]) {
        return true;
      }
      return false;
    }
    term(key, ...args) {
      const { primary, secondary } = this.getTranslationData(this.lang());
      let term;
      if (primary && primary[key]) {
        term = primary[key];
      } else if (secondary && secondary[key]) {
        term = secondary[key];
      } else if (fallback && fallback[key]) {
        term = fallback[key];
      } else {
        console.error(`No translation found for: ${String(key)}`);
        return String(key);
      }
      if (typeof term === "function") {
        return term(...args);
      }
      return term;
    }
    date(dateToFormat, options) {
      dateToFormat = new Date(dateToFormat);
      return new Intl.DateTimeFormat(this.lang(), options).format(dateToFormat);
    }
    number(numberToFormat, options) {
      numberToFormat = Number(numberToFormat);
      return isNaN(numberToFormat) ? "" : new Intl.NumberFormat(this.lang(), options).format(numberToFormat);
    }
    relativeTime(value2, unit, options) {
      return new Intl.RelativeTimeFormat(this.lang(), options).format(value2, unit);
    }
  };

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7BTDLTNI.js
  var translation = {
    $code: "en",
    $name: "English",
    $dir: "ltr",
    carousel: "Carousel",
    clearEntry: "Clear entry",
    close: "Close",
    copied: "Copied",
    copy: "Copy",
    currentValue: "Current value",
    error: "Error",
    goToSlide: (slide, count) => `Go to slide ${slide} of ${count}`,
    hidePassword: "Hide password",
    loading: "Loading",
    nextSlide: "Next slide",
    numOptionsSelected: (num) => {
      if (num === 0)
        return "No options selected";
      if (num === 1)
        return "1 option selected";
      return `${num} options selected`;
    },
    previousSlide: "Previous slide",
    progress: "Progress",
    remove: "Remove",
    resize: "Resize",
    scrollToEnd: "Scroll to end",
    scrollToStart: "Scroll to start",
    selectAColorFromTheScreen: "Select a color from the screen",
    showPassword: "Show password",
    slideNum: (slide) => `Slide ${slide}`,
    toggleColorFormat: "Toggle color format"
  };
  registerTranslation(translation);
  var en_default = translation;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.6CTB5ZDJ.js
  var LocalizeController2 = class extends LocalizeController {
  };
  registerTranslation(en_default);

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.6R4LM7O6.js
  var SlTag = class extends ShoelaceElement {
    constructor() {
      super(...arguments);
      this.localize = new LocalizeController2(this);
      this.variant = "neutral";
      this.size = "medium";
      this.pill = false;
      this.removable = false;
    }
    handleRemoveClick() {
      this.emit("sl-remove");
    }
    render() {
      return x`
      <span
        part="base"
        class=${e10({
        tag: true,
        // Types
        "tag--primary": this.variant === "primary",
        "tag--success": this.variant === "success",
        "tag--neutral": this.variant === "neutral",
        "tag--warning": this.variant === "warning",
        "tag--danger": this.variant === "danger",
        "tag--text": this.variant === "text",
        // Sizes
        "tag--small": this.size === "small",
        "tag--medium": this.size === "medium",
        "tag--large": this.size === "large",
        // Modifiers
        "tag--pill": this.pill,
        "tag--removable": this.removable
      })}
      >
        <slot part="content" class="tag__content"></slot>

        ${this.removable ? x`
              <sl-icon-button
                part="remove-button"
                exportparts="base:remove-button__base"
                name="x-lg"
                library="system"
                label=${this.localize.term("remove")}
                class="tag__remove"
                @click=${this.handleRemoveClick}
                tabindex="-1"
              ></sl-icon-button>
            ` : ""}
      </span>
    `;
    }
  };
  SlTag.styles = [component_styles_default, tag_styles_default];
  SlTag.dependencies = { "sl-icon-button": SlIconButton };
  __decorateClass2([
    n5({ reflect: true })
  ], SlTag.prototype, "variant", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlTag.prototype, "size", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlTag.prototype, "pill", 2);
  __decorateClass2([
    n5({ type: Boolean })
  ], SlTag.prototype, "removable", 2);

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.6CGWZTF5.js
  SlTag.define("sl-tag");

  // node_modules/@jsfe/shoelace/dist/esm/widgets/array.js
  var array = (options) => {
    return x`
		<fieldset
			id=${options.id}
			class="theme-shoelace widget-array widget-fieldset level-${options.level}"
			part="widget-array"
		>
			${options.label ? x`<legend>${options.label}</legend>` : E2}
			<!-- -->
			${options.helpText ? x`<p class="widget-fieldset__description">${options.helpText}</p>` : E2}
			<!--  -->
			${options.items((index, widget, controls) => x`
					<sl-card
						class="widget-array__card"
						@dragover=${controls.wrapper.dragover}
						@dragenter=${controls.wrapper.dragenter}
						@dragleave=${controls.wrapper.dragleave}
						@drop=${controls.wrapper.drop}
					>
						<header slot="header" class="widget-array__header">
							<div
								class="widget-array__handle"
								.draggable=${true}
								@mousedown=${controls.handle.mousedown}
								@dragstart=${controls.handle.dragstart}
							>
								<sl-tag size="small" pill>${index + 1}</sl-tag>
								<div class="widget-array__handle-grip">
									<sl-icon name="grip-horizontal" label="Settings"></sl-icon>
								</div>
							</div>

							<nav>
								<sl-tooltip content="Delete">
									<sl-button size="small" @click=${controls.delete.click}>
										<sl-icon name="x-lg" label="Settings"></sl-icon>
									</sl-button>
								</sl-tooltip>

								<sl-divider vertical></sl-divider>

								<sl-button-group>
									<sl-tooltip content="Move item up">
										<sl-button
											size="small"
											@click=${controls.up.click}
											.disabled=${controls.up.disabled}
										>
											<sl-icon name="arrow-up" label="Up"></sl-icon>
										</sl-button>
									</sl-tooltip>

									<sl-tooltip content="Move item down">
										<sl-button
											size="small"
											@click=${controls.down.click}
											.disabled=${controls.down.disabled}
										>
											<sl-icon name="arrow-down" label="Down"></sl-icon>
										</sl-button>
									</sl-tooltip>
								</sl-button-group>
							</nav>
						</header>

						${widget}
					</sl-card>
				`)}

			<nav class="widget-array__add-zone">
				<sl-button @click=${options.controls.add.click} size="large">
					<sl-icon name="plus"></sl-icon> New
					${options.itemLabel ? x`"<strong>${options.itemLabel}</strong>"` : E2}
				</sl-button>
			</nav>
		</fieldset>
	`;
  };

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.B63YXDJO.js
  var radio_group_styles_default = i3`
  :host {
    display: block;
  }

  .form-control {
    position: relative;
    border: none;
    padding: 0;
    margin: 0;
  }

  .form-control__label {
    padding: 0;
  }

  .radio-group--required .radio-group__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
  }

  .visually-hidden {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.SI4ACBFK.js
  var form_control_styles_default = i3`
  .form-control .form-control__label {
    display: none;
  }

  .form-control .form-control__help-text {
    display: none;
  }

  /* Label */
  .form-control--has-label .form-control__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    margin-bottom: var(--sl-spacing-3x-small);
  }

  .form-control--has-label.form-control--small .form-control__label {
    font-size: var(--sl-input-label-font-size-small);
  }

  .form-control--has-label.form-control--medium .form-control__label {
    font-size: var(--sl-input-label-font-size-medium);
  }

  .form-control--has-label.form-control--large .form-control__label {
    font-size: var(--sl-input-label-font-size-large);
  }

  :host([required]) .form-control--has-label .form-control__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
    color: var(--sl-input-required-content-color);
  }

  /* Help text */
  .form-control--has-help-text .form-control__help-text {
    display: block;
    color: var(--sl-input-help-text-color);
    margin-top: var(--sl-spacing-3x-small);
  }

  .form-control--has-help-text.form-control--small .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-small);
  }

  .form-control--has-help-text.form-control--medium .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-medium);
  }

  .form-control--has-help-text.form-control--large .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-large);
  }

  .form-control--has-help-text.form-control--radio-group .form-control__help-text {
    margin-top: var(--sl-spacing-2x-small);
  }
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2OUC42YY.js
  var button_group_styles_default = i3`
  :host {
    display: inline-block;
  }

  .button-group {
    display: flex;
    flex-wrap: nowrap;
  }
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.A36OXQYR.js
  var SlButtonGroup = class extends ShoelaceElement {
    constructor() {
      super(...arguments);
      this.disableRole = false;
      this.label = "";
    }
    handleFocus(event) {
      const button = findButton(event.target);
      button == null ? void 0 : button.toggleAttribute("data-sl-button-group__button--focus", true);
    }
    handleBlur(event) {
      const button = findButton(event.target);
      button == null ? void 0 : button.toggleAttribute("data-sl-button-group__button--focus", false);
    }
    handleMouseOver(event) {
      const button = findButton(event.target);
      button == null ? void 0 : button.toggleAttribute("data-sl-button-group__button--hover", true);
    }
    handleMouseOut(event) {
      const button = findButton(event.target);
      button == null ? void 0 : button.toggleAttribute("data-sl-button-group__button--hover", false);
    }
    handleSlotChange() {
      const slottedElements = [...this.defaultSlot.assignedElements({ flatten: true })];
      slottedElements.forEach((el) => {
        const index = slottedElements.indexOf(el);
        const button = findButton(el);
        if (button) {
          button.toggleAttribute("data-sl-button-group__button", true);
          button.toggleAttribute("data-sl-button-group__button--first", index === 0);
          button.toggleAttribute("data-sl-button-group__button--inner", index > 0 && index < slottedElements.length - 1);
          button.toggleAttribute("data-sl-button-group__button--last", index === slottedElements.length - 1);
          button.toggleAttribute(
            "data-sl-button-group__button--radio",
            button.tagName.toLowerCase() === "sl-radio-button"
          );
        }
      });
    }
    render() {
      return x`
      <div
        part="base"
        class="button-group"
        role="${this.disableRole ? "presentation" : "group"}"
        aria-label=${this.label}
        @focusout=${this.handleBlur}
        @focusin=${this.handleFocus}
        @mouseover=${this.handleMouseOver}
        @mouseout=${this.handleMouseOut}
      >
        <slot @slotchange=${this.handleSlotChange}></slot>
      </div>
    `;
    }
  };
  SlButtonGroup.styles = [component_styles_default, button_group_styles_default];
  __decorateClass2([
    e6("slot")
  ], SlButtonGroup.prototype, "defaultSlot", 2);
  __decorateClass2([
    r6()
  ], SlButtonGroup.prototype, "disableRole", 2);
  __decorateClass2([
    n5()
  ], SlButtonGroup.prototype, "label", 2);
  function findButton(el) {
    var _a;
    const selector = "sl-button, sl-radio-button";
    return (_a = el.closest(selector)) != null ? _a : el.querySelector(selector);
  }

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3RPBFEDE.js
  var formCollections = /* @__PURE__ */ new WeakMap();
  var reportValidityOverloads = /* @__PURE__ */ new WeakMap();
  var checkValidityOverloads = /* @__PURE__ */ new WeakMap();
  var userInteractedControls = /* @__PURE__ */ new WeakSet();
  var interactions = /* @__PURE__ */ new WeakMap();
  var FormControlController = class {
    constructor(host, options) {
      this.handleFormData = (event) => {
        const disabled = this.options.disabled(this.host);
        const name = this.options.name(this.host);
        const value2 = this.options.value(this.host);
        const isButton = this.host.tagName.toLowerCase() === "sl-button";
        if (this.host.isConnected && !disabled && !isButton && typeof name === "string" && name.length > 0 && typeof value2 !== "undefined") {
          if (Array.isArray(value2)) {
            value2.forEach((val) => {
              event.formData.append(name, val.toString());
            });
          } else {
            event.formData.append(name, value2.toString());
          }
        }
      };
      this.handleFormSubmit = (event) => {
        var _a;
        const disabled = this.options.disabled(this.host);
        const reportValidity = this.options.reportValidity;
        if (this.form && !this.form.noValidate) {
          (_a = formCollections.get(this.form)) == null ? void 0 : _a.forEach((control) => {
            this.setUserInteracted(control, true);
          });
        }
        if (this.form && !this.form.noValidate && !disabled && !reportValidity(this.host)) {
          event.preventDefault();
          event.stopImmediatePropagation();
        }
      };
      this.handleFormReset = () => {
        this.options.setValue(this.host, this.options.defaultValue(this.host));
        this.setUserInteracted(this.host, false);
        interactions.set(this.host, []);
      };
      this.handleInteraction = (event) => {
        const emittedEvents = interactions.get(this.host);
        if (!emittedEvents.includes(event.type)) {
          emittedEvents.push(event.type);
        }
        if (emittedEvents.length === this.options.assumeInteractionOn.length) {
          this.setUserInteracted(this.host, true);
        }
      };
      this.checkFormValidity = () => {
        if (this.form && !this.form.noValidate) {
          const elements = this.form.querySelectorAll("*");
          for (const element of elements) {
            if (typeof element.checkValidity === "function") {
              if (!element.checkValidity()) {
                return false;
              }
            }
          }
        }
        return true;
      };
      this.reportFormValidity = () => {
        if (this.form && !this.form.noValidate) {
          const elements = this.form.querySelectorAll("*");
          for (const element of elements) {
            if (typeof element.reportValidity === "function") {
              if (!element.reportValidity()) {
                return false;
              }
            }
          }
        }
        return true;
      };
      (this.host = host).addController(this);
      this.options = __spreadValues({
        form: (input) => {
          const formId = input.form;
          if (formId) {
            const root2 = input.getRootNode();
            const form = root2.querySelector(`#${formId}`);
            if (form) {
              return form;
            }
          }
          return input.closest("form");
        },
        name: (input) => input.name,
        value: (input) => input.value,
        defaultValue: (input) => input.defaultValue,
        disabled: (input) => {
          var _a;
          return (_a = input.disabled) != null ? _a : false;
        },
        reportValidity: (input) => typeof input.reportValidity === "function" ? input.reportValidity() : true,
        checkValidity: (input) => typeof input.checkValidity === "function" ? input.checkValidity() : true,
        setValue: (input, value2) => input.value = value2,
        assumeInteractionOn: ["sl-input"]
      }, options);
    }
    hostConnected() {
      const form = this.options.form(this.host);
      if (form) {
        this.attachForm(form);
      }
      interactions.set(this.host, []);
      this.options.assumeInteractionOn.forEach((event) => {
        this.host.addEventListener(event, this.handleInteraction);
      });
    }
    hostDisconnected() {
      this.detachForm();
      interactions.delete(this.host);
      this.options.assumeInteractionOn.forEach((event) => {
        this.host.removeEventListener(event, this.handleInteraction);
      });
    }
    hostUpdated() {
      const form = this.options.form(this.host);
      if (!form) {
        this.detachForm();
      }
      if (form && this.form !== form) {
        this.detachForm();
        this.attachForm(form);
      }
      if (this.host.hasUpdated) {
        this.setValidity(this.host.validity.valid);
      }
    }
    attachForm(form) {
      if (form) {
        this.form = form;
        if (formCollections.has(this.form)) {
          formCollections.get(this.form).add(this.host);
        } else {
          formCollections.set(this.form, /* @__PURE__ */ new Set([this.host]));
        }
        this.form.addEventListener("formdata", this.handleFormData);
        this.form.addEventListener("submit", this.handleFormSubmit);
        this.form.addEventListener("reset", this.handleFormReset);
        if (!reportValidityOverloads.has(this.form)) {
          reportValidityOverloads.set(this.form, this.form.reportValidity);
          this.form.reportValidity = () => this.reportFormValidity();
        }
        if (!checkValidityOverloads.has(this.form)) {
          checkValidityOverloads.set(this.form, this.form.checkValidity);
          this.form.checkValidity = () => this.checkFormValidity();
        }
      } else {
        this.form = void 0;
      }
    }
    detachForm() {
      if (!this.form)
        return;
      const formCollection = formCollections.get(this.form);
      if (!formCollection) {
        return;
      }
      formCollection.delete(this.host);
      if (formCollection.size <= 0) {
        this.form.removeEventListener("formdata", this.handleFormData);
        this.form.removeEventListener("submit", this.handleFormSubmit);
        this.form.removeEventListener("reset", this.handleFormReset);
        if (reportValidityOverloads.has(this.form)) {
          this.form.reportValidity = reportValidityOverloads.get(this.form);
          reportValidityOverloads.delete(this.form);
        }
        if (checkValidityOverloads.has(this.form)) {
          this.form.checkValidity = checkValidityOverloads.get(this.form);
          checkValidityOverloads.delete(this.form);
        }
        this.form = void 0;
      }
    }
    setUserInteracted(el, hasInteracted) {
      if (hasInteracted) {
        userInteractedControls.add(el);
      } else {
        userInteractedControls.delete(el);
      }
      el.requestUpdate();
    }
    doAction(type, submitter) {
      if (this.form) {
        const button = document.createElement("button");
        button.type = type;
        button.style.position = "absolute";
        button.style.width = "0";
        button.style.height = "0";
        button.style.clipPath = "inset(50%)";
        button.style.overflow = "hidden";
        button.style.whiteSpace = "nowrap";
        if (submitter) {
          button.name = submitter.name;
          button.value = submitter.value;
          ["formaction", "formenctype", "formmethod", "formnovalidate", "formtarget"].forEach((attr) => {
            if (submitter.hasAttribute(attr)) {
              button.setAttribute(attr, submitter.getAttribute(attr));
            }
          });
        }
        this.form.append(button);
        button.click();
        button.remove();
      }
    }
    /** Returns the associated `<form>` element, if one exists. */
    getForm() {
      var _a;
      return (_a = this.form) != null ? _a : null;
    }
    /** Resets the form, restoring all the control to their default value */
    reset(submitter) {
      this.doAction("reset", submitter);
    }
    /** Submits the form, triggering validation and form data injection. */
    submit(submitter) {
      this.doAction("submit", submitter);
    }
    /**
     * Synchronously sets the form control's validity. Call this when you know the future validity but need to update
     * the host element immediately, i.e. before Lit updates the component in the next update.
     */
    setValidity(isValid) {
      const host = this.host;
      const hasInteracted = Boolean(userInteractedControls.has(host));
      const required = Boolean(host.required);
      host.toggleAttribute("data-required", required);
      host.toggleAttribute("data-optional", !required);
      host.toggleAttribute("data-invalid", !isValid);
      host.toggleAttribute("data-valid", isValid);
      host.toggleAttribute("data-user-invalid", !isValid && hasInteracted);
      host.toggleAttribute("data-user-valid", isValid && hasInteracted);
    }
    /**
     * Updates the form control's validity based on the current value of `host.validity.valid`. Call this when anything
     * that affects constraint validation changes so the component receives the correct validity states.
     */
    updateValidity() {
      const host = this.host;
      this.setValidity(host.validity.valid);
    }
    /**
     * Dispatches a non-bubbling, cancelable custom event of type `sl-invalid`.
     * If the `sl-invalid` event will be cancelled then the original `invalid`
     * event (which may have been passed as argument) will also be cancelled.
     * If no original `invalid` event has been passed then the `sl-invalid`
     * event will be cancelled before being dispatched.
     */
    emitInvalidEvent(originalInvalidEvent) {
      const slInvalidEvent = new CustomEvent("sl-invalid", {
        bubbles: false,
        composed: false,
        cancelable: true,
        detail: {}
      });
      if (!originalInvalidEvent) {
        slInvalidEvent.preventDefault();
      }
      if (!this.host.dispatchEvent(slInvalidEvent)) {
        originalInvalidEvent == null ? void 0 : originalInvalidEvent.preventDefault();
      }
    }
  };
  var validValidityState = Object.freeze({
    badInput: false,
    customError: false,
    patternMismatch: false,
    rangeOverflow: false,
    rangeUnderflow: false,
    stepMismatch: false,
    tooLong: false,
    tooShort: false,
    typeMismatch: false,
    valid: true,
    valueMissing: false
  });
  var valueMissingValidityState = Object.freeze(__spreadProps(__spreadValues({}, validValidityState), {
    valid: false,
    valueMissing: true
  }));
  var customErrorValidityState = Object.freeze(__spreadProps(__spreadValues({}, validValidityState), {
    valid: false,
    customError: true
  }));

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.ZJNIZFRS.js
  var SlRadioGroup = class extends ShoelaceElement {
    constructor() {
      super(...arguments);
      this.formControlController = new FormControlController(this);
      this.hasSlotController = new HasSlotController(this, "help-text", "label");
      this.customValidityMessage = "";
      this.hasButtonGroup = false;
      this.errorMessage = "";
      this.defaultValue = "";
      this.label = "";
      this.helpText = "";
      this.name = "option";
      this.value = "";
      this.size = "medium";
      this.form = "";
      this.required = false;
    }
    /** Gets the validity state object */
    get validity() {
      const isRequiredAndEmpty = this.required && !this.value;
      const hasCustomValidityMessage = this.customValidityMessage !== "";
      if (hasCustomValidityMessage) {
        return customErrorValidityState;
      } else if (isRequiredAndEmpty) {
        return valueMissingValidityState;
      }
      return validValidityState;
    }
    /** Gets the validation message */
    get validationMessage() {
      const isRequiredAndEmpty = this.required && !this.value;
      const hasCustomValidityMessage = this.customValidityMessage !== "";
      if (hasCustomValidityMessage) {
        return this.customValidityMessage;
      } else if (isRequiredAndEmpty) {
        return this.validationInput.validationMessage;
      }
      return "";
    }
    connectedCallback() {
      super.connectedCallback();
      this.defaultValue = this.value;
    }
    firstUpdated() {
      this.formControlController.updateValidity();
    }
    getAllRadios() {
      return [...this.querySelectorAll("sl-radio, sl-radio-button")];
    }
    handleRadioClick(event) {
      const target = event.target.closest("sl-radio, sl-radio-button");
      const radios = this.getAllRadios();
      const oldValue = this.value;
      if (!target || target.disabled) {
        return;
      }
      this.value = target.value;
      radios.forEach((radio) => radio.checked = radio === target);
      if (this.value !== oldValue) {
        this.emit("sl-change");
        this.emit("sl-input");
      }
    }
    handleKeyDown(event) {
      var _a;
      if (!["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(event.key)) {
        return;
      }
      const radios = this.getAllRadios().filter((radio) => !radio.disabled);
      const checkedRadio = (_a = radios.find((radio) => radio.checked)) != null ? _a : radios[0];
      const incr = event.key === " " ? 0 : ["ArrowUp", "ArrowLeft"].includes(event.key) ? -1 : 1;
      const oldValue = this.value;
      let index = radios.indexOf(checkedRadio) + incr;
      if (index < 0) {
        index = radios.length - 1;
      }
      if (index > radios.length - 1) {
        index = 0;
      }
      this.getAllRadios().forEach((radio) => {
        radio.checked = false;
        if (!this.hasButtonGroup) {
          radio.setAttribute("tabindex", "-1");
        }
      });
      this.value = radios[index].value;
      radios[index].checked = true;
      if (!this.hasButtonGroup) {
        radios[index].setAttribute("tabindex", "0");
        radios[index].focus();
      } else {
        radios[index].shadowRoot.querySelector("button").focus();
      }
      if (this.value !== oldValue) {
        this.emit("sl-change");
        this.emit("sl-input");
      }
      event.preventDefault();
    }
    handleLabelClick() {
      this.focus();
    }
    handleInvalid(event) {
      this.formControlController.setValidity(false);
      this.formControlController.emitInvalidEvent(event);
    }
    async syncRadioElements() {
      var _a, _b;
      const radios = this.getAllRadios();
      await Promise.all(
        // Sync the checked state and size
        radios.map(async (radio) => {
          await radio.updateComplete;
          radio.checked = radio.value === this.value;
          radio.size = this.size;
        })
      );
      this.hasButtonGroup = radios.some((radio) => radio.tagName.toLowerCase() === "sl-radio-button");
      if (radios.length > 0 && !radios.some((radio) => radio.checked)) {
        if (this.hasButtonGroup) {
          const buttonRadio = (_a = radios[0].shadowRoot) == null ? void 0 : _a.querySelector("button");
          if (buttonRadio) {
            buttonRadio.setAttribute("tabindex", "0");
          }
        } else {
          radios[0].setAttribute("tabindex", "0");
        }
      }
      if (this.hasButtonGroup) {
        const buttonGroup2 = (_b = this.shadowRoot) == null ? void 0 : _b.querySelector("sl-button-group");
        if (buttonGroup2) {
          buttonGroup2.disableRole = true;
        }
      }
    }
    syncRadios() {
      if (customElements.get("sl-radio") && customElements.get("sl-radio-button")) {
        this.syncRadioElements();
        return;
      }
      if (customElements.get("sl-radio")) {
        this.syncRadioElements();
      } else {
        customElements.whenDefined("sl-radio").then(() => this.syncRadios());
      }
      if (customElements.get("sl-radio-button")) {
        this.syncRadioElements();
      } else {
        customElements.whenDefined("sl-radio-button").then(() => this.syncRadios());
      }
    }
    updateCheckedRadio() {
      const radios = this.getAllRadios();
      radios.forEach((radio) => radio.checked = radio.value === this.value);
      this.formControlController.setValidity(this.validity.valid);
    }
    handleSizeChange() {
      this.syncRadios();
    }
    handleValueChange() {
      if (this.hasUpdated) {
        this.updateCheckedRadio();
      }
    }
    /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
    checkValidity() {
      const isRequiredAndEmpty = this.required && !this.value;
      const hasCustomValidityMessage = this.customValidityMessage !== "";
      if (isRequiredAndEmpty || hasCustomValidityMessage) {
        this.formControlController.emitInvalidEvent();
        return false;
      }
      return true;
    }
    /** Gets the associated form, if one exists. */
    getForm() {
      return this.formControlController.getForm();
    }
    /** Checks for validity and shows the browser's validation message if the control is invalid. */
    reportValidity() {
      const isValid = this.validity.valid;
      this.errorMessage = this.customValidityMessage || isValid ? "" : this.validationInput.validationMessage;
      this.formControlController.setValidity(isValid);
      this.validationInput.hidden = true;
      clearTimeout(this.validationTimeout);
      if (!isValid) {
        this.validationInput.hidden = false;
        this.validationInput.reportValidity();
        this.validationTimeout = setTimeout(() => this.validationInput.hidden = true, 1e4);
      }
      return isValid;
    }
    /** Sets a custom validation message. Pass an empty string to restore validity. */
    setCustomValidity(message = "") {
      this.customValidityMessage = message;
      this.errorMessage = message;
      this.validationInput.setCustomValidity(message);
      this.formControlController.updateValidity();
    }
    /** Sets focus on the radio-group. */
    focus(options) {
      const radios = this.getAllRadios();
      const checked = radios.find((radio) => radio.checked);
      const firstEnabledRadio = radios.find((radio) => !radio.disabled);
      const radioToFocus = checked || firstEnabledRadio;
      if (radioToFocus) {
        radioToFocus.focus(options);
      }
    }
    render() {
      const hasLabelSlot = this.hasSlotController.test("label");
      const hasHelpTextSlot = this.hasSlotController.test("help-text");
      const hasLabel = this.label ? true : !!hasLabelSlot;
      const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
      const defaultSlot = x`
      <slot @slotchange=${this.syncRadios} @click=${this.handleRadioClick} @keydown=${this.handleKeyDown}></slot>
    `;
      return x`
      <fieldset
        part="form-control"
        class=${e10({
        "form-control": true,
        "form-control--small": this.size === "small",
        "form-control--medium": this.size === "medium",
        "form-control--large": this.size === "large",
        "form-control--radio-group": true,
        "form-control--has-label": hasLabel,
        "form-control--has-help-text": hasHelpText
      })}
        role="radiogroup"
        aria-labelledby="label"
        aria-describedby="help-text"
        aria-errormessage="error-message"
      >
        <label
          part="form-control-label"
          id="label"
          class="form-control__label"
          aria-hidden=${hasLabel ? "false" : "true"}
          @click=${this.handleLabelClick}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div class="visually-hidden">
            <div id="error-message" aria-live="assertive">${this.errorMessage}</div>
            <label class="radio-group__validation">
              <input
                type="text"
                class="radio-group__validation-input"
                ?required=${this.required}
                tabindex="-1"
                hidden
                @invalid=${this.handleInvalid}
              />
            </label>
          </div>

          ${this.hasButtonGroup ? x`
                <sl-button-group part="button-group" exportparts="base:button-group__base" role="presentation">
                  ${defaultSlot}
                </sl-button-group>
              ` : defaultSlot}
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </fieldset>
    `;
    }
  };
  SlRadioGroup.styles = [component_styles_default, form_control_styles_default, radio_group_styles_default];
  SlRadioGroup.dependencies = { "sl-button-group": SlButtonGroup };
  __decorateClass2([
    e6("slot:not([name])")
  ], SlRadioGroup.prototype, "defaultSlot", 2);
  __decorateClass2([
    e6(".radio-group__validation-input")
  ], SlRadioGroup.prototype, "validationInput", 2);
  __decorateClass2([
    r6()
  ], SlRadioGroup.prototype, "hasButtonGroup", 2);
  __decorateClass2([
    r6()
  ], SlRadioGroup.prototype, "errorMessage", 2);
  __decorateClass2([
    r6()
  ], SlRadioGroup.prototype, "defaultValue", 2);
  __decorateClass2([
    n5()
  ], SlRadioGroup.prototype, "label", 2);
  __decorateClass2([
    n5({ attribute: "help-text" })
  ], SlRadioGroup.prototype, "helpText", 2);
  __decorateClass2([
    n5()
  ], SlRadioGroup.prototype, "name", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlRadioGroup.prototype, "value", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlRadioGroup.prototype, "size", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlRadioGroup.prototype, "form", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlRadioGroup.prototype, "required", 2);
  __decorateClass2([
    watch("size", { waitUntilFirstUpdate: true })
  ], SlRadioGroup.prototype, "handleSizeChange", 1);
  __decorateClass2([
    watch("value")
  ], SlRadioGroup.prototype, "handleValueChange", 1);

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2PCBEMQZ.js
  SlRadioGroup.define("sl-radio-group");

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.MAQXLKQ7.js
  var button_styles_default = i3`
  :host {
    display: inline-block;
    position: relative;
    width: auto;
    cursor: pointer;
  }

  .button {
    display: inline-flex;
    align-items: stretch;
    justify-content: center;
    width: 100%;
    border-style: solid;
    border-width: var(--sl-input-border-width);
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-font-weight-semibold);
    text-decoration: none;
    user-select: none;
    -webkit-user-select: none;
    white-space: nowrap;
    vertical-align: middle;
    padding: 0;
    transition:
      var(--sl-transition-x-fast) background-color,
      var(--sl-transition-x-fast) color,
      var(--sl-transition-x-fast) border,
      var(--sl-transition-x-fast) box-shadow;
    cursor: inherit;
  }

  .button::-moz-focus-inner {
    border: 0;
  }

  .button:focus {
    outline: none;
  }

  .button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When disabled, prevent mouse events from bubbling up from children */
  .button--disabled * {
    pointer-events: none;
  }

  .button__prefix,
  .button__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    pointer-events: none;
  }

  .button__label {
    display: inline-block;
  }

  .button__label::slotted(sl-icon) {
    vertical-align: -2px;
  }

  /*
   * Standard buttons
   */

  /* Default */
  .button--standard.button--default {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-input-border-color);
    color: var(--sl-color-neutral-700);
  }

  .button--standard.button--default:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-300);
    color: var(--sl-color-primary-700);
  }

  .button--standard.button--default:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-100);
    border-color: var(--sl-color-primary-400);
    color: var(--sl-color-primary-700);
  }

  /* Primary */
  .button--standard.button--primary {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--standard.button--success {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:hover:not(.button--disabled) {
    background-color: var(--sl-color-success-500);
    border-color: var(--sl-color-success-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:active:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--standard.button--neutral {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:hover:not(.button--disabled) {
    background-color: var(--sl-color-neutral-500);
    border-color: var(--sl-color-neutral-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:active:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--standard.button--warning {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }
  .button--standard.button--warning:hover:not(.button--disabled) {
    background-color: var(--sl-color-warning-500);
    border-color: var(--sl-color-warning-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--warning:active:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--standard.button--danger {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:hover:not(.button--disabled) {
    background-color: var(--sl-color-danger-500);
    border-color: var(--sl-color-danger-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:active:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /*
   * Outline buttons
   */

  .button--outline {
    background: none;
    border: solid 1px;
  }

  /* Default */
  .button--outline.button--default {
    border-color: var(--sl-input-border-color);
    color: var(--sl-color-neutral-700);
  }

  .button--outline.button--default:hover:not(.button--disabled),
  .button--outline.button--default.button--checked:not(.button--disabled) {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--default:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Primary */
  .button--outline.button--primary {
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-primary-600);
  }

  .button--outline.button--primary:hover:not(.button--disabled),
  .button--outline.button--primary.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--primary:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--outline.button--success {
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-success-600);
  }

  .button--outline.button--success:hover:not(.button--disabled),
  .button--outline.button--success.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--success:active:not(.button--disabled) {
    border-color: var(--sl-color-success-700);
    background-color: var(--sl-color-success-700);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--outline.button--neutral {
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-600);
  }

  .button--outline.button--neutral:hover:not(.button--disabled),
  .button--outline.button--neutral.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--neutral:active:not(.button--disabled) {
    border-color: var(--sl-color-neutral-700);
    background-color: var(--sl-color-neutral-700);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--outline.button--warning {
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-warning-600);
  }

  .button--outline.button--warning:hover:not(.button--disabled),
  .button--outline.button--warning.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--warning:active:not(.button--disabled) {
    border-color: var(--sl-color-warning-700);
    background-color: var(--sl-color-warning-700);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--outline.button--danger {
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-danger-600);
  }

  .button--outline.button--danger:hover:not(.button--disabled),
  .button--outline.button--danger.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--danger:active:not(.button--disabled) {
    border-color: var(--sl-color-danger-700);
    background-color: var(--sl-color-danger-700);
    color: var(--sl-color-neutral-0);
  }

  @media (forced-colors: active) {
    .button.button--outline.button--checked:not(.button--disabled) {
      outline: solid 2px transparent;
    }
  }

  /*
   * Text buttons
   */

  .button--text {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-600);
  }

  .button--text:hover:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:focus-visible:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:active:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-700);
  }

  /*
   * Size modifiers
   */

  .button--small {
    height: auto;
    min-height: var(--sl-input-height-small);
    font-size: var(--sl-button-font-size-small);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
  }

  .button--medium {
    height: auto;
    min-height: var(--sl-input-height-medium);
    font-size: var(--sl-button-font-size-medium);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
  }

  .button--large {
    height: auto;
    min-height: var(--sl-input-height-large);
    font-size: var(--sl-button-font-size-large);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
  }

  /*
   * Pill modifier
   */

  .button--pill.button--small {
    border-radius: var(--sl-input-height-small);
  }

  .button--pill.button--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .button--pill.button--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Circle modifier
   */

  .button--circle {
    padding-left: 0;
    padding-right: 0;
  }

  .button--circle.button--small {
    width: var(--sl-input-height-small);
    border-radius: 50%;
  }

  .button--circle.button--medium {
    width: var(--sl-input-height-medium);
    border-radius: 50%;
  }

  .button--circle.button--large {
    width: var(--sl-input-height-large);
    border-radius: 50%;
  }

  .button--circle .button__prefix,
  .button--circle .button__suffix,
  .button--circle .button__caret {
    display: none;
  }

  /*
   * Caret modifier
   */

  .button--caret .button__suffix {
    display: none;
  }

  .button--caret .button__caret {
    height: auto;
  }

  /*
   * Loading modifier
   */

  .button--loading {
    position: relative;
    cursor: wait;
  }

  .button--loading .button__prefix,
  .button--loading .button__label,
  .button--loading .button__suffix,
  .button--loading .button__caret {
    visibility: hidden;
  }

  .button--loading sl-spinner {
    --indicator-color: currentColor;
    position: absolute;
    font-size: 1em;
    height: 1em;
    width: 1em;
    top: calc(50% - 0.5em);
    left: calc(50% - 0.5em);
  }

  /*
   * Badges
   */

  .button ::slotted(sl-badge) {
    position: absolute;
    top: 0;
    right: 0;
    translate: 50% -50%;
    pointer-events: none;
  }

  .button--rtl ::slotted(sl-badge) {
    right: auto;
    left: 0;
    translate: -50% -50%;
  }

  /*
   * Button spacing
   */

  .button--has-label.button--small .button__label {
    padding: 0 var(--sl-spacing-small);
  }

  .button--has-label.button--medium .button__label {
    padding: 0 var(--sl-spacing-medium);
  }

  .button--has-label.button--large .button__label {
    padding: 0 var(--sl-spacing-large);
  }

  .button--has-prefix.button--small {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--small .button__label {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--medium {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--medium .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-suffix.button--small,
  .button--caret.button--small {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--small .button__label,
  .button--caret.button--small .button__label {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--medium,
  .button--caret.button--medium {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--medium .button__label,
  .button--caret.button--medium .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large,
  .button--caret.button--large {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large .button__label,
  .button--caret.button--large .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  /*
   * Button groups support a variety of button types (e.g. buttons with tooltips, buttons as dropdown triggers, etc.).
   * This means buttons aren't always direct descendants of the button group, thus we can't target them with the
   * ::slotted selector. To work around this, the button group component does some magic to add these special classes to
   * buttons and we style them here instead.
   */

  :host([data-sl-button-group__button--first]:not([data-sl-button-group__button--last])) .button {
    border-start-end-radius: 0;
    border-end-end-radius: 0;
  }

  :host([data-sl-button-group__button--inner]) .button {
    border-radius: 0;
  }

  :host([data-sl-button-group__button--last]:not([data-sl-button-group__button--first])) .button {
    border-start-start-radius: 0;
    border-end-start-radius: 0;
  }

  /* All except the first */
  :host([data-sl-button-group__button]:not([data-sl-button-group__button--first])) {
    margin-inline-start: calc(-1 * var(--sl-input-border-width));
  }

  /* Add a visual separator between solid buttons */
  :host(
      [data-sl-button-group__button]:not(
          [data-sl-button-group__button--first],
          [data-sl-button-group__button--radio],
          [variant='default']
        ):not(:hover)
    )
    .button:after {
    content: '';
    position: absolute;
    top: 0;
    inset-inline-start: 0;
    bottom: 0;
    border-left: solid 1px rgb(128 128 128 / 33%);
    mix-blend-mode: multiply;
  }

  /* Bump hovered, focused, and checked buttons up so their focus ring isn't clipped */
  :host([data-sl-button-group__button--hover]) {
    z-index: 1;
  }

  /* Focus and checked are always on top */
  :host([data-sl-button-group__button--focus]),
  :host([data-sl-button-group__button][checked]) {
    z-index: 2;
  }
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2P5EQCYK.js
  var radio_button_styles_default = i3`
  ${button_styles_default}

  .button__prefix,
  .button__suffix,
  .button__label {
    display: inline-flex;
    position: relative;
    align-items: center;
  }

  /* We use a hidden input so constraint validation errors work, since they don't appear to show when used with buttons.
    We can't actually hide it, though, otherwise the messages will be suppressed by the browser. */
  .hidden-input {
    all: unset;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    outline: dotted 1px red;
    opacity: 0;
    z-index: -1;
  }
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.G7RQ5NDY.js
  var SlRadioButton = class extends ShoelaceElement {
    constructor() {
      super(...arguments);
      this.hasSlotController = new HasSlotController(this, "[default]", "prefix", "suffix");
      this.hasFocus = false;
      this.checked = false;
      this.disabled = false;
      this.size = "medium";
      this.pill = false;
    }
    connectedCallback() {
      super.connectedCallback();
      this.setAttribute("role", "presentation");
    }
    handleBlur() {
      this.hasFocus = false;
      this.emit("sl-blur");
    }
    handleClick(e13) {
      if (this.disabled) {
        e13.preventDefault();
        e13.stopPropagation();
        return;
      }
      this.checked = true;
    }
    handleFocus() {
      this.hasFocus = true;
      this.emit("sl-focus");
    }
    handleDisabledChange() {
      this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
    }
    /** Sets focus on the radio button. */
    focus(options) {
      this.input.focus(options);
    }
    /** Removes focus from the radio button. */
    blur() {
      this.input.blur();
    }
    render() {
      return u5`
      <div part="base" role="presentation">
        <button
          part="${`button${this.checked ? " button--checked" : ""}`}"
          role="radio"
          aria-checked="${this.checked}"
          class=${e10({
        button: true,
        "button--default": true,
        "button--small": this.size === "small",
        "button--medium": this.size === "medium",
        "button--large": this.size === "large",
        "button--checked": this.checked,
        "button--disabled": this.disabled,
        "button--focused": this.hasFocus,
        "button--outline": true,
        "button--pill": this.pill,
        "button--has-label": this.hasSlotController.test("[default]"),
        "button--has-prefix": this.hasSlotController.test("prefix"),
        "button--has-suffix": this.hasSlotController.test("suffix")
      })}
          aria-disabled=${this.disabled}
          type="button"
          value=${o11(this.value)}
          @blur=${this.handleBlur}
          @focus=${this.handleFocus}
          @click=${this.handleClick}
        >
          <slot name="prefix" part="prefix" class="button__prefix"></slot>
          <slot part="label" class="button__label"></slot>
          <slot name="suffix" part="suffix" class="button__suffix"></slot>
        </button>
      </div>
    `;
    }
  };
  SlRadioButton.styles = [component_styles_default, radio_button_styles_default];
  __decorateClass2([
    e6(".button")
  ], SlRadioButton.prototype, "input", 2);
  __decorateClass2([
    e6(".hidden-input")
  ], SlRadioButton.prototype, "hiddenInput", 2);
  __decorateClass2([
    r6()
  ], SlRadioButton.prototype, "hasFocus", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlRadioButton.prototype, "checked", 2);
  __decorateClass2([
    n5()
  ], SlRadioButton.prototype, "value", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlRadioButton.prototype, "disabled", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlRadioButton.prototype, "size", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlRadioButton.prototype, "pill", 2);
  __decorateClass2([
    watch("disabled", { waitUntilFirstUpdate: true })
  ], SlRadioButton.prototype, "handleDisabledChange", 1);

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.5P45LHIX.js
  SlRadioButton.define("sl-radio-button");

  // node_modules/@jsfe/shoelace/dist/esm/widgets/button-group.js
  var buttonGroup = (options) => x`
	<sl-radio-group
		size="medium"
		.label=${options.label ?? ""}
		.helpText=${options.helpText ?? ""}
		value=${typeof options.value !== "undefined" ? String(options.value) : ""}
		.name=${options.id}
		.required=${options.required ?? false}
		@sl-change=${(event) => {
    let newValue = event.target.value;
    if (options.type === "number") {
      newValue = Number(newValue);
    }
    options.valueChangedCallback?.(newValue);
  }}
	>
		${options.enum?.map((enumVal) => x`<sl-radio-button
					.disabled=${String(enumVal) === options.value ? false : options.disabled}
					value=${String(enumVal)}
					>${enumVal}</sl-radio-button
				>`)}
	</sl-radio-group>
`;

  // node_modules/@jsfe/shoelace/dist/esm/widgets/button-group-boolean.js
  var buttonGroupBoolean = (options) => x`
	<sl-radio-group
		size="medium"
		.label=${options.label ?? ""}
		.helpText=${options.helpText ?? ""}
		value=${typeof options.value !== "undefined" ? String(options.value) : ""}
		.name=${options.id}
		.required?=${options.required}
		@sl-change=${(event) => {
    const newValue = event.target.value;
    options.valueChangedCallback?.(newValue === "true");
  }}
	>
		<sl-radio-button
			value="true"
			.disabled=${options.value === true ? false : options.disabled}
			>${options.trueLabel ?? "Yes"}</sl-radio-button
		>
		<sl-radio-button
			value="false"
			.disabled=${options.value === false ? false : options.disabled}
			>${options.falseLabel ?? "No"}</sl-radio-button
		>
	</sl-radio-group>
`;

  // node_modules/@jsfe/shoelace/dist/esm/widgets/callout.js
  var callout = (options) => {
    console.warn(options.message);
    return x`
		<div
			role="alert"
			class=${`callout--${options.type ?? "warning"} theme-shoelace widget-callout`}
			id=${options.id}
			part="widget-callout"
		>
			<p>${options.message}</p>
		</div>
	`;
  };

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.GGT72J62.js
  var input_styles_default = i3`
  :host {
    display: block;
  }

  .input {
    flex: 1 1 auto;
    display: inline-flex;
    align-items: stretch;
    justify-content: start;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: text;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  /* Standard inputs */
  .input--standard {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .input--standard:hover:not(.input--disabled) {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
  }

  .input--standard.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  .input--standard.input--focused:not(.input--disabled) .input__control {
    color: var(--sl-input-color-focus);
  }

  .input--standard.input--disabled {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input--standard.input--disabled .input__control {
    color: var(--sl-input-color-disabled);
  }

  .input--standard.input--disabled .input__control::placeholder {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Filled inputs */
  .input--filled {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .input--filled:hover:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .input--filled.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .input--filled.input--disabled {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input__control {
    flex: 1 1 auto;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    min-width: 0;
    height: 100%;
    color: var(--sl-input-color);
    border: none;
    background: inherit;
    box-shadow: none;
    padding: 0;
    margin: 0;
    cursor: inherit;
    -webkit-appearance: none;
  }

  .input__control::-webkit-search-decoration,
  .input__control::-webkit-search-cancel-button,
  .input__control::-webkit-search-results-button,
  .input__control::-webkit-search-results-decoration {
    -webkit-appearance: none;
  }

  .input__control:-webkit-autofill,
  .input__control:-webkit-autofill:hover,
  .input__control:-webkit-autofill:focus,
  .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-background-color-hover) inset !important;
    -webkit-text-fill-color: var(--sl-color-primary-500);
    caret-color: var(--sl-input-color);
  }

  .input--filled .input__control:-webkit-autofill,
  .input--filled .input__control:-webkit-autofill:hover,
  .input--filled .input__control:-webkit-autofill:focus,
  .input--filled .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-filled-background-color) inset !important;
  }

  .input__control::placeholder {
    color: var(--sl-input-placeholder-color);
    user-select: none;
    -webkit-user-select: none;
  }

  .input:hover:not(.input--disabled) .input__control {
    color: var(--sl-input-color-hover);
  }

  .input__control:focus {
    outline: none;
  }

  .input__prefix,
  .input__suffix {
    display: inline-flex;
    flex: 0 0 auto;
    align-items: center;
    cursor: default;
  }

  .input__prefix ::slotted(sl-icon),
  .input__suffix ::slotted(sl-icon) {
    color: var(--sl-input-icon-color);
  }

  /*
   * Size modifiers
   */

  .input--small {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    height: var(--sl-input-height-small);
  }

  .input--small .input__control {
    height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-small);
  }

  .input--small .input__clear,
  .input--small .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-small) * 2);
  }

  .input--small .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .input--small .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .input--medium {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    height: var(--sl-input-height-medium);
  }

  .input--medium .input__control {
    height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-medium);
  }

  .input--medium .input__clear,
  .input--medium .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-medium) * 2);
  }

  .input--medium .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .input--medium .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .input--large {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    height: var(--sl-input-height-large);
  }

  .input--large .input__control {
    height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-large);
  }

  .input--large .input__clear,
  .input--large .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-large) * 2);
  }

  .input--large .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .input--large .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  /*
   * Pill modifier
   */

  .input--pill.input--small {
    border-radius: var(--sl-input-height-small);
  }

  .input--pill.input--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .input--pill.input--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Clearable + Password Toggle
   */

  .input__clear,
  .input__password-toggle {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .input__clear:hover,
  .input__password-toggle:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .input__clear:focus,
  .input__password-toggle:focus {
    outline: none;
  }

  /* Don't show the browser's password toggle in Edge */
  ::-ms-reveal {
    display: none;
  }

  /* Hide the built-in number spinner */
  .input--no-spin-buttons input[type='number']::-webkit-outer-spin-button,
  .input--no-spin-buttons input[type='number']::-webkit-inner-spin-button {
    -webkit-appearance: none;
    display: none;
  }

  .input--no-spin-buttons input[type='number'] {
    -moz-appearance: textfield;
  }
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.GI7VDIWX.js
  var defaultValue = (propertyName = "value") => (proto, key) => {
    const ctor = proto.constructor;
    const attributeChangedCallback = ctor.prototype.attributeChangedCallback;
    ctor.prototype.attributeChangedCallback = function(name, old, value2) {
      var _a;
      const options = ctor.getPropertyOptions(propertyName);
      const attributeName = typeof options.attribute === "string" ? options.attribute : propertyName;
      if (name === attributeName) {
        const converter = options.converter || u2;
        const fromAttribute = typeof converter === "function" ? converter : (_a = converter == null ? void 0 : converter.fromAttribute) != null ? _a : u2.fromAttribute;
        const newValue = fromAttribute(value2, options.type);
        if (this[propertyName] !== newValue) {
          this[key] = newValue;
        }
      }
      attributeChangedCallback.call(this, name, old, value2);
    };
  };

  // node_modules/lit-html/directives/live.js
  var l5 = e8(class extends i7 {
    constructor(r9) {
      if (super(r9), r9.type !== t6.PROPERTY && r9.type !== t6.ATTRIBUTE && r9.type !== t6.BOOLEAN_ATTRIBUTE)
        throw Error("The `live` directive is not allowed on child or event bindings");
      if (!f4(r9))
        throw Error("`live` bindings can only contain a single expression");
    }
    render(r9) {
      return r9;
    }
    update(i11, [t7]) {
      if (t7 === T2 || t7 === E2)
        return t7;
      const o14 = i11.element, l6 = i11.name;
      if (i11.type === t6.PROPERTY) {
        if (t7 === o14[l6])
          return T2;
      } else if (i11.type === t6.BOOLEAN_ATTRIBUTE) {
        if (!!t7 === o14.hasAttribute(l6))
          return T2;
      } else if (i11.type === t6.ATTRIBUTE && o14.getAttribute(l6) === t7 + "")
        return T2;
      return m3(i11), t7;
    }
  });

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.VM65NPGC.js
  var SlInput = class extends ShoelaceElement {
    constructor() {
      super(...arguments);
      this.formControlController = new FormControlController(this, {
        assumeInteractionOn: ["sl-blur", "sl-input"]
      });
      this.hasSlotController = new HasSlotController(this, "help-text", "label");
      this.localize = new LocalizeController2(this);
      this.hasFocus = false;
      this.title = "";
      this.__numberInput = Object.assign(document.createElement("input"), { type: "number" });
      this.__dateInput = Object.assign(document.createElement("input"), { type: "date" });
      this.type = "text";
      this.name = "";
      this.value = "";
      this.defaultValue = "";
      this.size = "medium";
      this.filled = false;
      this.pill = false;
      this.label = "";
      this.helpText = "";
      this.clearable = false;
      this.disabled = false;
      this.placeholder = "";
      this.readonly = false;
      this.passwordToggle = false;
      this.passwordVisible = false;
      this.noSpinButtons = false;
      this.form = "";
      this.required = false;
      this.spellcheck = true;
    }
    //
    // NOTE: We use an in-memory input for these getters/setters instead of the one in the template because the properties
    // can be set before the component is rendered.
    //
    /**
     * Gets or sets the current value as a `Date` object. Returns `null` if the value can't be converted. This will use the native `<input type="{{type}}">` implementation and may result in an error.
     */
    get valueAsDate() {
      var _a;
      this.__dateInput.type = this.type;
      this.__dateInput.value = this.value;
      return ((_a = this.input) == null ? void 0 : _a.valueAsDate) || this.__dateInput.valueAsDate;
    }
    set valueAsDate(newValue) {
      this.__dateInput.type = this.type;
      this.__dateInput.valueAsDate = newValue;
      this.value = this.__dateInput.value;
    }
    /** Gets or sets the current value as a number. Returns `NaN` if the value can't be converted. */
    get valueAsNumber() {
      var _a;
      this.__numberInput.value = this.value;
      return ((_a = this.input) == null ? void 0 : _a.valueAsNumber) || this.__numberInput.valueAsNumber;
    }
    set valueAsNumber(newValue) {
      this.__numberInput.valueAsNumber = newValue;
      this.value = this.__numberInput.value;
    }
    /** Gets the validity state object */
    get validity() {
      return this.input.validity;
    }
    /** Gets the validation message */
    get validationMessage() {
      return this.input.validationMessage;
    }
    firstUpdated() {
      this.formControlController.updateValidity();
    }
    handleBlur() {
      this.hasFocus = false;
      this.emit("sl-blur");
    }
    handleChange() {
      this.value = this.input.value;
      this.emit("sl-change");
    }
    handleClearClick(event) {
      event.preventDefault();
      if (this.value !== "") {
        this.value = "";
        this.emit("sl-clear");
        this.emit("sl-input");
        this.emit("sl-change");
      }
      this.input.focus();
    }
    handleFocus() {
      this.hasFocus = true;
      this.emit("sl-focus");
    }
    handleInput() {
      this.value = this.input.value;
      this.formControlController.updateValidity();
      this.emit("sl-input");
    }
    handleInvalid(event) {
      this.formControlController.setValidity(false);
      this.formControlController.emitInvalidEvent(event);
    }
    handleKeyDown(event) {
      const hasModifier = event.metaKey || event.ctrlKey || event.shiftKey || event.altKey;
      if (event.key === "Enter" && !hasModifier) {
        setTimeout(() => {
          if (!event.defaultPrevented && !event.isComposing) {
            this.formControlController.submit();
          }
        });
      }
    }
    handlePasswordToggle() {
      this.passwordVisible = !this.passwordVisible;
    }
    handleDisabledChange() {
      this.formControlController.setValidity(this.disabled);
    }
    handleStepChange() {
      this.input.step = String(this.step);
      this.formControlController.updateValidity();
    }
    async handleValueChange() {
      await this.updateComplete;
      this.formControlController.updateValidity();
    }
    /** Sets focus on the input. */
    focus(options) {
      this.input.focus(options);
    }
    /** Removes focus from the input. */
    blur() {
      this.input.blur();
    }
    /** Selects all the text in the input. */
    select() {
      this.input.select();
    }
    /** Sets the start and end positions of the text selection (0-based). */
    setSelectionRange(selectionStart, selectionEnd, selectionDirection = "none") {
      this.input.setSelectionRange(selectionStart, selectionEnd, selectionDirection);
    }
    /** Replaces a range of text with a new string. */
    setRangeText(replacement, start, end, selectMode = "preserve") {
      const selectionStart = start != null ? start : this.input.selectionStart;
      const selectionEnd = end != null ? end : this.input.selectionEnd;
      this.input.setRangeText(replacement, selectionStart, selectionEnd, selectMode);
      if (this.value !== this.input.value) {
        this.value = this.input.value;
      }
    }
    /** Displays the browser picker for an input element (only works if the browser supports it for the input type). */
    showPicker() {
      if ("showPicker" in HTMLInputElement.prototype) {
        this.input.showPicker();
      }
    }
    /** Increments the value of a numeric input type by the value of the step attribute. */
    stepUp() {
      this.input.stepUp();
      if (this.value !== this.input.value) {
        this.value = this.input.value;
      }
    }
    /** Decrements the value of a numeric input type by the value of the step attribute. */
    stepDown() {
      this.input.stepDown();
      if (this.value !== this.input.value) {
        this.value = this.input.value;
      }
    }
    /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
    checkValidity() {
      return this.input.checkValidity();
    }
    /** Gets the associated form, if one exists. */
    getForm() {
      return this.formControlController.getForm();
    }
    /** Checks for validity and shows the browser's validation message if the control is invalid. */
    reportValidity() {
      return this.input.reportValidity();
    }
    /** Sets a custom validation message. Pass an empty string to restore validity. */
    setCustomValidity(message) {
      this.input.setCustomValidity(message);
      this.formControlController.updateValidity();
    }
    render() {
      const hasLabelSlot = this.hasSlotController.test("label");
      const hasHelpTextSlot = this.hasSlotController.test("help-text");
      const hasLabel = this.label ? true : !!hasLabelSlot;
      const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
      const hasClearIcon = this.clearable && !this.disabled && !this.readonly;
      const isClearIconVisible = hasClearIcon && (typeof this.value === "number" || this.value.length > 0);
      return x`
      <div
        part="form-control"
        class=${e10({
        "form-control": true,
        "form-control--small": this.size === "small",
        "form-control--medium": this.size === "medium",
        "form-control--large": this.size === "large",
        "form-control--has-label": hasLabel,
        "form-control--has-help-text": hasHelpText
      })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${hasLabel ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${e10({
        input: true,
        // Sizes
        "input--small": this.size === "small",
        "input--medium": this.size === "medium",
        "input--large": this.size === "large",
        // States
        "input--pill": this.pill,
        "input--standard": !this.filled,
        "input--filled": this.filled,
        "input--disabled": this.disabled,
        "input--focused": this.hasFocus,
        "input--empty": !this.value,
        "input--no-spin-buttons": this.noSpinButtons
      })}
          >
            <span part="prefix" class="input__prefix">
              <slot name="prefix"></slot>
            </span>

            <input
              part="input"
              id="input"
              class="input__control"
              type=${this.type === "password" && this.passwordVisible ? "text" : this.type}
              title=${this.title}
              name=${o11(this.name)}
              ?disabled=${this.disabled}
              ?readonly=${this.readonly}
              ?required=${this.required}
              placeholder=${o11(this.placeholder)}
              minlength=${o11(this.minlength)}
              maxlength=${o11(this.maxlength)}
              min=${o11(this.min)}
              max=${o11(this.max)}
              step=${o11(this.step)}
              .value=${l5(this.value)}
              autocapitalize=${o11(this.autocapitalize)}
              autocomplete=${o11(this.autocomplete)}
              autocorrect=${o11(this.autocorrect)}
              ?autofocus=${this.autofocus}
              spellcheck=${this.spellcheck}
              pattern=${o11(this.pattern)}
              enterkeyhint=${o11(this.enterkeyhint)}
              inputmode=${o11(this.inputmode)}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @keydown=${this.handleKeyDown}
              @focus=${this.handleFocus}
              @blur=${this.handleBlur}
            />

            ${isClearIconVisible ? x`
                  <button
                    part="clear-button"
                    class="input__clear"
                    type="button"
                    aria-label=${this.localize.term("clearEntry")}
                    @click=${this.handleClearClick}
                    tabindex="-1"
                  >
                    <slot name="clear-icon">
                      <sl-icon name="x-circle-fill" library="system"></sl-icon>
                    </slot>
                  </button>
                ` : ""}
            ${this.passwordToggle && !this.disabled ? x`
                  <button
                    part="password-toggle-button"
                    class="input__password-toggle"
                    type="button"
                    aria-label=${this.localize.term(this.passwordVisible ? "hidePassword" : "showPassword")}
                    @click=${this.handlePasswordToggle}
                    tabindex="-1"
                  >
                    ${this.passwordVisible ? x`
                          <slot name="show-password-icon">
                            <sl-icon name="eye-slash" library="system"></sl-icon>
                          </slot>
                        ` : x`
                          <slot name="hide-password-icon">
                            <sl-icon name="eye" library="system"></sl-icon>
                          </slot>
                        `}
                  </button>
                ` : ""}

            <span part="suffix" class="input__suffix">
              <slot name="suffix"></slot>
            </span>
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
    }
  };
  SlInput.styles = [component_styles_default, form_control_styles_default, input_styles_default];
  SlInput.dependencies = { "sl-icon": SlIcon };
  __decorateClass2([
    e6(".input__control")
  ], SlInput.prototype, "input", 2);
  __decorateClass2([
    r6()
  ], SlInput.prototype, "hasFocus", 2);
  __decorateClass2([
    n5()
  ], SlInput.prototype, "title", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlInput.prototype, "type", 2);
  __decorateClass2([
    n5()
  ], SlInput.prototype, "name", 2);
  __decorateClass2([
    n5()
  ], SlInput.prototype, "value", 2);
  __decorateClass2([
    defaultValue()
  ], SlInput.prototype, "defaultValue", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlInput.prototype, "size", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlInput.prototype, "filled", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlInput.prototype, "pill", 2);
  __decorateClass2([
    n5()
  ], SlInput.prototype, "label", 2);
  __decorateClass2([
    n5({ attribute: "help-text" })
  ], SlInput.prototype, "helpText", 2);
  __decorateClass2([
    n5({ type: Boolean })
  ], SlInput.prototype, "clearable", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlInput.prototype, "disabled", 2);
  __decorateClass2([
    n5()
  ], SlInput.prototype, "placeholder", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlInput.prototype, "readonly", 2);
  __decorateClass2([
    n5({ attribute: "password-toggle", type: Boolean })
  ], SlInput.prototype, "passwordToggle", 2);
  __decorateClass2([
    n5({ attribute: "password-visible", type: Boolean })
  ], SlInput.prototype, "passwordVisible", 2);
  __decorateClass2([
    n5({ attribute: "no-spin-buttons", type: Boolean })
  ], SlInput.prototype, "noSpinButtons", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlInput.prototype, "form", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlInput.prototype, "required", 2);
  __decorateClass2([
    n5()
  ], SlInput.prototype, "pattern", 2);
  __decorateClass2([
    n5({ type: Number })
  ], SlInput.prototype, "minlength", 2);
  __decorateClass2([
    n5({ type: Number })
  ], SlInput.prototype, "maxlength", 2);
  __decorateClass2([
    n5()
  ], SlInput.prototype, "min", 2);
  __decorateClass2([
    n5()
  ], SlInput.prototype, "max", 2);
  __decorateClass2([
    n5()
  ], SlInput.prototype, "step", 2);
  __decorateClass2([
    n5()
  ], SlInput.prototype, "autocapitalize", 2);
  __decorateClass2([
    n5()
  ], SlInput.prototype, "autocorrect", 2);
  __decorateClass2([
    n5()
  ], SlInput.prototype, "autocomplete", 2);
  __decorateClass2([
    n5({ type: Boolean })
  ], SlInput.prototype, "autofocus", 2);
  __decorateClass2([
    n5()
  ], SlInput.prototype, "enterkeyhint", 2);
  __decorateClass2([
    n5({
      type: Boolean,
      converter: {
        // Allow "true|false" attribute values but keep the property boolean
        fromAttribute: (value2) => !value2 || value2 === "false" ? false : true,
        toAttribute: (value2) => value2 ? "true" : "false"
      }
    })
  ], SlInput.prototype, "spellcheck", 2);
  __decorateClass2([
    n5()
  ], SlInput.prototype, "inputmode", 2);
  __decorateClass2([
    watch("disabled", { waitUntilFirstUpdate: true })
  ], SlInput.prototype, "handleDisabledChange", 1);
  __decorateClass2([
    watch("step", { waitUntilFirstUpdate: true })
  ], SlInput.prototype, "handleStepChange", 1);
  __decorateClass2([
    watch("value", { waitUntilFirstUpdate: true })
  ], SlInput.prototype, "handleValueChange", 1);

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.XA43ZQPC.js
  SlInput.define("sl-input");

  // node_modules/@jsfe/shoelace/dist/esm/widgets/checkbox.js
  var checkbox = (options) => x`
	<div class="theme-shoelace widget-checkbox">
		<sl-checkbox
			type="text"
			.checked="${options.value}"
			.name=${options.id}
			.id=${options.id}
			.required=${options.required ?? true}
			@sl-input=${(event) => {
    const { checked: newValue } = event.target;
    options.valueChangedCallback?.(newValue);
  }}
			.disabled=${options.disabled}
		>
			<label class="widget-checkbox__label">${options.label}</label>
		</sl-checkbox>

		${options.helpText ? x`<div class="widget-checkbox__description">
					${options.helpText}
			  </div>` : E2}
	</div>
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.R3NF57O3.js
  var checkbox_styles_default = i3`
  :host {
    display: inline-block;
  }

  .checkbox {
    position: relative;
    display: inline-flex;
    align-items: flex-start;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .checkbox--small {
    --toggle-size: var(--sl-toggle-size-small);
    font-size: var(--sl-input-font-size-small);
  }

  .checkbox--medium {
    --toggle-size: var(--sl-toggle-size-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .checkbox--large {
    --toggle-size: var(--sl-toggle-size-large);
    font-size: var(--sl-input-font-size-large);
  }

  .checkbox__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--toggle-size);
    height: var(--toggle-size);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
    border-radius: 2px;
    background-color: var(--sl-input-background-color);
    color: var(--sl-color-neutral-0);
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
  }

  .checkbox__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  .checkbox__checked-icon,
  .checkbox__indeterminate-icon {
    display: inline-flex;
    width: var(--toggle-size);
    height: var(--toggle-size);
  }

  /* Hover */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-input-border-color-hover);
    background-color: var(--sl-input-background-color-hover);
  }

  /* Focus */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Checked/indeterminate */
  .checkbox--checked .checkbox__control,
  .checkbox--indeterminate .checkbox__control {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
  }

  /* Checked/indeterminate + hover */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__control:hover,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
  }

  /* Checked/indeterminate + focus */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .checkbox--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .checkbox__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    line-height: var(--toggle-size);
    margin-inline-start: 0.5em;
    user-select: none;
    -webkit-user-select: none;
  }

  :host([required]) .checkbox__label::after {
    content: var(--sl-input-required-content);
    color: var(--sl-input-required-content-color);
    margin-inline-start: var(--sl-input-required-content-offset);
  }
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.XSFJLY2D.js
  var SlCheckbox = class extends ShoelaceElement {
    constructor() {
      super(...arguments);
      this.formControlController = new FormControlController(this, {
        value: (control) => control.checked ? control.value || "on" : void 0,
        defaultValue: (control) => control.defaultChecked,
        setValue: (control, checked) => control.checked = checked
      });
      this.hasSlotController = new HasSlotController(this, "help-text");
      this.hasFocus = false;
      this.title = "";
      this.name = "";
      this.size = "medium";
      this.disabled = false;
      this.checked = false;
      this.indeterminate = false;
      this.defaultChecked = false;
      this.form = "";
      this.required = false;
      this.helpText = "";
    }
    /** Gets the validity state object */
    get validity() {
      return this.input.validity;
    }
    /** Gets the validation message */
    get validationMessage() {
      return this.input.validationMessage;
    }
    firstUpdated() {
      this.formControlController.updateValidity();
    }
    handleClick() {
      this.checked = !this.checked;
      this.indeterminate = false;
      this.emit("sl-change");
    }
    handleBlur() {
      this.hasFocus = false;
      this.emit("sl-blur");
    }
    handleInput() {
      this.emit("sl-input");
    }
    handleInvalid(event) {
      this.formControlController.setValidity(false);
      this.formControlController.emitInvalidEvent(event);
    }
    handleFocus() {
      this.hasFocus = true;
      this.emit("sl-focus");
    }
    handleDisabledChange() {
      this.formControlController.setValidity(this.disabled);
    }
    handleStateChange() {
      this.input.checked = this.checked;
      this.input.indeterminate = this.indeterminate;
      this.formControlController.updateValidity();
    }
    /** Simulates a click on the checkbox. */
    click() {
      this.input.click();
    }
    /** Sets focus on the checkbox. */
    focus(options) {
      this.input.focus(options);
    }
    /** Removes focus from the checkbox. */
    blur() {
      this.input.blur();
    }
    /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
    checkValidity() {
      return this.input.checkValidity();
    }
    /** Gets the associated form, if one exists. */
    getForm() {
      return this.formControlController.getForm();
    }
    /** Checks for validity and shows the browser's validation message if the control is invalid. */
    reportValidity() {
      return this.input.reportValidity();
    }
    /**
     * Sets a custom validation message. The value provided will be shown to the user when the form is submitted. To clear
     * the custom validation message, call this method with an empty string.
     */
    setCustomValidity(message) {
      this.input.setCustomValidity(message);
      this.formControlController.updateValidity();
    }
    render() {
      const hasHelpTextSlot = this.hasSlotController.test("help-text");
      const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
      return x`
      <div
        class=${e10({
        "form-control": true,
        "form-control--small": this.size === "small",
        "form-control--medium": this.size === "medium",
        "form-control--large": this.size === "large",
        "form-control--has-help-text": hasHelpText
      })}
      >
        <label
          part="base"
          class=${e10({
        checkbox: true,
        "checkbox--checked": this.checked,
        "checkbox--disabled": this.disabled,
        "checkbox--focused": this.hasFocus,
        "checkbox--indeterminate": this.indeterminate,
        "checkbox--small": this.size === "small",
        "checkbox--medium": this.size === "medium",
        "checkbox--large": this.size === "large"
      })}
        >
          <input
            class="checkbox__input"
            type="checkbox"
            title=${this.title}
            name=${this.name}
            value=${o11(this.value)}
            .indeterminate=${l5(this.indeterminate)}
            .checked=${l5(this.checked)}
            .disabled=${this.disabled}
            .required=${this.required}
            aria-checked=${this.checked ? "true" : "false"}
            aria-describedby="help-text"
            @click=${this.handleClick}
            @input=${this.handleInput}
            @invalid=${this.handleInvalid}
            @blur=${this.handleBlur}
            @focus=${this.handleFocus}
          />

          <span
            part="control${this.checked ? " control--checked" : ""}${this.indeterminate ? " control--indeterminate" : ""}"
            class="checkbox__control"
          >
            ${this.checked ? x`
                  <sl-icon part="checked-icon" class="checkbox__checked-icon" library="system" name="check"></sl-icon>
                ` : ""}
            ${!this.checked && this.indeterminate ? x`
                  <sl-icon
                    part="indeterminate-icon"
                    class="checkbox__indeterminate-icon"
                    library="system"
                    name="indeterminate"
                  ></sl-icon>
                ` : ""}
          </span>

          <div part="label" class="checkbox__label">
            <slot></slot>
          </div>
        </label>

        <div
          aria-hidden=${hasHelpText ? "false" : "true"}
          class="form-control__help-text"
          id="help-text"
          part="form-control-help-text"
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
    }
  };
  SlCheckbox.styles = [component_styles_default, form_control_styles_default, checkbox_styles_default];
  SlCheckbox.dependencies = { "sl-icon": SlIcon };
  __decorateClass2([
    e6('input[type="checkbox"]')
  ], SlCheckbox.prototype, "input", 2);
  __decorateClass2([
    r6()
  ], SlCheckbox.prototype, "hasFocus", 2);
  __decorateClass2([
    n5()
  ], SlCheckbox.prototype, "title", 2);
  __decorateClass2([
    n5()
  ], SlCheckbox.prototype, "name", 2);
  __decorateClass2([
    n5()
  ], SlCheckbox.prototype, "value", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlCheckbox.prototype, "size", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlCheckbox.prototype, "disabled", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlCheckbox.prototype, "checked", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlCheckbox.prototype, "indeterminate", 2);
  __decorateClass2([
    defaultValue("checked")
  ], SlCheckbox.prototype, "defaultChecked", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlCheckbox.prototype, "form", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlCheckbox.prototype, "required", 2);
  __decorateClass2([
    n5({ attribute: "help-text" })
  ], SlCheckbox.prototype, "helpText", 2);
  __decorateClass2([
    watch("disabled", { waitUntilFirstUpdate: true })
  ], SlCheckbox.prototype, "handleDisabledChange", 1);
  __decorateClass2([
    watch(["checked", "indeterminate"], { waitUntilFirstUpdate: true })
  ], SlCheckbox.prototype, "handleStateChange", 1);

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.D5YQDJ7X.js
  SlCheckbox.define("sl-checkbox");

  // node_modules/@jsfe/shoelace/dist/esm/widgets/checkbox-group.js
  var checkboxGroup = (options) => x`
	<fieldset
		.id=${options.id}
		class="theme-shoelace widget-checkbox-group widget-fieldset level-${options.level}"
		part="widget-checkbox-group"
	>
		<legend>${options.label}</legend>
		${options.helpText ? x`<div class="help-text">${options.helpText}</div>` : E2}

		<!-- NOTE: Unused for now. Too noisy? -->
		<!-- <div class="help-text">${options.itemsLabel}</div> -->

		<div class="widget-checkbox-group__list">
			${options?.enum?.map((enumValue) => {
    return x`<sl-checkbox
					.checked=${options.value?.some((v3) => v3 === enumValue) ?? false}
					@sl-change=${(event) => {
      const { checked } = event.target;
      const newData = [];
      options?.enum?.forEach((eVal) => {
        if (eVal === enumValue && checked) {
          newData.push(eVal);
        }
      });
      options.value?.forEach((dVal) => {
        if (dVal !== enumValue) {
          newData.push(dVal);
        }
      });
      options.valueChangedCallback?.(newData);
    }}
					.disabled=${options.disabled}
					>${enumValue}</sl-checkbox
				>`;
  })}
		</div>
	</fieldset>
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.YKKSQ2FG.js
  var visually_hidden_styles_default = i3`
  :host(:not(:focus-within)) {
    position: absolute !important;
    width: 1px !important;
    height: 1px !important;
    clip: rect(0 0 0 0) !important;
    clip-path: inset(50%) !important;
    border: none !important;
    overflow: hidden !important;
    white-space: nowrap !important;
    padding: 0 !important;
  }
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.J33OE77I.js
  var SlVisuallyHidden = class extends ShoelaceElement {
    render() {
      return x` <slot></slot> `;
    }
  };
  SlVisuallyHidden.styles = [component_styles_default, visually_hidden_styles_default];

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.ESELY2US.js
  function drag(container, options) {
    function move(pointerEvent) {
      const dims = container.getBoundingClientRect();
      const defaultView = container.ownerDocument.defaultView;
      const offsetX = dims.left + defaultView.scrollX;
      const offsetY = dims.top + defaultView.scrollY;
      const x2 = pointerEvent.pageX - offsetX;
      const y4 = pointerEvent.pageY - offsetY;
      if (options == null ? void 0 : options.onMove) {
        options.onMove(x2, y4);
      }
    }
    function stop() {
      document.removeEventListener("pointermove", move);
      document.removeEventListener("pointerup", stop);
      if (options == null ? void 0 : options.onStop) {
        options.onStop();
      }
    }
    document.addEventListener("pointermove", move, { passive: true });
    document.addEventListener("pointerup", stop);
    if ((options == null ? void 0 : options.initialEvent) instanceof PointerEvent) {
      move(options.initialEvent);
    }
  }

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.LXP7GVU3.js
  var dropdown_styles_default = i3`
  :host {
    display: inline-block;
  }

  .dropdown::part(popup) {
    z-index: var(--sl-z-index-dropdown);
  }

  .dropdown[data-current-placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .dropdown[data-current-placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  .dropdown[data-current-placement^='left']::part(popup) {
    transform-origin: right;
  }

  .dropdown[data-current-placement^='right']::part(popup) {
    transform-origin: left;
  }

  .dropdown__trigger {
    display: block;
  }

  .dropdown__panel {
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    box-shadow: var(--sl-shadow-large);
    border-radius: var(--sl-border-radius-medium);
    pointer-events: none;
  }

  .dropdown--open .dropdown__panel {
    display: block;
    pointer-events: all;
  }

  /* When users slot a menu, make sure it conforms to the popup's auto-size */
  ::slotted(sl-menu) {
    max-width: var(--auto-size-available-width) !important;
    max-height: var(--auto-size-available-height) !important;
  }
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.VESXC477.js
  function* activeElements(activeElement = document.activeElement) {
    if (activeElement === null || activeElement === void 0)
      return;
    yield activeElement;
    if ("shadowRoot" in activeElement && activeElement.shadowRoot && activeElement.shadowRoot.mode !== "closed") {
      yield* __yieldStar(activeElements(activeElement.shadowRoot.activeElement));
    }
  }
  function getDeepestActiveElement() {
    return [...activeElements()].pop();
  }
  var computedStyleMap = /* @__PURE__ */ new WeakMap();
  function getCachedComputedStyle(el) {
    let computedStyle = computedStyleMap.get(el);
    if (!computedStyle) {
      computedStyle = window.getComputedStyle(el, null);
      computedStyleMap.set(el, computedStyle);
    }
    return computedStyle;
  }
  function isVisible(el) {
    if (typeof el.checkVisibility === "function") {
      return el.checkVisibility({ checkOpacity: false, checkVisibilityCSS: true });
    }
    const computedStyle = getCachedComputedStyle(el);
    return computedStyle.visibility !== "hidden" && computedStyle.display !== "none";
  }
  function isOverflowingAndTabbable(el) {
    const computedStyle = getCachedComputedStyle(el);
    const { overflowY, overflowX } = computedStyle;
    if (overflowY === "scroll" || overflowX === "scroll") {
      return true;
    }
    if (overflowY !== "auto" || overflowX !== "auto") {
      return false;
    }
    const isOverflowingY = el.scrollHeight > el.clientHeight;
    if (isOverflowingY && overflowY === "auto") {
      return true;
    }
    const isOverflowingX = el.scrollWidth > el.clientWidth;
    if (isOverflowingX && overflowX === "auto") {
      return true;
    }
    return false;
  }
  function isTabbable(el) {
    const tag = el.tagName.toLowerCase();
    const tabindex = Number(el.getAttribute("tabindex"));
    const hasTabindex = el.hasAttribute("tabindex");
    if (hasTabindex && (isNaN(tabindex) || tabindex <= -1)) {
      return false;
    }
    if (el.hasAttribute("disabled")) {
      return false;
    }
    if (el.closest("[inert]")) {
      return false;
    }
    if (tag === "input" && el.getAttribute("type") === "radio") {
      const rootNode = el.getRootNode();
      const findRadios = `input[type='radio'][name="${el.getAttribute("name")}"]`;
      const firstChecked = rootNode.querySelector(`${findRadios}:checked`);
      if (firstChecked) {
        return firstChecked === el;
      }
      const firstRadio = rootNode.querySelector(findRadios);
      return firstRadio === el;
    }
    if (!isVisible(el)) {
      return false;
    }
    if ((tag === "audio" || tag === "video") && el.hasAttribute("controls")) {
      return true;
    }
    if (el.hasAttribute("tabindex")) {
      return true;
    }
    if (el.hasAttribute("contenteditable") && el.getAttribute("contenteditable") !== "false") {
      return true;
    }
    const isNativelyTabbable = [
      "button",
      "input",
      "select",
      "textarea",
      "a",
      "audio",
      "video",
      "summary",
      "iframe"
    ].includes(tag);
    if (isNativelyTabbable) {
      return true;
    }
    return isOverflowingAndTabbable(el);
  }
  function getTabbableBoundary(root2) {
    var _a, _b;
    const tabbableElements = getTabbableElements(root2);
    const start = (_a = tabbableElements[0]) != null ? _a : null;
    const end = (_b = tabbableElements[tabbableElements.length - 1]) != null ? _b : null;
    return { start, end };
  }
  function getSlottedChildrenOutsideRootElement(slotElement, root2) {
    var _a;
    return ((_a = slotElement.getRootNode({ composed: true })) == null ? void 0 : _a.host) !== root2;
  }
  function getTabbableElements(root2) {
    const walkedEls = /* @__PURE__ */ new WeakMap();
    const tabbableElements = [];
    function walk(el) {
      if (el instanceof Element) {
        if (el.hasAttribute("inert") || el.closest("[inert]")) {
          return;
        }
        if (walkedEls.has(el)) {
          return;
        }
        walkedEls.set(el, true);
        if (!tabbableElements.includes(el) && isTabbable(el)) {
          tabbableElements.push(el);
        }
        if (el instanceof HTMLSlotElement && getSlottedChildrenOutsideRootElement(el, root2)) {
          el.assignedElements({ flatten: true }).forEach((assignedEl) => {
            walk(assignedEl);
          });
        }
        if (el.shadowRoot !== null && el.shadowRoot.mode === "open") {
          walk(el.shadowRoot);
        }
      }
      for (const e13 of el.children) {
        walk(e13);
      }
    }
    walk(root2);
    return tabbableElements.sort((a5, b4) => {
      const aTabindex = Number(a5.getAttribute("tabindex")) || 0;
      const bTabindex = Number(b4.getAttribute("tabindex")) || 0;
      return bTabindex - aTabindex;
    });
  }

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3KSWVBQ5.js
  var popup_styles_default = i3`
  :host {
    --arrow-color: var(--sl-color-neutral-1000);
    --arrow-size: 6px;

    /*
     * These properties are computed to account for the arrow's dimensions after being rotated 45. The constant
     * 0.7071 is derived from sin(45), which is the diagonal size of the arrow's container after rotating.
     */
    --arrow-size-diagonal: calc(var(--arrow-size) * 0.7071);
    --arrow-padding-offset: calc(var(--arrow-size-diagonal) - var(--arrow-size));

    display: contents;
  }

  .popup {
    position: absolute;
    isolation: isolate;
    max-width: var(--auto-size-available-width, none);
    max-height: var(--auto-size-available-height, none);
  }

  .popup--fixed {
    position: fixed;
  }

  .popup:not(.popup--active) {
    display: none;
  }

  .popup__arrow {
    position: absolute;
    width: calc(var(--arrow-size-diagonal) * 2);
    height: calc(var(--arrow-size-diagonal) * 2);
    rotate: 45deg;
    background: var(--arrow-color);
    z-index: -1;
  }

  /* Hover bridge */
  .popup-hover-bridge:not(.popup-hover-bridge--visible) {
    display: none;
  }

  .popup-hover-bridge {
    position: fixed;
    z-index: calc(var(--sl-z-index-dropdown) - 1);
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    clip-path: polygon(
      var(--hover-bridge-top-left-x, 0) var(--hover-bridge-top-left-y, 0),
      var(--hover-bridge-top-right-x, 0) var(--hover-bridge-top-right-y, 0),
      var(--hover-bridge-bottom-right-x, 0) var(--hover-bridge-bottom-right-y, 0),
      var(--hover-bridge-bottom-left-x, 0) var(--hover-bridge-bottom-left-y, 0)
    );
  }
`;

  // node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
  var min = Math.min;
  var max = Math.max;
  var round = Math.round;
  var floor = Math.floor;
  var createCoords = (v3) => ({
    x: v3,
    y: v3
  });
  var oppositeSideMap = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  var oppositeAlignmentMap = {
    start: "end",
    end: "start"
  };
  function clamp(start, value2, end) {
    return max(start, min(value2, end));
  }
  function evaluate(value2, param) {
    return typeof value2 === "function" ? value2(param) : value2;
  }
  function getSide(placement) {
    return placement.split("-")[0];
  }
  function getAlignment(placement) {
    return placement.split("-")[1];
  }
  function getOppositeAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  function getAxisLength(axis) {
    return axis === "y" ? "height" : "width";
  }
  var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
  function getSideAxis(placement) {
    return yAxisSides.has(getSide(placement)) ? "y" : "x";
  }
  function getAlignmentAxis(placement) {
    return getOppositeAxis(getSideAxis(placement));
  }
  function getAlignmentSides(placement, rects, rtl) {
    if (rtl === void 0) {
      rtl = false;
    }
    const alignment = getAlignment(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const length = getAxisLength(alignmentAxis);
    let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
    if (rects.reference[length] > rects.floating[length]) {
      mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
    }
    return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
  }
  function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
  }
  function getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
  }
  var lrPlacement = ["left", "right"];
  var rlPlacement = ["right", "left"];
  var tbPlacement = ["top", "bottom"];
  var btPlacement = ["bottom", "top"];
  function getSideList(side, isStart, rtl) {
    switch (side) {
      case "top":
      case "bottom":
        if (rtl)
          return isStart ? rlPlacement : lrPlacement;
        return isStart ? lrPlacement : rlPlacement;
      case "left":
      case "right":
        return isStart ? tbPlacement : btPlacement;
      default:
        return [];
    }
  }
  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
    const alignment = getAlignment(placement);
    let list = getSideList(getSide(placement), direction === "start", rtl);
    if (alignment) {
      list = list.map((side) => side + "-" + alignment);
      if (flipAlignment) {
        list = list.concat(list.map(getOppositeAlignmentPlacement));
      }
    }
    return list;
  }
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
  }
  function expandPaddingObject(padding) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...padding
    };
  }
  function getPaddingObject(padding) {
    return typeof padding !== "number" ? expandPaddingObject(padding) : {
      top: padding,
      right: padding,
      bottom: padding,
      left: padding
    };
  }
  function rectToClientRect(rect) {
    const {
      x: x2,
      y: y4,
      width,
      height
    } = rect;
    return {
      width,
      height,
      top: y4,
      left: x2,
      right: x2 + width,
      bottom: y4 + height,
      x: x2,
      y: y4
    };
  }

  // node_modules/@floating-ui/core/dist/floating-ui.core.mjs
  function computeCoordsFromPlacement(_ref, placement, rtl) {
    let {
      reference,
      floating
    } = _ref;
    const sideAxis = getSideAxis(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const alignLength = getAxisLength(alignmentAxis);
    const side = getSide(placement);
    const isVertical = sideAxis === "y";
    const commonX = reference.x + reference.width / 2 - floating.width / 2;
    const commonY = reference.y + reference.height / 2 - floating.height / 2;
    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
    let coords;
    switch (side) {
      case "top":
        coords = {
          x: commonX,
          y: reference.y - floating.height
        };
        break;
      case "bottom":
        coords = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;
      case "right":
        coords = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;
      case "left":
        coords = {
          x: reference.x - floating.width,
          y: commonY
        };
        break;
      default:
        coords = {
          x: reference.x,
          y: reference.y
        };
    }
    switch (getAlignment(placement)) {
      case "start":
        coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
        break;
      case "end":
        coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
        break;
    }
    return coords;
  }
  var computePosition = async (reference, floating, config) => {
    const {
      placement = "bottom",
      strategy = "absolute",
      middleware = [],
      platform: platform2
    } = config;
    const validMiddleware = middleware.filter(Boolean);
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
    let rects = await platform2.getElementRects({
      reference,
      floating,
      strategy
    });
    let {
      x: x2,
      y: y4
    } = computeCoordsFromPlacement(rects, placement, rtl);
    let statefulPlacement = placement;
    let middlewareData = {};
    let resetCount = 0;
    for (let i11 = 0; i11 < validMiddleware.length; i11++) {
      const {
        name,
        fn
      } = validMiddleware[i11];
      const {
        x: nextX,
        y: nextY,
        data,
        reset
      } = await fn({
        x: x2,
        y: y4,
        initialPlacement: placement,
        placement: statefulPlacement,
        strategy,
        middlewareData,
        rects,
        platform: platform2,
        elements: {
          reference,
          floating
        }
      });
      x2 = nextX != null ? nextX : x2;
      y4 = nextY != null ? nextY : y4;
      middlewareData = {
        ...middlewareData,
        [name]: {
          ...middlewareData[name],
          ...data
        }
      };
      if (reset && resetCount <= 50) {
        resetCount++;
        if (typeof reset === "object") {
          if (reset.placement) {
            statefulPlacement = reset.placement;
          }
          if (reset.rects) {
            rects = reset.rects === true ? await platform2.getElementRects({
              reference,
              floating,
              strategy
            }) : reset.rects;
          }
          ({
            x: x2,
            y: y4
          } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
        }
        i11 = -1;
      }
    }
    return {
      x: x2,
      y: y4,
      placement: statefulPlacement,
      strategy,
      middlewareData
    };
  };
  async function detectOverflow(state, options) {
    var _await$platform$isEle;
    if (options === void 0) {
      options = {};
    }
    const {
      x: x2,
      y: y4,
      platform: platform2,
      rects,
      elements,
      strategy
    } = state;
    const {
      boundary = "clippingAncestors",
      rootBoundary = "viewport",
      elementContext = "floating",
      altBoundary = false,
      padding = 0
    } = evaluate(options, state);
    const paddingObject = getPaddingObject(padding);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
      element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
      boundary,
      rootBoundary,
      strategy
    }));
    const rect = elementContext === "floating" ? {
      x: x2,
      y: y4,
      width: rects.floating.width,
      height: rects.floating.height
    } : rects.reference;
    const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
    const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    };
    const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements,
      rect,
      offsetParent,
      strategy
    }) : rect);
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  }
  var arrow = (options) => ({
    name: "arrow",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y4,
        placement,
        rects,
        platform: platform2,
        elements,
        middlewareData
      } = state;
      const {
        element,
        padding = 0
      } = evaluate(options, state) || {};
      if (element == null) {
        return {};
      }
      const paddingObject = getPaddingObject(padding);
      const coords = {
        x: x2,
        y: y4
      };
      const axis = getAlignmentAxis(placement);
      const length = getAxisLength(axis);
      const arrowDimensions = await platform2.getDimensions(element);
      const isYAxis = axis === "y";
      const minProp = isYAxis ? "top" : "left";
      const maxProp = isYAxis ? "bottom" : "right";
      const clientProp = isYAxis ? "clientHeight" : "clientWidth";
      const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
      const startDiff = coords[axis] - rects.reference[axis];
      const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
      let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
      if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
        clientSize = elements.floating[clientProp] || rects.floating[length];
      }
      const centerToReference = endDiff / 2 - startDiff / 2;
      const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
      const minPadding = min(paddingObject[minProp], largestPossiblePadding);
      const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
      const min$1 = minPadding;
      const max2 = clientSize - arrowDimensions[length] - maxPadding;
      const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
      const offset3 = clamp(min$1, center, max2);
      const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset3 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
      const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
      return {
        [axis]: coords[axis] + alignmentOffset,
        data: {
          [axis]: offset3,
          centerOffset: center - offset3 - alignmentOffset,
          ...shouldAddOffset && {
            alignmentOffset
          }
        },
        reset: shouldAddOffset
      };
    }
  });
  var flip = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "flip",
      options,
      async fn(state) {
        var _middlewareData$arrow, _middlewareData$flip;
        const {
          placement,
          middlewareData,
          rects,
          initialPlacement,
          platform: platform2,
          elements
        } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true,
          fallbackPlacements: specifiedFallbackPlacements,
          fallbackStrategy = "bestFit",
          fallbackAxisSideDirection = "none",
          flipAlignment = true,
          ...detectOverflowOptions
        } = evaluate(options, state);
        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        const side = getSide(placement);
        const initialSideAxis = getSideAxis(initialPlacement);
        const isBasePlacement = getSide(initialPlacement) === initialPlacement;
        const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
        const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
        if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
        }
        const placements2 = [initialPlacement, ...fallbackPlacements];
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const overflows = [];
        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
        if (checkMainAxis) {
          overflows.push(overflow[side]);
        }
        if (checkCrossAxis) {
          const sides2 = getAlignmentSides(placement, rects, rtl);
          overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
        }
        overflowsData = [...overflowsData, {
          placement,
          overflows
        }];
        if (!overflows.every((side2) => side2 <= 0)) {
          var _middlewareData$flip2, _overflowsData$filter;
          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
          const nextPlacement = placements2[nextIndex];
          if (nextPlacement) {
            const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
            if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
            // overflows the main axis.
            overflowsData.every((d4) => getSideAxis(d4.placement) === initialSideAxis ? d4.overflows[0] > 0 : true)) {
              return {
                data: {
                  index: nextIndex,
                  overflows: overflowsData
                },
                reset: {
                  placement: nextPlacement
                }
              };
            }
          }
          let resetPlacement = (_overflowsData$filter = overflowsData.filter((d4) => d4.overflows[0] <= 0).sort((a5, b4) => a5.overflows[1] - b4.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
          if (!resetPlacement) {
            switch (fallbackStrategy) {
              case "bestFit": {
                var _overflowsData$filter2;
                const placement2 = (_overflowsData$filter2 = overflowsData.filter((d4) => {
                  if (hasFallbackAxisSideDirection) {
                    const currentSideAxis = getSideAxis(d4.placement);
                    return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    currentSideAxis === "y";
                  }
                  return true;
                }).map((d4) => [d4.placement, d4.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a5, b4) => a5[1] - b4[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                if (placement2) {
                  resetPlacement = placement2;
                }
                break;
              }
              case "initialPlacement":
                resetPlacement = initialPlacement;
                break;
            }
          }
          if (placement !== resetPlacement) {
            return {
              reset: {
                placement: resetPlacement
              }
            };
          }
        }
        return {};
      }
    };
  };
  var originSides = /* @__PURE__ */ new Set(["left", "top"]);
  async function convertValueToCoords(state, options) {
    const {
      placement,
      platform: platform2,
      elements
    } = state;
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
    const side = getSide(placement);
    const alignment = getAlignment(placement);
    const isVertical = getSideAxis(placement) === "y";
    const mainAxisMulti = originSides.has(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = evaluate(options, state);
    let {
      mainAxis,
      crossAxis,
      alignmentAxis
    } = typeof rawValue === "number" ? {
      mainAxis: rawValue,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: rawValue.mainAxis || 0,
      crossAxis: rawValue.crossAxis || 0,
      alignmentAxis: rawValue.alignmentAxis
    };
    if (alignment && typeof alignmentAxis === "number") {
      crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? {
      x: crossAxis * crossAxisMulti,
      y: mainAxis * mainAxisMulti
    } : {
      x: mainAxis * mainAxisMulti,
      y: crossAxis * crossAxisMulti
    };
  }
  var offset = function(options) {
    if (options === void 0) {
      options = 0;
    }
    return {
      name: "offset",
      options,
      async fn(state) {
        var _middlewareData$offse, _middlewareData$arrow;
        const {
          x: x2,
          y: y4,
          placement,
          middlewareData
        } = state;
        const diffCoords = await convertValueToCoords(state, options);
        if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        return {
          x: x2 + diffCoords.x,
          y: y4 + diffCoords.y,
          data: {
            ...diffCoords,
            placement
          }
        };
      }
    };
  };
  var shift = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "shift",
      options,
      async fn(state) {
        const {
          x: x2,
          y: y4,
          placement
        } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = false,
          limiter = {
            fn: (_ref) => {
              let {
                x: x3,
                y: y5
              } = _ref;
              return {
                x: x3,
                y: y5
              };
            }
          },
          ...detectOverflowOptions
        } = evaluate(options, state);
        const coords = {
          x: x2,
          y: y4
        };
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const crossAxis = getSideAxis(getSide(placement));
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        if (checkMainAxis) {
          const minSide = mainAxis === "y" ? "top" : "left";
          const maxSide = mainAxis === "y" ? "bottom" : "right";
          const min2 = mainAxisCoord + overflow[minSide];
          const max2 = mainAxisCoord - overflow[maxSide];
          mainAxisCoord = clamp(min2, mainAxisCoord, max2);
        }
        if (checkCrossAxis) {
          const minSide = crossAxis === "y" ? "top" : "left";
          const maxSide = crossAxis === "y" ? "bottom" : "right";
          const min2 = crossAxisCoord + overflow[minSide];
          const max2 = crossAxisCoord - overflow[maxSide];
          crossAxisCoord = clamp(min2, crossAxisCoord, max2);
        }
        const limitedCoords = limiter.fn({
          ...state,
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        });
        return {
          ...limitedCoords,
          data: {
            x: limitedCoords.x - x2,
            y: limitedCoords.y - y4,
            enabled: {
              [mainAxis]: checkMainAxis,
              [crossAxis]: checkCrossAxis
            }
          }
        };
      }
    };
  };
  var size = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "size",
      options,
      async fn(state) {
        var _state$middlewareData, _state$middlewareData2;
        const {
          placement,
          rects,
          platform: platform2,
          elements
        } = state;
        const {
          apply = () => {
          },
          ...detectOverflowOptions
        } = evaluate(options, state);
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const side = getSide(placement);
        const alignment = getAlignment(placement);
        const isYAxis = getSideAxis(placement) === "y";
        const {
          width,
          height
        } = rects.floating;
        let heightSide;
        let widthSide;
        if (side === "top" || side === "bottom") {
          heightSide = side;
          widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
        } else {
          widthSide = side;
          heightSide = alignment === "end" ? "top" : "bottom";
        }
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        const maximumClippingWidth = width - overflow.left - overflow.right;
        const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
        const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
        const noShift = !state.middlewareData.shift;
        let availableHeight = overflowAvailableHeight;
        let availableWidth = overflowAvailableWidth;
        if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
          availableWidth = maximumClippingWidth;
        }
        if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
          availableHeight = maximumClippingHeight;
        }
        if (noShift && !alignment) {
          const xMin = max(overflow.left, 0);
          const xMax = max(overflow.right, 0);
          const yMin = max(overflow.top, 0);
          const yMax = max(overflow.bottom, 0);
          if (isYAxis) {
            availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
          } else {
            availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
          }
        }
        await apply({
          ...state,
          availableWidth,
          availableHeight
        });
        const nextDimensions = await platform2.getDimensions(elements.floating);
        if (width !== nextDimensions.width || height !== nextDimensions.height) {
          return {
            reset: {
              rects: true
            }
          };
        }
        return {};
      }
    };
  };

  // node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
  function hasWindow() {
    return typeof window !== "undefined";
  }
  function getNodeName(node) {
    if (isNode(node)) {
      return (node.nodeName || "").toLowerCase();
    }
    return "#document";
  }
  function getWindow(node) {
    var _node$ownerDocument;
    return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
  }
  function getDocumentElement(node) {
    var _ref;
    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
  }
  function isNode(value2) {
    if (!hasWindow()) {
      return false;
    }
    return value2 instanceof Node || value2 instanceof getWindow(value2).Node;
  }
  function isElement(value2) {
    if (!hasWindow()) {
      return false;
    }
    return value2 instanceof Element || value2 instanceof getWindow(value2).Element;
  }
  function isHTMLElement(value2) {
    if (!hasWindow()) {
      return false;
    }
    return value2 instanceof HTMLElement || value2 instanceof getWindow(value2).HTMLElement;
  }
  function isShadowRoot(value2) {
    if (!hasWindow() || typeof ShadowRoot === "undefined") {
      return false;
    }
    return value2 instanceof ShadowRoot || value2 instanceof getWindow(value2).ShadowRoot;
  }
  var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
  function isOverflowElement(element) {
    const {
      overflow,
      overflowX,
      overflowY,
      display
    } = getComputedStyle2(element);
    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
  }
  var tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
  function isTableElement(element) {
    return tableElements.has(getNodeName(element));
  }
  var topLayerSelectors = [":popover-open", ":modal"];
  function isTopLayer(element) {
    return topLayerSelectors.some((selector) => {
      try {
        return element.matches(selector);
      } catch (_e2) {
        return false;
      }
    });
  }
  var transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
  var willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
  var containValues = ["paint", "layout", "strict", "content"];
  function isContainingBlock(elementOrCss) {
    const webkit = isWebKit();
    const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
    return transformProperties.some((value2) => css[value2] ? css[value2] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value2) => (css.willChange || "").includes(value2)) || containValues.some((value2) => (css.contain || "").includes(value2));
  }
  function getContainingBlock(element) {
    let currentNode = getParentNode(element);
    while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
      if (isContainingBlock(currentNode)) {
        return currentNode;
      } else if (isTopLayer(currentNode)) {
        return null;
      }
      currentNode = getParentNode(currentNode);
    }
    return null;
  }
  function isWebKit() {
    if (typeof CSS === "undefined" || !CSS.supports)
      return false;
    return CSS.supports("-webkit-backdrop-filter", "none");
  }
  var lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
  function isLastTraversableNode(node) {
    return lastTraversableNodeNames.has(getNodeName(node));
  }
  function getComputedStyle2(element) {
    return getWindow(element).getComputedStyle(element);
  }
  function getNodeScroll(element) {
    if (isElement(element)) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    return {
      scrollLeft: element.scrollX,
      scrollTop: element.scrollY
    };
  }
  function getParentNode(node) {
    if (getNodeName(node) === "html") {
      return node;
    }
    const result = (
      // Step into the shadow DOM of the parent of a slotted node.
      node.assignedSlot || // DOM Element detected.
      node.parentNode || // ShadowRoot detected.
      isShadowRoot(node) && node.host || // Fallback.
      getDocumentElement(node)
    );
    return isShadowRoot(result) ? result.host : result;
  }
  function getNearestOverflowAncestor(node) {
    const parentNode = getParentNode(node);
    if (isLastTraversableNode(parentNode)) {
      return node.ownerDocument ? node.ownerDocument.body : node.body;
    }
    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
      return parentNode;
    }
    return getNearestOverflowAncestor(parentNode);
  }
  function getOverflowAncestors(node, list, traverseIframes) {
    var _node$ownerDocument2;
    if (list === void 0) {
      list = [];
    }
    if (traverseIframes === void 0) {
      traverseIframes = true;
    }
    const scrollableAncestor = getNearestOverflowAncestor(node);
    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
    const win = getWindow(scrollableAncestor);
    if (isBody) {
      const frameElement = getFrameElement(win);
      return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
    }
    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
  }
  function getFrameElement(win) {
    return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
  }

  // node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
  function getCssDimensions(element) {
    const css = getComputedStyle2(element);
    let width = parseFloat(css.width) || 0;
    let height = parseFloat(css.height) || 0;
    const hasOffset = isHTMLElement(element);
    const offsetWidth = hasOffset ? element.offsetWidth : width;
    const offsetHeight = hasOffset ? element.offsetHeight : height;
    const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
    if (shouldFallback) {
      width = offsetWidth;
      height = offsetHeight;
    }
    return {
      width,
      height,
      $: shouldFallback
    };
  }
  function unwrapElement(element) {
    return !isElement(element) ? element.contextElement : element;
  }
  function getScale(element) {
    const domElement = unwrapElement(element);
    if (!isHTMLElement(domElement)) {
      return createCoords(1);
    }
    const rect = domElement.getBoundingClientRect();
    const {
      width,
      height,
      $: $4
    } = getCssDimensions(domElement);
    let x2 = ($4 ? round(rect.width) : rect.width) / width;
    let y4 = ($4 ? round(rect.height) : rect.height) / height;
    if (!x2 || !Number.isFinite(x2)) {
      x2 = 1;
    }
    if (!y4 || !Number.isFinite(y4)) {
      y4 = 1;
    }
    return {
      x: x2,
      y: y4
    };
  }
  var noOffsets = /* @__PURE__ */ createCoords(0);
  function getVisualOffsets(element) {
    const win = getWindow(element);
    if (!isWebKit() || !win.visualViewport) {
      return noOffsets;
    }
    return {
      x: win.visualViewport.offsetLeft,
      y: win.visualViewport.offsetTop
    };
  }
  function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
      return false;
    }
    return isFixed;
  }
  function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    const clientRect = element.getBoundingClientRect();
    const domElement = unwrapElement(element);
    let scale = createCoords(1);
    if (includeScale) {
      if (offsetParent) {
        if (isElement(offsetParent)) {
          scale = getScale(offsetParent);
        }
      } else {
        scale = getScale(element);
      }
    }
    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
    let x2 = (clientRect.left + visualOffsets.x) / scale.x;
    let y4 = (clientRect.top + visualOffsets.y) / scale.y;
    let width = clientRect.width / scale.x;
    let height = clientRect.height / scale.y;
    if (domElement) {
      const win = getWindow(domElement);
      const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
      let currentWin = win;
      let currentIFrame = getFrameElement(currentWin);
      while (currentIFrame && offsetParent && offsetWin !== currentWin) {
        const iframeScale = getScale(currentIFrame);
        const iframeRect = currentIFrame.getBoundingClientRect();
        const css = getComputedStyle2(currentIFrame);
        const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
        const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
        x2 *= iframeScale.x;
        y4 *= iframeScale.y;
        width *= iframeScale.x;
        height *= iframeScale.y;
        x2 += left;
        y4 += top;
        currentWin = getWindow(currentIFrame);
        currentIFrame = getFrameElement(currentWin);
      }
    }
    return rectToClientRect({
      width,
      height,
      x: x2,
      y: y4
    });
  }
  function getWindowScrollBarX(element, rect) {
    const leftScroll = getNodeScroll(element).scrollLeft;
    if (!rect) {
      return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
    }
    return rect.left + leftScroll;
  }
  function getHTMLOffset(documentElement, scroll) {
    const htmlRect = documentElement.getBoundingClientRect();
    const x2 = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
    const y4 = htmlRect.top + scroll.scrollTop;
    return {
      x: x2,
      y: y4
    };
  }
  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
    let {
      elements,
      rect,
      offsetParent,
      strategy
    } = _ref;
    const isFixed = strategy === "fixed";
    const documentElement = getDocumentElement(offsetParent);
    const topLayer = elements ? isTopLayer(elements.floating) : false;
    if (offsetParent === documentElement || topLayer && isFixed) {
      return rect;
    }
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    let scale = createCoords(1);
    const offsets = createCoords(0);
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        const offsetRect = getBoundingClientRect(offsetParent);
        scale = getScale(offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      }
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
    return {
      width: rect.width * scale.x,
      height: rect.height * scale.y,
      x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
      y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
    };
  }
  function getClientRects(element) {
    return Array.from(element.getClientRects());
  }
  function getDocumentRect(element) {
    const html = getDocumentElement(element);
    const scroll = getNodeScroll(element);
    const body = element.ownerDocument.body;
    const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
    const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
    let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
    const y4 = -scroll.scrollTop;
    if (getComputedStyle2(body).direction === "rtl") {
      x2 += max(html.clientWidth, body.clientWidth) - width;
    }
    return {
      width,
      height,
      x: x2,
      y: y4
    };
  }
  var SCROLLBAR_MAX = 25;
  function getViewportRect(element, strategy) {
    const win = getWindow(element);
    const html = getDocumentElement(element);
    const visualViewport = win.visualViewport;
    let width = html.clientWidth;
    let height = html.clientHeight;
    let x2 = 0;
    let y4 = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      const visualViewportBased = isWebKit();
      if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
        x2 = visualViewport.offsetLeft;
        y4 = visualViewport.offsetTop;
      }
    }
    const windowScrollbarX = getWindowScrollBarX(html);
    if (windowScrollbarX <= 0) {
      const doc = html.ownerDocument;
      const body = doc.body;
      const bodyStyles = getComputedStyle(body);
      const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
      const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
      if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
        width -= clippingStableScrollbarWidth;
      }
    } else if (windowScrollbarX <= SCROLLBAR_MAX) {
      width += windowScrollbarX;
    }
    return {
      width,
      height,
      x: x2,
      y: y4
    };
  }
  var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
  function getInnerBoundingClientRect(element, strategy) {
    const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
    const top = clientRect.top + element.clientTop;
    const left = clientRect.left + element.clientLeft;
    const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
    const width = element.clientWidth * scale.x;
    const height = element.clientHeight * scale.y;
    const x2 = left * scale.x;
    const y4 = top * scale.y;
    return {
      width,
      height,
      x: x2,
      y: y4
    };
  }
  function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
    let rect;
    if (clippingAncestor === "viewport") {
      rect = getViewportRect(element, strategy);
    } else if (clippingAncestor === "document") {
      rect = getDocumentRect(getDocumentElement(element));
    } else if (isElement(clippingAncestor)) {
      rect = getInnerBoundingClientRect(clippingAncestor, strategy);
    } else {
      const visualOffsets = getVisualOffsets(element);
      rect = {
        x: clippingAncestor.x - visualOffsets.x,
        y: clippingAncestor.y - visualOffsets.y,
        width: clippingAncestor.width,
        height: clippingAncestor.height
      };
    }
    return rectToClientRect(rect);
  }
  function hasFixedPositionAncestor(element, stopNode) {
    const parentNode = getParentNode(element);
    if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
      return false;
    }
    return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
  }
  function getClippingElementAncestors(element, cache) {
    const cachedResult = cache.get(element);
    if (cachedResult) {
      return cachedResult;
    }
    let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = getComputedStyle2(element).position === "fixed";
    let currentNode = elementIsFixed ? getParentNode(element) : element;
    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
      const computedStyle = getComputedStyle2(currentNode);
      const currentNodeIsContaining = isContainingBlock(currentNode);
      if (!currentNodeIsContaining && computedStyle.position === "fixed") {
        currentContainingBlockComputedStyle = null;
      }
      const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
      if (shouldDropCurrentNode) {
        result = result.filter((ancestor) => ancestor !== currentNode);
      } else {
        currentContainingBlockComputedStyle = computedStyle;
      }
      currentNode = getParentNode(currentNode);
    }
    cache.set(element, result);
    return result;
  }
  function getClippingRect(_ref) {
    let {
      element,
      boundary,
      rootBoundary,
      strategy
    } = _ref;
    const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
    const clippingAncestors = [...elementClippingAncestors, rootBoundary];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
      const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
    return {
      width: clippingRect.right - clippingRect.left,
      height: clippingRect.bottom - clippingRect.top,
      x: clippingRect.left,
      y: clippingRect.top
    };
  }
  function getDimensions(element) {
    const {
      width,
      height
    } = getCssDimensions(element);
    return {
      width,
      height
    };
  }
  function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    const documentElement = getDocumentElement(offsetParent);
    const isFixed = strategy === "fixed";
    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const offsets = createCoords(0);
    function setLeftRTLScrollbarOffset() {
      offsets.x = getWindowScrollBarX(documentElement);
    }
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isOffsetParentAnElement) {
        const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      } else if (documentElement) {
        setLeftRTLScrollbarOffset();
      }
    }
    if (isFixed && !isOffsetParentAnElement && documentElement) {
      setLeftRTLScrollbarOffset();
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
    const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
    const y4 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
    return {
      x: x2,
      y: y4,
      width: rect.width,
      height: rect.height
    };
  }
  function isStaticPositioned(element) {
    return getComputedStyle2(element).position === "static";
  }
  function getTrueOffsetParent(element, polyfill) {
    if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
      return null;
    }
    if (polyfill) {
      return polyfill(element);
    }
    let rawOffsetParent = element.offsetParent;
    if (getDocumentElement(element) === rawOffsetParent) {
      rawOffsetParent = rawOffsetParent.ownerDocument.body;
    }
    return rawOffsetParent;
  }
  function getOffsetParent(element, polyfill) {
    const win = getWindow(element);
    if (isTopLayer(element)) {
      return win;
    }
    if (!isHTMLElement(element)) {
      let svgOffsetParent = getParentNode(element);
      while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
        if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
          return svgOffsetParent;
        }
        svgOffsetParent = getParentNode(svgOffsetParent);
      }
      return win;
    }
    let offsetParent = getTrueOffsetParent(element, polyfill);
    while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
      offsetParent = getTrueOffsetParent(offsetParent, polyfill);
    }
    if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
      return win;
    }
    return offsetParent || getContainingBlock(element) || win;
  }
  var getElementRects = async function(data) {
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    const floatingDimensions = await getDimensionsFn(data.floating);
    return {
      reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
      floating: {
        x: 0,
        y: 0,
        width: floatingDimensions.width,
        height: floatingDimensions.height
      }
    };
  };
  function isRTL(element) {
    return getComputedStyle2(element).direction === "rtl";
  }
  var platform = {
    convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement,
    getClippingRect,
    getOffsetParent,
    getElementRects,
    getClientRects,
    getDimensions,
    getScale,
    isElement,
    isRTL
  };
  function rectsAreEqual(a5, b4) {
    return a5.x === b4.x && a5.y === b4.y && a5.width === b4.width && a5.height === b4.height;
  }
  function observeMove(element, onMove) {
    let io = null;
    let timeoutId;
    const root2 = getDocumentElement(element);
    function cleanup() {
      var _io;
      clearTimeout(timeoutId);
      (_io = io) == null || _io.disconnect();
      io = null;
    }
    function refresh(skip, threshold) {
      if (skip === void 0) {
        skip = false;
      }
      if (threshold === void 0) {
        threshold = 1;
      }
      cleanup();
      const elementRectForRootMargin = element.getBoundingClientRect();
      const {
        left,
        top,
        width,
        height
      } = elementRectForRootMargin;
      if (!skip) {
        onMove();
      }
      if (!width || !height) {
        return;
      }
      const insetTop = floor(top);
      const insetRight = floor(root2.clientWidth - (left + width));
      const insetBottom = floor(root2.clientHeight - (top + height));
      const insetLeft = floor(left);
      const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
      const options = {
        rootMargin,
        threshold: max(0, min(1, threshold)) || 1
      };
      let isFirstUpdate = true;
      function handleObserve(entries) {
        const ratio = entries[0].intersectionRatio;
        if (ratio !== threshold) {
          if (!isFirstUpdate) {
            return refresh();
          }
          if (!ratio) {
            timeoutId = setTimeout(() => {
              refresh(false, 1e-7);
            }, 1e3);
          } else {
            refresh(false, ratio);
          }
        }
        if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
          refresh();
        }
        isFirstUpdate = false;
      }
      try {
        io = new IntersectionObserver(handleObserve, {
          ...options,
          // Handle <iframe>s
          root: root2.ownerDocument
        });
      } catch (_e2) {
        io = new IntersectionObserver(handleObserve, options);
      }
      io.observe(element);
    }
    refresh(true);
    return cleanup;
  }
  function autoUpdate(reference, floating, update2, options) {
    if (options === void 0) {
      options = {};
    }
    const {
      ancestorScroll = true,
      ancestorResize = true,
      elementResize = typeof ResizeObserver === "function",
      layoutShift = typeof IntersectionObserver === "function",
      animationFrame = false
    } = options;
    const referenceEl = unwrapElement(reference);
    const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.addEventListener("scroll", update2, {
        passive: true
      });
      ancestorResize && ancestor.addEventListener("resize", update2);
    });
    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
    let reobserveFrame = -1;
    let resizeObserver = null;
    if (elementResize) {
      resizeObserver = new ResizeObserver((_ref) => {
        let [firstEntry] = _ref;
        if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
          resizeObserver.unobserve(floating);
          cancelAnimationFrame(reobserveFrame);
          reobserveFrame = requestAnimationFrame(() => {
            var _resizeObserver;
            (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
          });
        }
        update2();
      });
      if (referenceEl && !animationFrame) {
        resizeObserver.observe(referenceEl);
      }
      resizeObserver.observe(floating);
    }
    let frameId;
    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
    if (animationFrame) {
      frameLoop();
    }
    function frameLoop() {
      const nextRefRect = getBoundingClientRect(reference);
      if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
        update2();
      }
      prevRefRect = nextRefRect;
      frameId = requestAnimationFrame(frameLoop);
    }
    update2();
    return () => {
      var _resizeObserver2;
      ancestors.forEach((ancestor) => {
        ancestorScroll && ancestor.removeEventListener("scroll", update2);
        ancestorResize && ancestor.removeEventListener("resize", update2);
      });
      cleanupIo == null || cleanupIo();
      (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
      resizeObserver = null;
      if (animationFrame) {
        cancelAnimationFrame(frameId);
      }
    };
  }
  var offset2 = offset;
  var shift2 = shift;
  var flip2 = flip;
  var size2 = size;
  var arrow2 = arrow;
  var computePosition2 = (reference, floating, options) => {
    const cache = /* @__PURE__ */ new Map();
    const mergedOptions = {
      platform,
      ...options
    };
    const platformWithCache = {
      ...mergedOptions.platform,
      _c: cache
    };
    return computePosition(reference, floating, {
      ...mergedOptions,
      platform: platformWithCache
    });
  };

  // node_modules/composed-offset-position/dist/composed-offset-position.browser.min.mjs
  function e11(t7) {
    return i9(t7);
  }
  function r8(t7) {
    return t7.assignedSlot ? t7.assignedSlot : t7.parentNode instanceof ShadowRoot ? t7.parentNode.host : t7.parentNode;
  }
  function i9(e13) {
    for (let t7 = e13; t7; t7 = r8(t7))
      if (t7 instanceof Element && "none" === getComputedStyle(t7).display)
        return null;
    for (let n10 = r8(e13); n10; n10 = r8(n10)) {
      if (!(n10 instanceof Element))
        continue;
      const e14 = getComputedStyle(n10);
      if ("contents" !== e14.display) {
        if ("static" !== e14.position || isContainingBlock(e14))
          return n10;
        if ("BODY" === n10.tagName)
          return n10;
      }
    }
    return null;
  }

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.5JY5FUCG.js
  function isVirtualElement(e13) {
    return e13 !== null && typeof e13 === "object" && "getBoundingClientRect" in e13 && ("contextElement" in e13 ? e13.contextElement instanceof Element : true);
  }
  var SlPopup = class extends ShoelaceElement {
    constructor() {
      super(...arguments);
      this.localize = new LocalizeController2(this);
      this.active = false;
      this.placement = "top";
      this.strategy = "absolute";
      this.distance = 0;
      this.skidding = 0;
      this.arrow = false;
      this.arrowPlacement = "anchor";
      this.arrowPadding = 10;
      this.flip = false;
      this.flipFallbackPlacements = "";
      this.flipFallbackStrategy = "best-fit";
      this.flipPadding = 0;
      this.shift = false;
      this.shiftPadding = 0;
      this.autoSizePadding = 0;
      this.hoverBridge = false;
      this.updateHoverBridge = () => {
        if (this.hoverBridge && this.anchorEl) {
          const anchorRect = this.anchorEl.getBoundingClientRect();
          const popupRect = this.popup.getBoundingClientRect();
          const isVertical = this.placement.includes("top") || this.placement.includes("bottom");
          let topLeftX = 0;
          let topLeftY = 0;
          let topRightX = 0;
          let topRightY = 0;
          let bottomLeftX = 0;
          let bottomLeftY = 0;
          let bottomRightX = 0;
          let bottomRightY = 0;
          if (isVertical) {
            if (anchorRect.top < popupRect.top) {
              topLeftX = anchorRect.left;
              topLeftY = anchorRect.bottom;
              topRightX = anchorRect.right;
              topRightY = anchorRect.bottom;
              bottomLeftX = popupRect.left;
              bottomLeftY = popupRect.top;
              bottomRightX = popupRect.right;
              bottomRightY = popupRect.top;
            } else {
              topLeftX = popupRect.left;
              topLeftY = popupRect.bottom;
              topRightX = popupRect.right;
              topRightY = popupRect.bottom;
              bottomLeftX = anchorRect.left;
              bottomLeftY = anchorRect.top;
              bottomRightX = anchorRect.right;
              bottomRightY = anchorRect.top;
            }
          } else {
            if (anchorRect.left < popupRect.left) {
              topLeftX = anchorRect.right;
              topLeftY = anchorRect.top;
              topRightX = popupRect.left;
              topRightY = popupRect.top;
              bottomLeftX = anchorRect.right;
              bottomLeftY = anchorRect.bottom;
              bottomRightX = popupRect.left;
              bottomRightY = popupRect.bottom;
            } else {
              topLeftX = popupRect.right;
              topLeftY = popupRect.top;
              topRightX = anchorRect.left;
              topRightY = anchorRect.top;
              bottomLeftX = popupRect.right;
              bottomLeftY = popupRect.bottom;
              bottomRightX = anchorRect.left;
              bottomRightY = anchorRect.bottom;
            }
          }
          this.style.setProperty("--hover-bridge-top-left-x", `${topLeftX}px`);
          this.style.setProperty("--hover-bridge-top-left-y", `${topLeftY}px`);
          this.style.setProperty("--hover-bridge-top-right-x", `${topRightX}px`);
          this.style.setProperty("--hover-bridge-top-right-y", `${topRightY}px`);
          this.style.setProperty("--hover-bridge-bottom-left-x", `${bottomLeftX}px`);
          this.style.setProperty("--hover-bridge-bottom-left-y", `${bottomLeftY}px`);
          this.style.setProperty("--hover-bridge-bottom-right-x", `${bottomRightX}px`);
          this.style.setProperty("--hover-bridge-bottom-right-y", `${bottomRightY}px`);
        }
      };
    }
    async connectedCallback() {
      super.connectedCallback();
      await this.updateComplete;
      this.start();
    }
    disconnectedCallback() {
      super.disconnectedCallback();
      this.stop();
    }
    async updated(changedProps) {
      super.updated(changedProps);
      if (changedProps.has("active")) {
        if (this.active) {
          this.start();
        } else {
          this.stop();
        }
      }
      if (changedProps.has("anchor")) {
        this.handleAnchorChange();
      }
      if (this.active) {
        await this.updateComplete;
        this.reposition();
      }
    }
    async handleAnchorChange() {
      await this.stop();
      if (this.anchor && typeof this.anchor === "string") {
        const root2 = this.getRootNode();
        this.anchorEl = root2.getElementById(this.anchor);
      } else if (this.anchor instanceof Element || isVirtualElement(this.anchor)) {
        this.anchorEl = this.anchor;
      } else {
        this.anchorEl = this.querySelector('[slot="anchor"]');
      }
      if (this.anchorEl instanceof HTMLSlotElement) {
        this.anchorEl = this.anchorEl.assignedElements({ flatten: true })[0];
      }
      if (this.anchorEl && this.active) {
        this.start();
      }
    }
    start() {
      if (!this.anchorEl || !this.active) {
        return;
      }
      this.cleanup = autoUpdate(this.anchorEl, this.popup, () => {
        this.reposition();
      });
    }
    async stop() {
      return new Promise((resolve) => {
        if (this.cleanup) {
          this.cleanup();
          this.cleanup = void 0;
          this.removeAttribute("data-current-placement");
          this.style.removeProperty("--auto-size-available-width");
          this.style.removeProperty("--auto-size-available-height");
          requestAnimationFrame(() => resolve());
        } else {
          resolve();
        }
      });
    }
    /** Forces the popup to recalculate and reposition itself. */
    reposition() {
      if (!this.active || !this.anchorEl) {
        return;
      }
      const middleware = [
        // The offset middleware goes first
        offset2({ mainAxis: this.distance, crossAxis: this.skidding })
      ];
      if (this.sync) {
        middleware.push(
          size2({
            apply: ({ rects }) => {
              const syncWidth = this.sync === "width" || this.sync === "both";
              const syncHeight = this.sync === "height" || this.sync === "both";
              this.popup.style.width = syncWidth ? `${rects.reference.width}px` : "";
              this.popup.style.height = syncHeight ? `${rects.reference.height}px` : "";
            }
          })
        );
      } else {
        this.popup.style.width = "";
        this.popup.style.height = "";
      }
      if (this.flip) {
        middleware.push(
          flip2({
            boundary: this.flipBoundary,
            // @ts-expect-error - We're converting a string attribute to an array here
            fallbackPlacements: this.flipFallbackPlacements,
            fallbackStrategy: this.flipFallbackStrategy === "best-fit" ? "bestFit" : "initialPlacement",
            padding: this.flipPadding
          })
        );
      }
      if (this.shift) {
        middleware.push(
          shift2({
            boundary: this.shiftBoundary,
            padding: this.shiftPadding
          })
        );
      }
      if (this.autoSize) {
        middleware.push(
          size2({
            boundary: this.autoSizeBoundary,
            padding: this.autoSizePadding,
            apply: ({ availableWidth, availableHeight }) => {
              if (this.autoSize === "vertical" || this.autoSize === "both") {
                this.style.setProperty("--auto-size-available-height", `${availableHeight}px`);
              } else {
                this.style.removeProperty("--auto-size-available-height");
              }
              if (this.autoSize === "horizontal" || this.autoSize === "both") {
                this.style.setProperty("--auto-size-available-width", `${availableWidth}px`);
              } else {
                this.style.removeProperty("--auto-size-available-width");
              }
            }
          })
        );
      } else {
        this.style.removeProperty("--auto-size-available-width");
        this.style.removeProperty("--auto-size-available-height");
      }
      if (this.arrow) {
        middleware.push(
          arrow2({
            element: this.arrowEl,
            padding: this.arrowPadding
          })
        );
      }
      const getOffsetParent2 = this.strategy === "absolute" ? (element) => platform.getOffsetParent(element, e11) : platform.getOffsetParent;
      computePosition2(this.anchorEl, this.popup, {
        placement: this.placement,
        middleware,
        strategy: this.strategy,
        platform: __spreadProps(__spreadValues({}, platform), {
          getOffsetParent: getOffsetParent2
        })
      }).then(({ x: x2, y: y4, middlewareData, placement }) => {
        const isRtl = this.localize.dir() === "rtl";
        const staticSide = { top: "bottom", right: "left", bottom: "top", left: "right" }[placement.split("-")[0]];
        this.setAttribute("data-current-placement", placement);
        Object.assign(this.popup.style, {
          left: `${x2}px`,
          top: `${y4}px`
        });
        if (this.arrow) {
          const arrowX = middlewareData.arrow.x;
          const arrowY = middlewareData.arrow.y;
          let top = "";
          let right = "";
          let bottom = "";
          let left = "";
          if (this.arrowPlacement === "start") {
            const value2 = typeof arrowX === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
            top = typeof arrowY === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
            right = isRtl ? value2 : "";
            left = isRtl ? "" : value2;
          } else if (this.arrowPlacement === "end") {
            const value2 = typeof arrowX === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
            right = isRtl ? "" : value2;
            left = isRtl ? value2 : "";
            bottom = typeof arrowY === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          } else if (this.arrowPlacement === "center") {
            left = typeof arrowX === "number" ? `calc(50% - var(--arrow-size-diagonal))` : "";
            top = typeof arrowY === "number" ? `calc(50% - var(--arrow-size-diagonal))` : "";
          } else {
            left = typeof arrowX === "number" ? `${arrowX}px` : "";
            top = typeof arrowY === "number" ? `${arrowY}px` : "";
          }
          Object.assign(this.arrowEl.style, {
            top,
            right,
            bottom,
            left,
            [staticSide]: "calc(var(--arrow-size-diagonal) * -1)"
          });
        }
      });
      requestAnimationFrame(() => this.updateHoverBridge());
      this.emit("sl-reposition");
    }
    render() {
      return x`
      <slot name="anchor" @slotchange=${this.handleAnchorChange}></slot>

      <span
        part="hover-bridge"
        class=${e10({
        "popup-hover-bridge": true,
        "popup-hover-bridge--visible": this.hoverBridge && this.active
      })}
      ></span>

      <div
        part="popup"
        class=${e10({
        popup: true,
        "popup--active": this.active,
        "popup--fixed": this.strategy === "fixed",
        "popup--has-arrow": this.arrow
      })}
      >
        <slot></slot>
        ${this.arrow ? x`<div part="arrow" class="popup__arrow" role="presentation"></div>` : ""}
      </div>
    `;
    }
  };
  SlPopup.styles = [component_styles_default, popup_styles_default];
  __decorateClass2([
    e6(".popup")
  ], SlPopup.prototype, "popup", 2);
  __decorateClass2([
    e6(".popup__arrow")
  ], SlPopup.prototype, "arrowEl", 2);
  __decorateClass2([
    n5()
  ], SlPopup.prototype, "anchor", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlPopup.prototype, "active", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlPopup.prototype, "placement", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlPopup.prototype, "strategy", 2);
  __decorateClass2([
    n5({ type: Number })
  ], SlPopup.prototype, "distance", 2);
  __decorateClass2([
    n5({ type: Number })
  ], SlPopup.prototype, "skidding", 2);
  __decorateClass2([
    n5({ type: Boolean })
  ], SlPopup.prototype, "arrow", 2);
  __decorateClass2([
    n5({ attribute: "arrow-placement" })
  ], SlPopup.prototype, "arrowPlacement", 2);
  __decorateClass2([
    n5({ attribute: "arrow-padding", type: Number })
  ], SlPopup.prototype, "arrowPadding", 2);
  __decorateClass2([
    n5({ type: Boolean })
  ], SlPopup.prototype, "flip", 2);
  __decorateClass2([
    n5({
      attribute: "flip-fallback-placements",
      converter: {
        fromAttribute: (value2) => {
          return value2.split(" ").map((p4) => p4.trim()).filter((p4) => p4 !== "");
        },
        toAttribute: (value2) => {
          return value2.join(" ");
        }
      }
    })
  ], SlPopup.prototype, "flipFallbackPlacements", 2);
  __decorateClass2([
    n5({ attribute: "flip-fallback-strategy" })
  ], SlPopup.prototype, "flipFallbackStrategy", 2);
  __decorateClass2([
    n5({ type: Object })
  ], SlPopup.prototype, "flipBoundary", 2);
  __decorateClass2([
    n5({ attribute: "flip-padding", type: Number })
  ], SlPopup.prototype, "flipPadding", 2);
  __decorateClass2([
    n5({ type: Boolean })
  ], SlPopup.prototype, "shift", 2);
  __decorateClass2([
    n5({ type: Object })
  ], SlPopup.prototype, "shiftBoundary", 2);
  __decorateClass2([
    n5({ attribute: "shift-padding", type: Number })
  ], SlPopup.prototype, "shiftPadding", 2);
  __decorateClass2([
    n5({ attribute: "auto-size" })
  ], SlPopup.prototype, "autoSize", 2);
  __decorateClass2([
    n5()
  ], SlPopup.prototype, "sync", 2);
  __decorateClass2([
    n5({ type: Object })
  ], SlPopup.prototype, "autoSizeBoundary", 2);
  __decorateClass2([
    n5({ attribute: "auto-size-padding", type: Number })
  ], SlPopup.prototype, "autoSizePadding", 2);
  __decorateClass2([
    n5({ attribute: "hover-bridge", type: Boolean })
  ], SlPopup.prototype, "hoverBridge", 2);

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.K7JGTRV7.js
  var defaultAnimationRegistry = /* @__PURE__ */ new Map();
  var customAnimationRegistry = /* @__PURE__ */ new WeakMap();
  function ensureAnimation(animation) {
    return animation != null ? animation : { keyframes: [], options: { duration: 0 } };
  }
  function getLogicalAnimation(animation, dir) {
    if (dir.toLowerCase() === "rtl") {
      return {
        keyframes: animation.rtlKeyframes || animation.keyframes,
        options: animation.options
      };
    }
    return animation;
  }
  function setDefaultAnimation(animationName, animation) {
    defaultAnimationRegistry.set(animationName, ensureAnimation(animation));
  }
  function getAnimation(el, animationName, options) {
    const customAnimation = customAnimationRegistry.get(el);
    if (customAnimation == null ? void 0 : customAnimation[animationName]) {
      return getLogicalAnimation(customAnimation[animationName], options.dir);
    }
    const defaultAnimation = defaultAnimationRegistry.get(animationName);
    if (defaultAnimation) {
      return getLogicalAnimation(defaultAnimation, options.dir);
    }
    return {
      keyframes: [],
      options: { duration: 0 }
    };
  }

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.B4BZKR24.js
  function waitForEvent(el, eventName) {
    return new Promise((resolve) => {
      function done(event) {
        if (event.target === el) {
          el.removeEventListener(eventName, done);
          resolve();
        }
      }
      el.addEventListener(eventName, done);
    });
  }

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.AJ3ENQ5C.js
  function animateTo(el, keyframes, options) {
    return new Promise((resolve) => {
      if ((options == null ? void 0 : options.duration) === Infinity) {
        throw new Error("Promise-based animations must be finite.");
      }
      const animation = el.animate(keyframes, __spreadProps(__spreadValues({}, options), {
        duration: prefersReducedMotion() ? 0 : options.duration
      }));
      animation.addEventListener("cancel", resolve, { once: true });
      animation.addEventListener("finish", resolve, { once: true });
    });
  }
  function prefersReducedMotion() {
    const query = window.matchMedia("(prefers-reduced-motion: reduce)");
    return query.matches;
  }
  function stopAnimations(el) {
    return Promise.all(
      el.getAnimations().map((animation) => {
        return new Promise((resolve) => {
          animation.cancel();
          requestAnimationFrame(resolve);
        });
      })
    );
  }

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.C56A5M6T.js
  var SlDropdown = class extends ShoelaceElement {
    constructor() {
      super(...arguments);
      this.localize = new LocalizeController2(this);
      this.open = false;
      this.placement = "bottom-start";
      this.disabled = false;
      this.stayOpenOnSelect = false;
      this.distance = 0;
      this.skidding = 0;
      this.hoist = false;
      this.sync = void 0;
      this.handleKeyDown = (event) => {
        if (this.open && event.key === "Escape") {
          event.stopPropagation();
          this.hide();
          this.focusOnTrigger();
        }
      };
      this.handleDocumentKeyDown = (event) => {
        var _a;
        if (event.key === "Escape" && this.open && !this.closeWatcher) {
          event.stopPropagation();
          this.focusOnTrigger();
          this.hide();
          return;
        }
        if (event.key === "Tab") {
          if (this.open && ((_a = document.activeElement) == null ? void 0 : _a.tagName.toLowerCase()) === "sl-menu-item") {
            event.preventDefault();
            this.hide();
            this.focusOnTrigger();
            return;
          }
          const computeClosestContaining = (element, tagName) => {
            if (!element)
              return null;
            const closest = element.closest(tagName);
            if (closest)
              return closest;
            const rootNode = element.getRootNode();
            if (rootNode instanceof ShadowRoot) {
              return computeClosestContaining(rootNode.host, tagName);
            }
            return null;
          };
          setTimeout(() => {
            var _a2;
            const activeElement = ((_a2 = this.containingElement) == null ? void 0 : _a2.getRootNode()) instanceof ShadowRoot ? getDeepestActiveElement() : document.activeElement;
            if (!this.containingElement || computeClosestContaining(activeElement, this.containingElement.tagName.toLowerCase()) !== this.containingElement) {
              this.hide();
            }
          });
        }
      };
      this.handleDocumentMouseDown = (event) => {
        const path = event.composedPath();
        if (this.containingElement && !path.includes(this.containingElement)) {
          this.hide();
        }
      };
      this.handlePanelSelect = (event) => {
        const target = event.target;
        if (!this.stayOpenOnSelect && target.tagName.toLowerCase() === "sl-menu") {
          this.hide();
          this.focusOnTrigger();
        }
      };
    }
    connectedCallback() {
      super.connectedCallback();
      if (!this.containingElement) {
        this.containingElement = this;
      }
    }
    firstUpdated() {
      this.panel.hidden = !this.open;
      if (this.open) {
        this.addOpenListeners();
        this.popup.active = true;
      }
    }
    disconnectedCallback() {
      super.disconnectedCallback();
      this.removeOpenListeners();
      this.hide();
    }
    focusOnTrigger() {
      const trigger = this.trigger.assignedElements({ flatten: true })[0];
      if (typeof (trigger == null ? void 0 : trigger.focus) === "function") {
        trigger.focus();
      }
    }
    getMenu() {
      return this.panel.assignedElements({ flatten: true }).find((el) => el.tagName.toLowerCase() === "sl-menu");
    }
    handleTriggerClick() {
      if (this.open) {
        this.hide();
      } else {
        this.show();
        this.focusOnTrigger();
      }
    }
    async handleTriggerKeyDown(event) {
      if ([" ", "Enter"].includes(event.key)) {
        event.preventDefault();
        this.handleTriggerClick();
        return;
      }
      const menu = this.getMenu();
      if (menu) {
        const menuItems = menu.getAllItems();
        const firstMenuItem = menuItems[0];
        const lastMenuItem = menuItems[menuItems.length - 1];
        if (["ArrowDown", "ArrowUp", "Home", "End"].includes(event.key)) {
          event.preventDefault();
          if (!this.open) {
            this.show();
            await this.updateComplete;
          }
          if (menuItems.length > 0) {
            this.updateComplete.then(() => {
              if (event.key === "ArrowDown" || event.key === "Home") {
                menu.setCurrentItem(firstMenuItem);
                firstMenuItem.focus();
              }
              if (event.key === "ArrowUp" || event.key === "End") {
                menu.setCurrentItem(lastMenuItem);
                lastMenuItem.focus();
              }
            });
          }
        }
      }
    }
    handleTriggerKeyUp(event) {
      if (event.key === " ") {
        event.preventDefault();
      }
    }
    handleTriggerSlotChange() {
      this.updateAccessibleTrigger();
    }
    //
    // Slotted triggers can be arbitrary content, but we need to link them to the dropdown panel with `aria-haspopup` and
    // `aria-expanded`. These must be applied to the "accessible trigger" (the tabbable portion of the trigger element
    // that gets slotted in) so screen readers will understand them. The accessible trigger could be the slotted element,
    // a child of the slotted element, or an element in the slotted element's shadow root.
    //
    // For example, the accessible trigger of an <sl-button> is a <button> located inside its shadow root.
    //
    // To determine this, we assume the first tabbable element in the trigger slot is the "accessible trigger."
    //
    updateAccessibleTrigger() {
      const assignedElements = this.trigger.assignedElements({ flatten: true });
      const accessibleTrigger = assignedElements.find((el) => getTabbableBoundary(el).start);
      let target;
      if (accessibleTrigger) {
        switch (accessibleTrigger.tagName.toLowerCase()) {
          case "sl-button":
          case "sl-icon-button":
            target = accessibleTrigger.button;
            break;
          default:
            target = accessibleTrigger;
        }
        target.setAttribute("aria-haspopup", "true");
        target.setAttribute("aria-expanded", this.open ? "true" : "false");
      }
    }
    /** Shows the dropdown panel. */
    async show() {
      if (this.open) {
        return void 0;
      }
      this.open = true;
      return waitForEvent(this, "sl-after-show");
    }
    /** Hides the dropdown panel */
    async hide() {
      if (!this.open) {
        return void 0;
      }
      this.open = false;
      return waitForEvent(this, "sl-after-hide");
    }
    /**
     * Instructs the dropdown menu to reposition. Useful when the position or size of the trigger changes when the menu
     * is activated.
     */
    reposition() {
      this.popup.reposition();
    }
    addOpenListeners() {
      var _a;
      this.panel.addEventListener("sl-select", this.handlePanelSelect);
      if ("CloseWatcher" in window) {
        (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
        this.closeWatcher = new CloseWatcher();
        this.closeWatcher.onclose = () => {
          this.hide();
          this.focusOnTrigger();
        };
      } else {
        this.panel.addEventListener("keydown", this.handleKeyDown);
      }
      document.addEventListener("keydown", this.handleDocumentKeyDown);
      document.addEventListener("mousedown", this.handleDocumentMouseDown);
    }
    removeOpenListeners() {
      var _a;
      if (this.panel) {
        this.panel.removeEventListener("sl-select", this.handlePanelSelect);
        this.panel.removeEventListener("keydown", this.handleKeyDown);
      }
      document.removeEventListener("keydown", this.handleDocumentKeyDown);
      document.removeEventListener("mousedown", this.handleDocumentMouseDown);
      (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
    }
    async handleOpenChange() {
      if (this.disabled) {
        this.open = false;
        return;
      }
      this.updateAccessibleTrigger();
      if (this.open) {
        this.emit("sl-show");
        this.addOpenListeners();
        await stopAnimations(this);
        this.panel.hidden = false;
        this.popup.active = true;
        const { keyframes, options } = getAnimation(this, "dropdown.show", { dir: this.localize.dir() });
        await animateTo(this.popup.popup, keyframes, options);
        this.emit("sl-after-show");
      } else {
        this.emit("sl-hide");
        this.removeOpenListeners();
        await stopAnimations(this);
        const { keyframes, options } = getAnimation(this, "dropdown.hide", { dir: this.localize.dir() });
        await animateTo(this.popup.popup, keyframes, options);
        this.panel.hidden = true;
        this.popup.active = false;
        this.emit("sl-after-hide");
      }
    }
    render() {
      return x`
      <sl-popup
        part="base"
        exportparts="popup:base__popup"
        id="dropdown"
        placement=${this.placement}
        distance=${this.distance}
        skidding=${this.skidding}
        strategy=${this.hoist ? "fixed" : "absolute"}
        flip
        shift
        auto-size="vertical"
        auto-size-padding="10"
        sync=${o11(this.sync ? this.sync : void 0)}
        class=${e10({
        dropdown: true,
        "dropdown--open": this.open
      })}
      >
        <slot
          name="trigger"
          slot="anchor"
          part="trigger"
          class="dropdown__trigger"
          @click=${this.handleTriggerClick}
          @keydown=${this.handleTriggerKeyDown}
          @keyup=${this.handleTriggerKeyUp}
          @slotchange=${this.handleTriggerSlotChange}
        ></slot>

        <div aria-hidden=${this.open ? "false" : "true"} aria-labelledby="dropdown">
          <slot part="panel" class="dropdown__panel"></slot>
        </div>
      </sl-popup>
    `;
    }
  };
  SlDropdown.styles = [component_styles_default, dropdown_styles_default];
  SlDropdown.dependencies = { "sl-popup": SlPopup };
  __decorateClass2([
    e6(".dropdown")
  ], SlDropdown.prototype, "popup", 2);
  __decorateClass2([
    e6(".dropdown__trigger")
  ], SlDropdown.prototype, "trigger", 2);
  __decorateClass2([
    e6(".dropdown__panel")
  ], SlDropdown.prototype, "panel", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlDropdown.prototype, "open", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlDropdown.prototype, "placement", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlDropdown.prototype, "disabled", 2);
  __decorateClass2([
    n5({ attribute: "stay-open-on-select", type: Boolean, reflect: true })
  ], SlDropdown.prototype, "stayOpenOnSelect", 2);
  __decorateClass2([
    n5({ attribute: false })
  ], SlDropdown.prototype, "containingElement", 2);
  __decorateClass2([
    n5({ type: Number })
  ], SlDropdown.prototype, "distance", 2);
  __decorateClass2([
    n5({ type: Number })
  ], SlDropdown.prototype, "skidding", 2);
  __decorateClass2([
    n5({ type: Boolean })
  ], SlDropdown.prototype, "hoist", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlDropdown.prototype, "sync", 2);
  __decorateClass2([
    watch("open", { waitUntilFirstUpdate: true })
  ], SlDropdown.prototype, "handleOpenChange", 1);
  setDefaultAnimation("dropdown.show", {
    keyframes: [
      { opacity: 0, scale: 0.9 },
      { opacity: 1, scale: 1 }
    ],
    options: { duration: 100, easing: "ease" }
  });
  setDefaultAnimation("dropdown.hide", {
    keyframes: [
      { opacity: 1, scale: 1 },
      { opacity: 0, scale: 0.9 }
    ],
    options: { duration: 100, easing: "ease" }
  });

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.O6CEROC7.js
  var color_picker_styles_default = i3`
  :host {
    --grid-width: 280px;
    --grid-height: 200px;
    --grid-handle-size: 16px;
    --slider-height: 15px;
    --slider-handle-size: 17px;
    --swatch-size: 25px;

    display: inline-block;
  }

  .color-picker {
    width: var(--grid-width);
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    color: var(--color);
    background-color: var(--sl-panel-background-color);
    border-radius: var(--sl-border-radius-medium);
    user-select: none;
    -webkit-user-select: none;
  }

  .color-picker--inline {
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
  }

  .color-picker--inline:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-picker__grid {
    position: relative;
    height: var(--grid-height);
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 1) 100%),
      linear-gradient(to right, #fff 0%, rgba(255, 255, 255, 0) 100%);
    border-top-left-radius: var(--sl-border-radius-medium);
    border-top-right-radius: var(--sl-border-radius-medium);
    cursor: crosshair;
    forced-color-adjust: none;
  }

  .color-picker__grid-handle {
    position: absolute;
    width: var(--grid-handle-size);
    height: var(--grid-handle-size);
    border-radius: 50%;
    box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
    border: solid 2px white;
    margin-top: calc(var(--grid-handle-size) / -2);
    margin-left: calc(var(--grid-handle-size) / -2);
    transition: var(--sl-transition-fast) scale;
  }

  .color-picker__grid-handle--dragging {
    cursor: none;
    scale: 1.5;
  }

  .color-picker__grid-handle:focus-visible {
    outline: var(--sl-focus-ring);
  }

  .color-picker__controls {
    padding: var(--sl-spacing-small);
    display: flex;
    align-items: center;
  }

  .color-picker__sliders {
    flex: 1 1 auto;
  }

  .color-picker__slider {
    position: relative;
    height: var(--slider-height);
    border-radius: var(--sl-border-radius-pill);
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.2);
    forced-color-adjust: none;
  }

  .color-picker__slider:not(:last-of-type) {
    margin-bottom: var(--sl-spacing-small);
  }

  .color-picker__slider-handle {
    position: absolute;
    top: calc(50% - var(--slider-handle-size) / 2);
    width: var(--slider-handle-size);
    height: var(--slider-handle-size);
    background-color: white;
    border-radius: 50%;
    box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.25);
    margin-left: calc(var(--slider-handle-size) / -2);
  }

  .color-picker__slider-handle:focus-visible {
    outline: var(--sl-focus-ring);
  }

  .color-picker__hue {
    background-image: linear-gradient(
      to right,
      rgb(255, 0, 0) 0%,
      rgb(255, 255, 0) 17%,
      rgb(0, 255, 0) 33%,
      rgb(0, 255, 255) 50%,
      rgb(0, 0, 255) 67%,
      rgb(255, 0, 255) 83%,
      rgb(255, 0, 0) 100%
    );
  }

  .color-picker__alpha .color-picker__alpha-gradient {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: inherit;
  }

  .color-picker__preview {
    flex: 0 0 auto;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    position: relative;
    width: 2.25rem;
    height: 2.25rem;
    border: none;
    border-radius: var(--sl-border-radius-circle);
    background: none;
    margin-left: var(--sl-spacing-small);
    cursor: copy;
    forced-color-adjust: none;
  }

  .color-picker__preview:before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: inherit;
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.2);

    /* We use a custom property in lieu of currentColor because of https://bugs.webkit.org/show_bug.cgi?id=216780 */
    background-color: var(--preview-color);
  }

  .color-picker__preview:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-picker__preview-color {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: solid 1px rgba(0, 0, 0, 0.125);
  }

  .color-picker__preview-color--copied {
    animation: pulse 0.75s;
  }

  @keyframes pulse {
    0% {
      box-shadow: 0 0 0 0 var(--sl-color-primary-500);
    }
    70% {
      box-shadow: 0 0 0 0.5rem transparent;
    }
    100% {
      box-shadow: 0 0 0 0 transparent;
    }
  }

  .color-picker__user-input {
    display: flex;
    padding: 0 var(--sl-spacing-small) var(--sl-spacing-small) var(--sl-spacing-small);
  }

  .color-picker__user-input sl-input {
    min-width: 0; /* fix input width in Safari */
    flex: 1 1 auto;
  }

  .color-picker__user-input sl-button-group {
    margin-left: var(--sl-spacing-small);
  }

  .color-picker__user-input sl-button {
    min-width: 3.25rem;
    max-width: 3.25rem;
    font-size: 1rem;
  }

  .color-picker__swatches {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    grid-gap: 0.5rem;
    justify-items: center;
    border-top: solid 1px var(--sl-color-neutral-200);
    padding: var(--sl-spacing-small);
    forced-color-adjust: none;
  }

  .color-picker__swatch {
    position: relative;
    width: var(--swatch-size);
    height: var(--swatch-size);
    border-radius: var(--sl-border-radius-small);
  }

  .color-picker__swatch .color-picker__swatch-color {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border: solid 1px rgba(0, 0, 0, 0.125);
    border-radius: inherit;
    cursor: pointer;
  }

  .color-picker__swatch:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-picker__transparent-bg {
    background-image: linear-gradient(45deg, var(--sl-color-neutral-300) 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, var(--sl-color-neutral-300) 75%),
      linear-gradient(45deg, transparent 75%, var(--sl-color-neutral-300) 75%),
      linear-gradient(45deg, var(--sl-color-neutral-300) 25%, transparent 25%);
    background-size: 10px 10px;
    background-position:
      0 0,
      0 0,
      -5px -5px,
      5px 5px;
  }

  .color-picker--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .color-picker--disabled .color-picker__grid,
  .color-picker--disabled .color-picker__grid-handle,
  .color-picker--disabled .color-picker__slider,
  .color-picker--disabled .color-picker__slider-handle,
  .color-picker--disabled .color-picker__preview,
  .color-picker--disabled .color-picker__swatch,
  .color-picker--disabled .color-picker__swatch-color {
    pointer-events: none;
  }

  /*
   * Color dropdown
   */

  .color-dropdown::part(panel) {
    max-height: none;
    background-color: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    overflow: visible;
  }

  .color-dropdown__trigger {
    display: inline-block;
    position: relative;
    background-color: transparent;
    border: none;
    cursor: pointer;
    forced-color-adjust: none;
  }

  .color-dropdown__trigger.color-dropdown__trigger--small {
    width: var(--sl-input-height-small);
    height: var(--sl-input-height-small);
    border-radius: var(--sl-border-radius-circle);
  }

  .color-dropdown__trigger.color-dropdown__trigger--medium {
    width: var(--sl-input-height-medium);
    height: var(--sl-input-height-medium);
    border-radius: var(--sl-border-radius-circle);
  }

  .color-dropdown__trigger.color-dropdown__trigger--large {
    width: var(--sl-input-height-large);
    height: var(--sl-input-height-large);
    border-radius: var(--sl-border-radius-circle);
  }

  .color-dropdown__trigger:before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: inherit;
    background-color: currentColor;
    box-shadow:
      inset 0 0 0 2px var(--sl-input-border-color),
      inset 0 0 0 4px var(--sl-color-neutral-0);
  }

  .color-dropdown__trigger--empty:before {
    background-color: transparent;
  }

  .color-dropdown__trigger:focus-visible {
    outline: none;
  }

  .color-dropdown__trigger:focus-visible:not(.color-dropdown__trigger--disabled) {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .color-dropdown__trigger.color-dropdown__trigger--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.HF7GESMZ.js
  function clamp2(value2, min2, max2) {
    const noNegativeZero = (n10) => Object.is(n10, -0) ? 0 : n10;
    if (value2 < min2) {
      return noNegativeZero(min2);
    }
    if (value2 > max2) {
      return noNegativeZero(max2);
    }
    return noNegativeZero(value2);
  }

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7DUCI5S4.js
  var spinner_styles_default = i3`
  :host {
    --track-width: 2px;
    --track-color: rgb(128 128 128 / 25%);
    --indicator-color: var(--sl-color-primary-600);
    --speed: 2s;

    display: inline-flex;
    width: 1em;
    height: 1em;
    flex: none;
  }

  .spinner {
    flex: 1 1 auto;
    height: 100%;
    width: 100%;
  }

  .spinner__track,
  .spinner__indicator {
    fill: none;
    stroke-width: var(--track-width);
    r: calc(0.5em - var(--track-width) / 2);
    cx: 0.5em;
    cy: 0.5em;
    transform-origin: 50% 50%;
  }

  .spinner__track {
    stroke: var(--track-color);
    transform-origin: 0% 0%;
  }

  .spinner__indicator {
    stroke: var(--indicator-color);
    stroke-linecap: round;
    stroke-dasharray: 150% 75%;
    animation: spin var(--speed) linear infinite;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
      stroke-dasharray: 0.05em, 3em;
    }

    50% {
      transform: rotate(450deg);
      stroke-dasharray: 1.375em, 1.375em;
    }

    100% {
      transform: rotate(1080deg);
      stroke-dasharray: 0.05em, 3em;
    }
  }
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.36O46B5H.js
  var SlSpinner = class extends ShoelaceElement {
    constructor() {
      super(...arguments);
      this.localize = new LocalizeController2(this);
    }
    render() {
      return x`
      <svg part="base" class="spinner" role="progressbar" aria-label=${this.localize.term("loading")}>
        <circle class="spinner__track"></circle>
        <circle class="spinner__indicator"></circle>
      </svg>
    `;
    }
  };
  SlSpinner.styles = [component_styles_default, spinner_styles_default];

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.SBCFYC2S.js
  var SlButton = class extends ShoelaceElement {
    constructor() {
      super(...arguments);
      this.formControlController = new FormControlController(this, {
        assumeInteractionOn: ["click"]
      });
      this.hasSlotController = new HasSlotController(this, "[default]", "prefix", "suffix");
      this.localize = new LocalizeController2(this);
      this.hasFocus = false;
      this.invalid = false;
      this.title = "";
      this.variant = "default";
      this.size = "medium";
      this.caret = false;
      this.disabled = false;
      this.loading = false;
      this.outline = false;
      this.pill = false;
      this.circle = false;
      this.type = "button";
      this.name = "";
      this.value = "";
      this.href = "";
      this.rel = "noreferrer noopener";
    }
    /** Gets the validity state object */
    get validity() {
      if (this.isButton()) {
        return this.button.validity;
      }
      return validValidityState;
    }
    /** Gets the validation message */
    get validationMessage() {
      if (this.isButton()) {
        return this.button.validationMessage;
      }
      return "";
    }
    firstUpdated() {
      if (this.isButton()) {
        this.formControlController.updateValidity();
      }
    }
    handleBlur() {
      this.hasFocus = false;
      this.emit("sl-blur");
    }
    handleFocus() {
      this.hasFocus = true;
      this.emit("sl-focus");
    }
    handleClick() {
      if (this.type === "submit") {
        this.formControlController.submit(this);
      }
      if (this.type === "reset") {
        this.formControlController.reset(this);
      }
    }
    handleInvalid(event) {
      this.formControlController.setValidity(false);
      this.formControlController.emitInvalidEvent(event);
    }
    isButton() {
      return this.href ? false : true;
    }
    isLink() {
      return this.href ? true : false;
    }
    handleDisabledChange() {
      if (this.isButton()) {
        this.formControlController.setValidity(this.disabled);
      }
    }
    /** Simulates a click on the button. */
    click() {
      this.button.click();
    }
    /** Sets focus on the button. */
    focus(options) {
      this.button.focus(options);
    }
    /** Removes focus from the button. */
    blur() {
      this.button.blur();
    }
    /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
    checkValidity() {
      if (this.isButton()) {
        return this.button.checkValidity();
      }
      return true;
    }
    /** Gets the associated form, if one exists. */
    getForm() {
      return this.formControlController.getForm();
    }
    /** Checks for validity and shows the browser's validation message if the control is invalid. */
    reportValidity() {
      if (this.isButton()) {
        return this.button.reportValidity();
      }
      return true;
    }
    /** Sets a custom validation message. Pass an empty string to restore validity. */
    setCustomValidity(message) {
      if (this.isButton()) {
        this.button.setCustomValidity(message);
        this.formControlController.updateValidity();
      }
    }
    render() {
      const isLink = this.isLink();
      const tag = isLink ? i8`a` : i8`button`;
      return u5`
      <${tag}
        part="base"
        class=${e10({
        button: true,
        "button--default": this.variant === "default",
        "button--primary": this.variant === "primary",
        "button--success": this.variant === "success",
        "button--neutral": this.variant === "neutral",
        "button--warning": this.variant === "warning",
        "button--danger": this.variant === "danger",
        "button--text": this.variant === "text",
        "button--small": this.size === "small",
        "button--medium": this.size === "medium",
        "button--large": this.size === "large",
        "button--caret": this.caret,
        "button--circle": this.circle,
        "button--disabled": this.disabled,
        "button--focused": this.hasFocus,
        "button--loading": this.loading,
        "button--standard": !this.outline,
        "button--outline": this.outline,
        "button--pill": this.pill,
        "button--rtl": this.localize.dir() === "rtl",
        "button--has-label": this.hasSlotController.test("[default]"),
        "button--has-prefix": this.hasSlotController.test("prefix"),
        "button--has-suffix": this.hasSlotController.test("suffix")
      })}
        ?disabled=${o11(isLink ? void 0 : this.disabled)}
        type=${o11(isLink ? void 0 : this.type)}
        title=${this.title}
        name=${o11(isLink ? void 0 : this.name)}
        value=${o11(isLink ? void 0 : this.value)}
        href=${o11(isLink && !this.disabled ? this.href : void 0)}
        target=${o11(isLink ? this.target : void 0)}
        download=${o11(isLink ? this.download : void 0)}
        rel=${o11(isLink ? this.rel : void 0)}
        role=${o11(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @invalid=${this.isButton() ? this.handleInvalid : null}
        @click=${this.handleClick}
      >
        <slot name="prefix" part="prefix" class="button__prefix"></slot>
        <slot part="label" class="button__label"></slot>
        <slot name="suffix" part="suffix" class="button__suffix"></slot>
        ${this.caret ? u5` <sl-icon part="caret" class="button__caret" library="system" name="caret"></sl-icon> ` : ""}
        ${this.loading ? u5`<sl-spinner part="spinner"></sl-spinner>` : ""}
      </${tag}>
    `;
    }
  };
  SlButton.styles = [component_styles_default, button_styles_default];
  SlButton.dependencies = {
    "sl-icon": SlIcon,
    "sl-spinner": SlSpinner
  };
  __decorateClass2([
    e6(".button")
  ], SlButton.prototype, "button", 2);
  __decorateClass2([
    r6()
  ], SlButton.prototype, "hasFocus", 2);
  __decorateClass2([
    r6()
  ], SlButton.prototype, "invalid", 2);
  __decorateClass2([
    n5()
  ], SlButton.prototype, "title", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlButton.prototype, "variant", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlButton.prototype, "size", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlButton.prototype, "caret", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlButton.prototype, "disabled", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlButton.prototype, "loading", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlButton.prototype, "outline", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlButton.prototype, "pill", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlButton.prototype, "circle", 2);
  __decorateClass2([
    n5()
  ], SlButton.prototype, "type", 2);
  __decorateClass2([
    n5()
  ], SlButton.prototype, "name", 2);
  __decorateClass2([
    n5()
  ], SlButton.prototype, "value", 2);
  __decorateClass2([
    n5()
  ], SlButton.prototype, "href", 2);
  __decorateClass2([
    n5()
  ], SlButton.prototype, "target", 2);
  __decorateClass2([
    n5()
  ], SlButton.prototype, "rel", 2);
  __decorateClass2([
    n5()
  ], SlButton.prototype, "download", 2);
  __decorateClass2([
    n5()
  ], SlButton.prototype, "form", 2);
  __decorateClass2([
    n5({ attribute: "formaction" })
  ], SlButton.prototype, "formAction", 2);
  __decorateClass2([
    n5({ attribute: "formenctype" })
  ], SlButton.prototype, "formEnctype", 2);
  __decorateClass2([
    n5({ attribute: "formmethod" })
  ], SlButton.prototype, "formMethod", 2);
  __decorateClass2([
    n5({ attribute: "formnovalidate", type: Boolean })
  ], SlButton.prototype, "formNoValidate", 2);
  __decorateClass2([
    n5({ attribute: "formtarget" })
  ], SlButton.prototype, "formTarget", 2);
  __decorateClass2([
    watch("disabled", { waitUntilFirstUpdate: true })
  ], SlButton.prototype, "handleDisabledChange", 1);

  // node_modules/lit-html/directives/style-map.js
  var n9 = "important";
  var i10 = " !" + n9;
  var o12 = e8(class extends i7 {
    constructor(t7) {
      if (super(t7), t7.type !== t6.ATTRIBUTE || "style" !== t7.name || t7.strings?.length > 2)
        throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
    }
    render(t7) {
      return Object.keys(t7).reduce((e13, r9) => {
        const s6 = t7[r9];
        return null == s6 ? e13 : e13 + `${r9 = r9.includes("-") ? r9 : r9.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${s6};`;
      }, "");
    }
    update(e13, [r9]) {
      const { style: s6 } = e13.element;
      if (void 0 === this.ft)
        return this.ft = new Set(Object.keys(r9)), this.render(r9);
      for (const t7 of this.ft)
        null == r9[t7] && (this.ft.delete(t7), t7.includes("-") ? s6.removeProperty(t7) : s6[t7] = null);
      for (const t7 in r9) {
        const e14 = r9[t7];
        if (null != e14) {
          this.ft.add(t7);
          const r10 = "string" == typeof e14 && e14.endsWith(i10);
          t7.includes("-") || r10 ? s6.setProperty(t7, r10 ? e14.slice(0, -11) : e14, r10 ? n9 : "") : s6[t7] = e14;
        }
      }
      return T2;
    }
  });

  // node_modules/@ctrl/tinycolor/dist/module/util.js
  function bound01(n10, max2) {
    if (isOnePointZero(n10)) {
      n10 = "100%";
    }
    const isPercent = isPercentage(n10);
    n10 = max2 === 360 ? n10 : Math.min(max2, Math.max(0, parseFloat(n10)));
    if (isPercent) {
      n10 = parseInt(String(n10 * max2), 10) / 100;
    }
    if (Math.abs(n10 - max2) < 1e-6) {
      return 1;
    }
    if (max2 === 360) {
      n10 = (n10 < 0 ? n10 % max2 + max2 : n10 % max2) / parseFloat(String(max2));
    } else {
      n10 = n10 % max2 / parseFloat(String(max2));
    }
    return n10;
  }
  function clamp01(val) {
    return Math.min(1, Math.max(0, val));
  }
  function isOnePointZero(n10) {
    return typeof n10 === "string" && n10.indexOf(".") !== -1 && parseFloat(n10) === 1;
  }
  function isPercentage(n10) {
    return typeof n10 === "string" && n10.indexOf("%") !== -1;
  }
  function boundAlpha(a5) {
    a5 = parseFloat(a5);
    if (isNaN(a5) || a5 < 0 || a5 > 1) {
      a5 = 1;
    }
    return a5;
  }
  function convertToPercentage(n10) {
    if (Number(n10) <= 1) {
      return `${Number(n10) * 100}%`;
    }
    return n10;
  }
  function pad2(c7) {
    return c7.length === 1 ? "0" + c7 : String(c7);
  }

  // node_modules/@ctrl/tinycolor/dist/module/conversion.js
  function rgbToRgb(r9, g3, b4) {
    return {
      r: bound01(r9, 255) * 255,
      g: bound01(g3, 255) * 255,
      b: bound01(b4, 255) * 255
    };
  }
  function rgbToHsl(r9, g3, b4) {
    r9 = bound01(r9, 255);
    g3 = bound01(g3, 255);
    b4 = bound01(b4, 255);
    const max2 = Math.max(r9, g3, b4);
    const min2 = Math.min(r9, g3, b4);
    let h6 = 0;
    let s6 = 0;
    const l6 = (max2 + min2) / 2;
    if (max2 === min2) {
      s6 = 0;
      h6 = 0;
    } else {
      const d4 = max2 - min2;
      s6 = l6 > 0.5 ? d4 / (2 - max2 - min2) : d4 / (max2 + min2);
      switch (max2) {
        case r9:
          h6 = (g3 - b4) / d4 + (g3 < b4 ? 6 : 0);
          break;
        case g3:
          h6 = (b4 - r9) / d4 + 2;
          break;
        case b4:
          h6 = (r9 - g3) / d4 + 4;
          break;
        default:
          break;
      }
      h6 /= 6;
    }
    return { h: h6, s: s6, l: l6 };
  }
  function hue2rgb(p4, q, t7) {
    if (t7 < 0) {
      t7 += 1;
    }
    if (t7 > 1) {
      t7 -= 1;
    }
    if (t7 < 1 / 6) {
      return p4 + (q - p4) * (6 * t7);
    }
    if (t7 < 1 / 2) {
      return q;
    }
    if (t7 < 2 / 3) {
      return p4 + (q - p4) * (2 / 3 - t7) * 6;
    }
    return p4;
  }
  function hslToRgb(h6, s6, l6) {
    let r9;
    let g3;
    let b4;
    h6 = bound01(h6, 360);
    s6 = bound01(s6, 100);
    l6 = bound01(l6, 100);
    if (s6 === 0) {
      g3 = l6;
      b4 = l6;
      r9 = l6;
    } else {
      const q = l6 < 0.5 ? l6 * (1 + s6) : l6 + s6 - l6 * s6;
      const p4 = 2 * l6 - q;
      r9 = hue2rgb(p4, q, h6 + 1 / 3);
      g3 = hue2rgb(p4, q, h6);
      b4 = hue2rgb(p4, q, h6 - 1 / 3);
    }
    return { r: r9 * 255, g: g3 * 255, b: b4 * 255 };
  }
  function rgbToHsv(r9, g3, b4) {
    r9 = bound01(r9, 255);
    g3 = bound01(g3, 255);
    b4 = bound01(b4, 255);
    const max2 = Math.max(r9, g3, b4);
    const min2 = Math.min(r9, g3, b4);
    let h6 = 0;
    const v3 = max2;
    const d4 = max2 - min2;
    const s6 = max2 === 0 ? 0 : d4 / max2;
    if (max2 === min2) {
      h6 = 0;
    } else {
      switch (max2) {
        case r9:
          h6 = (g3 - b4) / d4 + (g3 < b4 ? 6 : 0);
          break;
        case g3:
          h6 = (b4 - r9) / d4 + 2;
          break;
        case b4:
          h6 = (r9 - g3) / d4 + 4;
          break;
        default:
          break;
      }
      h6 /= 6;
    }
    return { h: h6, s: s6, v: v3 };
  }
  function hsvToRgb(h6, s6, v3) {
    h6 = bound01(h6, 360) * 6;
    s6 = bound01(s6, 100);
    v3 = bound01(v3, 100);
    const i11 = Math.floor(h6);
    const f6 = h6 - i11;
    const p4 = v3 * (1 - s6);
    const q = v3 * (1 - f6 * s6);
    const t7 = v3 * (1 - (1 - f6) * s6);
    const mod = i11 % 6;
    const r9 = [v3, q, p4, p4, t7, v3][mod];
    const g3 = [t7, v3, v3, q, p4, p4][mod];
    const b4 = [p4, p4, t7, v3, v3, q][mod];
    return { r: r9 * 255, g: g3 * 255, b: b4 * 255 };
  }
  function rgbToHex(r9, g3, b4, allow3Char) {
    const hex = [
      pad2(Math.round(r9).toString(16)),
      pad2(Math.round(g3).toString(16)),
      pad2(Math.round(b4).toString(16))
    ];
    if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
      return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }
    return hex.join("");
  }
  function rgbaToHex(r9, g3, b4, a5, allow4Char) {
    const hex = [
      pad2(Math.round(r9).toString(16)),
      pad2(Math.round(g3).toString(16)),
      pad2(Math.round(b4).toString(16)),
      pad2(convertDecimalToHex(a5))
    ];
    if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
      return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
    }
    return hex.join("");
  }
  function cmykToRgb(c7, m4, y4, k3) {
    const cConv = c7 / 100;
    const mConv = m4 / 100;
    const yConv = y4 / 100;
    const kConv = k3 / 100;
    const r9 = 255 * (1 - cConv) * (1 - kConv);
    const g3 = 255 * (1 - mConv) * (1 - kConv);
    const b4 = 255 * (1 - yConv) * (1 - kConv);
    return { r: r9, g: g3, b: b4 };
  }
  function rgbToCmyk(r9, g3, b4) {
    let c7 = 1 - r9 / 255;
    let m4 = 1 - g3 / 255;
    let y4 = 1 - b4 / 255;
    let k3 = Math.min(c7, m4, y4);
    if (k3 === 1) {
      c7 = 0;
      m4 = 0;
      y4 = 0;
    } else {
      c7 = (c7 - k3) / (1 - k3) * 100;
      m4 = (m4 - k3) / (1 - k3) * 100;
      y4 = (y4 - k3) / (1 - k3) * 100;
    }
    k3 *= 100;
    return {
      c: Math.round(c7),
      m: Math.round(m4),
      y: Math.round(y4),
      k: Math.round(k3)
    };
  }
  function convertDecimalToHex(d4) {
    return Math.round(parseFloat(d4) * 255).toString(16);
  }
  function convertHexToDecimal(h6) {
    return parseIntFromHex(h6) / 255;
  }
  function parseIntFromHex(val) {
    return parseInt(val, 16);
  }
  function numberInputToObject(color) {
    return {
      r: color >> 16,
      g: (color & 65280) >> 8,
      b: color & 255
    };
  }

  // node_modules/@ctrl/tinycolor/dist/module/css-color-names.js
  var names = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    goldenrod: "#daa520",
    gold: "#ffd700",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavenderblush: "#fff0f5",
    lavender: "#e6e6fa",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  };

  // node_modules/@ctrl/tinycolor/dist/module/format-input.js
  function inputToRGB(color) {
    let rgb = { r: 0, g: 0, b: 0 };
    let a5 = 1;
    let s6 = null;
    let v3 = null;
    let l6 = null;
    let ok = false;
    let format = false;
    if (typeof color === "string") {
      color = stringInputToObject(color);
    }
    if (typeof color === "object") {
      if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
        rgb = rgbToRgb(color.r, color.g, color.b);
        ok = true;
        format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
      } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
        s6 = convertToPercentage(color.s);
        v3 = convertToPercentage(color.v);
        rgb = hsvToRgb(color.h, s6, v3);
        ok = true;
        format = "hsv";
      } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
        s6 = convertToPercentage(color.s);
        l6 = convertToPercentage(color.l);
        rgb = hslToRgb(color.h, s6, l6);
        ok = true;
        format = "hsl";
      } else if (isValidCSSUnit(color.c) && isValidCSSUnit(color.m) && isValidCSSUnit(color.y) && isValidCSSUnit(color.k)) {
        rgb = cmykToRgb(color.c, color.m, color.y, color.k);
        ok = true;
        format = "cmyk";
      }
      if (Object.prototype.hasOwnProperty.call(color, "a")) {
        a5 = color.a;
      }
    }
    a5 = boundAlpha(a5);
    return {
      ok,
      format: color.format || format,
      r: Math.min(255, Math.max(rgb.r, 0)),
      g: Math.min(255, Math.max(rgb.g, 0)),
      b: Math.min(255, Math.max(rgb.b, 0)),
      a: a5
    };
  }
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = (
    // eslint-disable-next-line prettier/prettier
    "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?"
  );
  var matchers = {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    cmyk: new RegExp("cmyk" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
  function stringInputToObject(color) {
    color = color.trim().toLowerCase();
    if (color.length === 0) {
      return false;
    }
    let named = false;
    if (names[color]) {
      color = names[color];
      named = true;
    } else if (color === "transparent") {
      return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    }
    let match = matchers.rgb.exec(color);
    if (match) {
      return { r: match[1], g: match[2], b: match[3] };
    }
    match = matchers.rgba.exec(color);
    if (match) {
      return { r: match[1], g: match[2], b: match[3], a: match[4] };
    }
    match = matchers.hsl.exec(color);
    if (match) {
      return { h: match[1], s: match[2], l: match[3] };
    }
    match = matchers.hsla.exec(color);
    if (match) {
      return { h: match[1], s: match[2], l: match[3], a: match[4] };
    }
    match = matchers.hsv.exec(color);
    if (match) {
      return { h: match[1], s: match[2], v: match[3] };
    }
    match = matchers.hsva.exec(color);
    if (match) {
      return { h: match[1], s: match[2], v: match[3], a: match[4] };
    }
    match = matchers.cmyk.exec(color);
    if (match) {
      return {
        c: match[1],
        m: match[2],
        y: match[3],
        k: match[4]
      };
    }
    match = matchers.hex8.exec(color);
    if (match) {
      return {
        r: parseIntFromHex(match[1]),
        g: parseIntFromHex(match[2]),
        b: parseIntFromHex(match[3]),
        a: convertHexToDecimal(match[4]),
        format: named ? "name" : "hex8"
      };
    }
    match = matchers.hex6.exec(color);
    if (match) {
      return {
        r: parseIntFromHex(match[1]),
        g: parseIntFromHex(match[2]),
        b: parseIntFromHex(match[3]),
        format: named ? "name" : "hex"
      };
    }
    match = matchers.hex4.exec(color);
    if (match) {
      return {
        r: parseIntFromHex(match[1] + match[1]),
        g: parseIntFromHex(match[2] + match[2]),
        b: parseIntFromHex(match[3] + match[3]),
        a: convertHexToDecimal(match[4] + match[4]),
        format: named ? "name" : "hex8"
      };
    }
    match = matchers.hex3.exec(color);
    if (match) {
      return {
        r: parseIntFromHex(match[1] + match[1]),
        g: parseIntFromHex(match[2] + match[2]),
        b: parseIntFromHex(match[3] + match[3]),
        format: named ? "name" : "hex"
      };
    }
    return false;
  }
  function isValidCSSUnit(color) {
    if (typeof color === "number") {
      return !Number.isNaN(color);
    }
    return matchers.CSS_UNIT.test(color);
  }

  // node_modules/@ctrl/tinycolor/dist/module/index.js
  var TinyColor = class _TinyColor {
    constructor(color = "", opts = {}) {
      if (color instanceof _TinyColor) {
        return color;
      }
      if (typeof color === "number") {
        color = numberInputToObject(color);
      }
      this.originalInput = color;
      const rgb = inputToRGB(color);
      this.originalInput = color;
      this.r = rgb.r;
      this.g = rgb.g;
      this.b = rgb.b;
      this.a = rgb.a;
      this.roundA = Math.round(100 * this.a) / 100;
      this.format = opts.format ?? rgb.format;
      this.gradientType = opts.gradientType;
      if (this.r < 1) {
        this.r = Math.round(this.r);
      }
      if (this.g < 1) {
        this.g = Math.round(this.g);
      }
      if (this.b < 1) {
        this.b = Math.round(this.b);
      }
      this.isValid = rgb.ok;
    }
    isDark() {
      return this.getBrightness() < 128;
    }
    isLight() {
      return !this.isDark();
    }
    /**
     * Returns the perceived brightness of the color, from 0-255.
     */
    getBrightness() {
      const rgb = this.toRgb();
      return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
    }
    /**
     * Returns the perceived luminance of a color, from 0-1.
     */
    getLuminance() {
      const rgb = this.toRgb();
      let R3;
      let G;
      let B3;
      const RsRGB = rgb.r / 255;
      const GsRGB = rgb.g / 255;
      const BsRGB = rgb.b / 255;
      if (RsRGB <= 0.03928) {
        R3 = RsRGB / 12.92;
      } else {
        R3 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
      }
      if (GsRGB <= 0.03928) {
        G = GsRGB / 12.92;
      } else {
        G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
      }
      if (BsRGB <= 0.03928) {
        B3 = BsRGB / 12.92;
      } else {
        B3 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
      }
      return 0.2126 * R3 + 0.7152 * G + 0.0722 * B3;
    }
    /**
     * Returns the alpha value of a color, from 0-1.
     */
    getAlpha() {
      return this.a;
    }
    /**
     * Sets the alpha value on the current color.
     *
     * @param alpha - The new alpha value. The accepted range is 0-1.
     */
    setAlpha(alpha) {
      this.a = boundAlpha(alpha);
      this.roundA = Math.round(100 * this.a) / 100;
      return this;
    }
    /**
     * Returns whether the color is monochrome.
     */
    isMonochrome() {
      const { s: s6 } = this.toHsl();
      return s6 === 0;
    }
    /**
     * Returns the object as a HSVA object.
     */
    toHsv() {
      const hsv = rgbToHsv(this.r, this.g, this.b);
      return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
    }
    /**
     * Returns the hsva values interpolated into a string with the following format:
     * "hsva(xxx, xxx, xxx, xx)".
     */
    toHsvString() {
      const hsv = rgbToHsv(this.r, this.g, this.b);
      const h6 = Math.round(hsv.h * 360);
      const s6 = Math.round(hsv.s * 100);
      const v3 = Math.round(hsv.v * 100);
      return this.a === 1 ? `hsv(${h6}, ${s6}%, ${v3}%)` : `hsva(${h6}, ${s6}%, ${v3}%, ${this.roundA})`;
    }
    /**
     * Returns the object as a HSLA object.
     */
    toHsl() {
      const hsl = rgbToHsl(this.r, this.g, this.b);
      return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
    }
    /**
     * Returns the hsla values interpolated into a string with the following format:
     * "hsla(xxx, xxx, xxx, xx)".
     */
    toHslString() {
      const hsl = rgbToHsl(this.r, this.g, this.b);
      const h6 = Math.round(hsl.h * 360);
      const s6 = Math.round(hsl.s * 100);
      const l6 = Math.round(hsl.l * 100);
      return this.a === 1 ? `hsl(${h6}, ${s6}%, ${l6}%)` : `hsla(${h6}, ${s6}%, ${l6}%, ${this.roundA})`;
    }
    /**
     * Returns the hex value of the color.
     * @param allow3Char will shorten hex value to 3 char if possible
     */
    toHex(allow3Char = false) {
      return rgbToHex(this.r, this.g, this.b, allow3Char);
    }
    /**
     * Returns the hex value of the color -with a # prefixed.
     * @param allow3Char will shorten hex value to 3 char if possible
     */
    toHexString(allow3Char = false) {
      return "#" + this.toHex(allow3Char);
    }
    /**
     * Returns the hex 8 value of the color.
     * @param allow4Char will shorten hex value to 4 char if possible
     */
    toHex8(allow4Char = false) {
      return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
    }
    /**
     * Returns the hex 8 value of the color -with a # prefixed.
     * @param allow4Char will shorten hex value to 4 char if possible
     */
    toHex8String(allow4Char = false) {
      return "#" + this.toHex8(allow4Char);
    }
    /**
     * Returns the shorter hex value of the color depends on its alpha -with a # prefixed.
     * @param allowShortChar will shorten hex value to 3 or 4 char if possible
     */
    toHexShortString(allowShortChar = false) {
      return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
    }
    /**
     * Returns the object as a RGBA object.
     */
    toRgb() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    }
    /**
     * Returns the RGBA values interpolated into a string with the following format:
     * "RGBA(xxx, xxx, xxx, xx)".
     */
    toRgbString() {
      const r9 = Math.round(this.r);
      const g3 = Math.round(this.g);
      const b4 = Math.round(this.b);
      return this.a === 1 ? `rgb(${r9}, ${g3}, ${b4})` : `rgba(${r9}, ${g3}, ${b4}, ${this.roundA})`;
    }
    /**
     * Returns the object as a RGBA object.
     */
    toPercentageRgb() {
      const fmt = (x2) => `${Math.round(bound01(x2, 255) * 100)}%`;
      return {
        r: fmt(this.r),
        g: fmt(this.g),
        b: fmt(this.b),
        a: this.a
      };
    }
    /**
     * Returns the RGBA relative values interpolated into a string
     */
    toPercentageRgbString() {
      const rnd = (x2) => Math.round(bound01(x2, 255) * 100);
      return this.a === 1 ? `rgb(${rnd(this.r)}%, ${rnd(this.g)}%, ${rnd(this.b)}%)` : `rgba(${rnd(this.r)}%, ${rnd(this.g)}%, ${rnd(this.b)}%, ${this.roundA})`;
    }
    toCmyk() {
      return {
        ...rgbToCmyk(this.r, this.g, this.b)
      };
    }
    toCmykString() {
      const { c: c7, m: m4, y: y4, k: k3 } = rgbToCmyk(this.r, this.g, this.b);
      return `cmyk(${c7}, ${m4}, ${y4}, ${k3})`;
    }
    /**
     * The 'real' name of the color -if there is one.
     */
    toName() {
      if (this.a === 0) {
        return "transparent";
      }
      if (this.a < 1) {
        return false;
      }
      const hex = "#" + rgbToHex(this.r, this.g, this.b, false);
      for (const [key, value2] of Object.entries(names)) {
        if (hex === value2) {
          return key;
        }
      }
      return false;
    }
    toString(format) {
      const formatSet = Boolean(format);
      format = format ?? this.format;
      let formattedString = false;
      const hasAlpha = this.a < 1 && this.a >= 0;
      const needsAlphaFormat = !formatSet && hasAlpha && (format.startsWith("hex") || format === "name");
      if (needsAlphaFormat) {
        if (format === "name" && this.a === 0) {
          return this.toName();
        }
        return this.toRgbString();
      }
      if (format === "rgb") {
        formattedString = this.toRgbString();
      }
      if (format === "prgb") {
        formattedString = this.toPercentageRgbString();
      }
      if (format === "hex" || format === "hex6") {
        formattedString = this.toHexString();
      }
      if (format === "hex3") {
        formattedString = this.toHexString(true);
      }
      if (format === "hex4") {
        formattedString = this.toHex8String(true);
      }
      if (format === "hex8") {
        formattedString = this.toHex8String();
      }
      if (format === "name") {
        formattedString = this.toName();
      }
      if (format === "hsl") {
        formattedString = this.toHslString();
      }
      if (format === "hsv") {
        formattedString = this.toHsvString();
      }
      if (format === "cmyk") {
        formattedString = this.toCmykString();
      }
      return formattedString || this.toHexString();
    }
    toNumber() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    }
    clone() {
      return new _TinyColor(this.toString());
    }
    /**
     * Lighten the color a given amount. Providing 100 will always return white.
     * @param amount - valid between 1-100
     */
    lighten(amount = 10) {
      const hsl = this.toHsl();
      hsl.l += amount / 100;
      hsl.l = clamp01(hsl.l);
      return new _TinyColor(hsl);
    }
    /**
     * Brighten the color a given amount, from 0 to 100.
     * @param amount - valid between 1-100
     */
    brighten(amount = 10) {
      const rgb = this.toRgb();
      rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
      rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
      rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
      return new _TinyColor(rgb);
    }
    /**
     * Darken the color a given amount, from 0 to 100.
     * Providing 100 will always return black.
     * @param amount - valid between 1-100
     */
    darken(amount = 10) {
      const hsl = this.toHsl();
      hsl.l -= amount / 100;
      hsl.l = clamp01(hsl.l);
      return new _TinyColor(hsl);
    }
    /**
     * Mix the color with pure white, from 0 to 100.
     * Providing 0 will do nothing, providing 100 will always return white.
     * @param amount - valid between 1-100
     */
    tint(amount = 10) {
      return this.mix("white", amount);
    }
    /**
     * Mix the color with pure black, from 0 to 100.
     * Providing 0 will do nothing, providing 100 will always return black.
     * @param amount - valid between 1-100
     */
    shade(amount = 10) {
      return this.mix("black", amount);
    }
    /**
     * Desaturate the color a given amount, from 0 to 100.
     * Providing 100 will is the same as calling greyscale
     * @param amount - valid between 1-100
     */
    desaturate(amount = 10) {
      const hsl = this.toHsl();
      hsl.s -= amount / 100;
      hsl.s = clamp01(hsl.s);
      return new _TinyColor(hsl);
    }
    /**
     * Saturate the color a given amount, from 0 to 100.
     * @param amount - valid between 1-100
     */
    saturate(amount = 10) {
      const hsl = this.toHsl();
      hsl.s += amount / 100;
      hsl.s = clamp01(hsl.s);
      return new _TinyColor(hsl);
    }
    /**
     * Completely desaturates a color into greyscale.
     * Same as calling `desaturate(100)`
     */
    greyscale() {
      return this.desaturate(100);
    }
    /**
     * Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
     * Values outside of this range will be wrapped into this range.
     */
    spin(amount) {
      const hsl = this.toHsl();
      const hue = (hsl.h + amount) % 360;
      hsl.h = hue < 0 ? 360 + hue : hue;
      return new _TinyColor(hsl);
    }
    /**
     * Mix the current color a given amount with another color, from 0 to 100.
     * 0 means no mixing (return current color).
     */
    mix(color, amount = 50) {
      const rgb1 = this.toRgb();
      const rgb2 = new _TinyColor(color).toRgb();
      const p4 = amount / 100;
      const rgba = {
        r: (rgb2.r - rgb1.r) * p4 + rgb1.r,
        g: (rgb2.g - rgb1.g) * p4 + rgb1.g,
        b: (rgb2.b - rgb1.b) * p4 + rgb1.b,
        a: (rgb2.a - rgb1.a) * p4 + rgb1.a
      };
      return new _TinyColor(rgba);
    }
    analogous(results = 6, slices = 30) {
      const hsl = this.toHsl();
      const part = 360 / slices;
      const ret = [this];
      for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(new _TinyColor(hsl));
      }
      return ret;
    }
    /**
     * taken from https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js
     */
    complement() {
      const hsl = this.toHsl();
      hsl.h = (hsl.h + 180) % 360;
      return new _TinyColor(hsl);
    }
    monochromatic(results = 6) {
      const hsv = this.toHsv();
      const { h: h6 } = hsv;
      const { s: s6 } = hsv;
      let { v: v3 } = hsv;
      const res = [];
      const modification = 1 / results;
      while (results--) {
        res.push(new _TinyColor({ h: h6, s: s6, v: v3 }));
        v3 = (v3 + modification) % 1;
      }
      return res;
    }
    splitcomplement() {
      const hsl = this.toHsl();
      const { h: h6 } = hsl;
      return [
        this,
        new _TinyColor({ h: (h6 + 72) % 360, s: hsl.s, l: hsl.l }),
        new _TinyColor({ h: (h6 + 216) % 360, s: hsl.s, l: hsl.l })
      ];
    }
    /**
     * Compute how the color would appear on a background
     */
    onBackground(background) {
      const fg = this.toRgb();
      const bg = new _TinyColor(background).toRgb();
      const alpha = fg.a + bg.a * (1 - fg.a);
      return new _TinyColor({
        r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
        g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
        b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
        a: alpha
      });
    }
    /**
     * Alias for `polyad(3)`
     */
    triad() {
      return this.polyad(3);
    }
    /**
     * Alias for `polyad(4)`
     */
    tetrad() {
      return this.polyad(4);
    }
    /**
     * Get polyad colors, like (for 1, 2, 3, 4, 5, 6, 7, 8, etc...)
     * monad, dyad, triad, tetrad, pentad, hexad, heptad, octad, etc...
     */
    polyad(n10) {
      const hsl = this.toHsl();
      const { h: h6 } = hsl;
      const result = [this];
      const increment = 360 / n10;
      for (let i11 = 1; i11 < n10; i11++) {
        result.push(new _TinyColor({ h: (h6 + i11 * increment) % 360, s: hsl.s, l: hsl.l }));
      }
      return result;
    }
    /**
     * compare color vs current color
     */
    equals(color) {
      const comparedColor = new _TinyColor(color);
      if (this.format === "cmyk" || comparedColor.format === "cmyk") {
        return this.toCmykString() === comparedColor.toCmykString();
      }
      return this.toRgbString() === comparedColor.toRgbString();
    }
  };

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.PSBQ3SJY.js
  var hasEyeDropper = "EyeDropper" in window;
  var SlColorPicker = class extends ShoelaceElement {
    constructor() {
      super();
      this.formControlController = new FormControlController(this);
      this.isSafeValue = false;
      this.localize = new LocalizeController2(this);
      this.hasFocus = false;
      this.isDraggingGridHandle = false;
      this.isEmpty = false;
      this.inputValue = "";
      this.hue = 0;
      this.saturation = 100;
      this.brightness = 100;
      this.alpha = 100;
      this.value = "";
      this.defaultValue = "";
      this.label = "";
      this.format = "hex";
      this.inline = false;
      this.size = "medium";
      this.noFormatToggle = false;
      this.name = "";
      this.disabled = false;
      this.hoist = false;
      this.opacity = false;
      this.uppercase = false;
      this.swatches = "";
      this.form = "";
      this.required = false;
      this.handleFocusIn = () => {
        this.hasFocus = true;
        this.emit("sl-focus");
      };
      this.handleFocusOut = () => {
        this.hasFocus = false;
        this.emit("sl-blur");
      };
      this.addEventListener("focusin", this.handleFocusIn);
      this.addEventListener("focusout", this.handleFocusOut);
    }
    /** Gets the validity state object */
    get validity() {
      return this.input.validity;
    }
    /** Gets the validation message */
    get validationMessage() {
      return this.input.validationMessage;
    }
    firstUpdated() {
      this.input.updateComplete.then(() => {
        this.formControlController.updateValidity();
      });
    }
    handleCopy() {
      this.input.select();
      document.execCommand("copy");
      this.previewButton.focus();
      this.previewButton.classList.add("color-picker__preview-color--copied");
      this.previewButton.addEventListener("animationend", () => {
        this.previewButton.classList.remove("color-picker__preview-color--copied");
      });
    }
    handleFormatToggle() {
      const formats = ["hex", "rgb", "hsl", "hsv"];
      const nextIndex = (formats.indexOf(this.format) + 1) % formats.length;
      this.format = formats[nextIndex];
      this.setColor(this.value);
      this.emit("sl-change");
      this.emit("sl-input");
    }
    handleAlphaDrag(event) {
      const container = this.shadowRoot.querySelector(".color-picker__slider.color-picker__alpha");
      const handle = container.querySelector(".color-picker__slider-handle");
      const { width } = container.getBoundingClientRect();
      let initialValue = this.value;
      let currentValue = this.value;
      handle.focus();
      event.preventDefault();
      drag(container, {
        onMove: (x2) => {
          this.alpha = clamp2(x2 / width * 100, 0, 100);
          this.syncValues();
          if (this.value !== currentValue) {
            currentValue = this.value;
            this.emit("sl-input");
          }
        },
        onStop: () => {
          if (this.value !== initialValue) {
            initialValue = this.value;
            this.emit("sl-change");
          }
        },
        initialEvent: event
      });
    }
    handleHueDrag(event) {
      const container = this.shadowRoot.querySelector(".color-picker__slider.color-picker__hue");
      const handle = container.querySelector(".color-picker__slider-handle");
      const { width } = container.getBoundingClientRect();
      let initialValue = this.value;
      let currentValue = this.value;
      handle.focus();
      event.preventDefault();
      drag(container, {
        onMove: (x2) => {
          this.hue = clamp2(x2 / width * 360, 0, 360);
          this.syncValues();
          if (this.value !== currentValue) {
            currentValue = this.value;
            this.emit("sl-input");
          }
        },
        onStop: () => {
          if (this.value !== initialValue) {
            initialValue = this.value;
            this.emit("sl-change");
          }
        },
        initialEvent: event
      });
    }
    handleGridDrag(event) {
      const grid = this.shadowRoot.querySelector(".color-picker__grid");
      const handle = grid.querySelector(".color-picker__grid-handle");
      const { width, height } = grid.getBoundingClientRect();
      let initialValue = this.value;
      let currentValue = this.value;
      handle.focus();
      event.preventDefault();
      this.isDraggingGridHandle = true;
      drag(grid, {
        onMove: (x2, y4) => {
          this.saturation = clamp2(x2 / width * 100, 0, 100);
          this.brightness = clamp2(100 - y4 / height * 100, 0, 100);
          this.syncValues();
          if (this.value !== currentValue) {
            currentValue = this.value;
            this.emit("sl-input");
          }
        },
        onStop: () => {
          this.isDraggingGridHandle = false;
          if (this.value !== initialValue) {
            initialValue = this.value;
            this.emit("sl-change");
          }
        },
        initialEvent: event
      });
    }
    handleAlphaKeyDown(event) {
      const increment = event.shiftKey ? 10 : 1;
      const oldValue = this.value;
      if (event.key === "ArrowLeft") {
        event.preventDefault();
        this.alpha = clamp2(this.alpha - increment, 0, 100);
        this.syncValues();
      }
      if (event.key === "ArrowRight") {
        event.preventDefault();
        this.alpha = clamp2(this.alpha + increment, 0, 100);
        this.syncValues();
      }
      if (event.key === "Home") {
        event.preventDefault();
        this.alpha = 0;
        this.syncValues();
      }
      if (event.key === "End") {
        event.preventDefault();
        this.alpha = 100;
        this.syncValues();
      }
      if (this.value !== oldValue) {
        this.emit("sl-change");
        this.emit("sl-input");
      }
    }
    handleHueKeyDown(event) {
      const increment = event.shiftKey ? 10 : 1;
      const oldValue = this.value;
      if (event.key === "ArrowLeft") {
        event.preventDefault();
        this.hue = clamp2(this.hue - increment, 0, 360);
        this.syncValues();
      }
      if (event.key === "ArrowRight") {
        event.preventDefault();
        this.hue = clamp2(this.hue + increment, 0, 360);
        this.syncValues();
      }
      if (event.key === "Home") {
        event.preventDefault();
        this.hue = 0;
        this.syncValues();
      }
      if (event.key === "End") {
        event.preventDefault();
        this.hue = 360;
        this.syncValues();
      }
      if (this.value !== oldValue) {
        this.emit("sl-change");
        this.emit("sl-input");
      }
    }
    handleGridKeyDown(event) {
      const increment = event.shiftKey ? 10 : 1;
      const oldValue = this.value;
      if (event.key === "ArrowLeft") {
        event.preventDefault();
        this.saturation = clamp2(this.saturation - increment, 0, 100);
        this.syncValues();
      }
      if (event.key === "ArrowRight") {
        event.preventDefault();
        this.saturation = clamp2(this.saturation + increment, 0, 100);
        this.syncValues();
      }
      if (event.key === "ArrowUp") {
        event.preventDefault();
        this.brightness = clamp2(this.brightness + increment, 0, 100);
        this.syncValues();
      }
      if (event.key === "ArrowDown") {
        event.preventDefault();
        this.brightness = clamp2(this.brightness - increment, 0, 100);
        this.syncValues();
      }
      if (this.value !== oldValue) {
        this.emit("sl-change");
        this.emit("sl-input");
      }
    }
    handleInputChange(event) {
      const target = event.target;
      const oldValue = this.value;
      event.stopPropagation();
      if (this.input.value) {
        this.setColor(target.value);
        target.value = this.value;
      } else {
        this.value = "";
      }
      if (this.value !== oldValue) {
        this.emit("sl-change");
        this.emit("sl-input");
      }
    }
    handleInputInput(event) {
      this.formControlController.updateValidity();
      event.stopPropagation();
    }
    handleInputKeyDown(event) {
      if (event.key === "Enter") {
        const oldValue = this.value;
        if (this.input.value) {
          this.setColor(this.input.value);
          this.input.value = this.value;
          if (this.value !== oldValue) {
            this.emit("sl-change");
            this.emit("sl-input");
          }
          setTimeout(() => this.input.select());
        } else {
          this.hue = 0;
        }
      }
    }
    handleInputInvalid(event) {
      this.formControlController.setValidity(false);
      this.formControlController.emitInvalidEvent(event);
    }
    handleTouchMove(event) {
      event.preventDefault();
    }
    parseColor(colorString) {
      const color = new TinyColor(colorString);
      if (!color.isValid) {
        return null;
      }
      const hslColor = color.toHsl();
      const hsl = {
        h: hslColor.h,
        s: hslColor.s * 100,
        l: hslColor.l * 100,
        a: hslColor.a
      };
      const rgb = color.toRgb();
      const hex = color.toHexString();
      const hexa = color.toHex8String();
      const hsvColor = color.toHsv();
      const hsv = {
        h: hsvColor.h,
        s: hsvColor.s * 100,
        v: hsvColor.v * 100,
        a: hsvColor.a
      };
      return {
        hsl: {
          h: hsl.h,
          s: hsl.s,
          l: hsl.l,
          string: this.setLetterCase(`hsl(${Math.round(hsl.h)}, ${Math.round(hsl.s)}%, ${Math.round(hsl.l)}%)`)
        },
        hsla: {
          h: hsl.h,
          s: hsl.s,
          l: hsl.l,
          a: hsl.a,
          string: this.setLetterCase(
            `hsla(${Math.round(hsl.h)}, ${Math.round(hsl.s)}%, ${Math.round(hsl.l)}%, ${hsl.a.toFixed(2).toString()})`
          )
        },
        hsv: {
          h: hsv.h,
          s: hsv.s,
          v: hsv.v,
          string: this.setLetterCase(`hsv(${Math.round(hsv.h)}, ${Math.round(hsv.s)}%, ${Math.round(hsv.v)}%)`)
        },
        hsva: {
          h: hsv.h,
          s: hsv.s,
          v: hsv.v,
          a: hsv.a,
          string: this.setLetterCase(
            `hsva(${Math.round(hsv.h)}, ${Math.round(hsv.s)}%, ${Math.round(hsv.v)}%, ${hsv.a.toFixed(2).toString()})`
          )
        },
        rgb: {
          r: rgb.r,
          g: rgb.g,
          b: rgb.b,
          string: this.setLetterCase(`rgb(${Math.round(rgb.r)}, ${Math.round(rgb.g)}, ${Math.round(rgb.b)})`)
        },
        rgba: {
          r: rgb.r,
          g: rgb.g,
          b: rgb.b,
          a: rgb.a,
          string: this.setLetterCase(
            `rgba(${Math.round(rgb.r)}, ${Math.round(rgb.g)}, ${Math.round(rgb.b)}, ${rgb.a.toFixed(2).toString()})`
          )
        },
        hex: this.setLetterCase(hex),
        hexa: this.setLetterCase(hexa)
      };
    }
    setColor(colorString) {
      const newColor = this.parseColor(colorString);
      if (newColor === null) {
        return false;
      }
      this.hue = newColor.hsva.h;
      this.saturation = newColor.hsva.s;
      this.brightness = newColor.hsva.v;
      this.alpha = this.opacity ? newColor.hsva.a * 100 : 100;
      this.syncValues();
      return true;
    }
    setLetterCase(string) {
      if (typeof string !== "string") {
        return "";
      }
      return this.uppercase ? string.toUpperCase() : string.toLowerCase();
    }
    async syncValues() {
      const currentColor = this.parseColor(
        `hsva(${this.hue}, ${this.saturation}%, ${this.brightness}%, ${this.alpha / 100})`
      );
      if (currentColor === null) {
        return;
      }
      if (this.format === "hsl") {
        this.inputValue = this.opacity ? currentColor.hsla.string : currentColor.hsl.string;
      } else if (this.format === "rgb") {
        this.inputValue = this.opacity ? currentColor.rgba.string : currentColor.rgb.string;
      } else if (this.format === "hsv") {
        this.inputValue = this.opacity ? currentColor.hsva.string : currentColor.hsv.string;
      } else {
        this.inputValue = this.opacity ? currentColor.hexa : currentColor.hex;
      }
      this.isSafeValue = true;
      this.value = this.inputValue;
      await this.updateComplete;
      this.isSafeValue = false;
    }
    handleAfterHide() {
      this.previewButton.classList.remove("color-picker__preview-color--copied");
    }
    handleEyeDropper() {
      if (!hasEyeDropper) {
        return;
      }
      const eyeDropper = new EyeDropper();
      eyeDropper.open().then((colorSelectionResult) => {
        const oldValue = this.value;
        this.setColor(colorSelectionResult.sRGBHex);
        if (this.value !== oldValue) {
          this.emit("sl-change");
          this.emit("sl-input");
        }
      }).catch(() => {
      });
    }
    selectSwatch(color) {
      const oldValue = this.value;
      if (!this.disabled) {
        this.setColor(color);
        if (this.value !== oldValue) {
          this.emit("sl-change");
          this.emit("sl-input");
        }
      }
    }
    /** Generates a hex string from HSV values. Hue must be 0-360. All other arguments must be 0-100. */
    getHexString(hue, saturation, brightness, alpha = 100) {
      const color = new TinyColor(`hsva(${hue}, ${saturation}%, ${brightness}%, ${alpha / 100})`);
      if (!color.isValid) {
        return "";
      }
      return color.toHex8String();
    }
    // Prevents nested components from leaking events
    stopNestedEventPropagation(event) {
      event.stopImmediatePropagation();
    }
    handleFormatChange() {
      this.syncValues();
    }
    handleOpacityChange() {
      this.alpha = 100;
    }
    handleValueChange(oldValue, newValue) {
      this.isEmpty = !newValue;
      if (!newValue) {
        this.hue = 0;
        this.saturation = 0;
        this.brightness = 100;
        this.alpha = 100;
      }
      if (!this.isSafeValue) {
        const newColor = this.parseColor(newValue);
        if (newColor !== null) {
          this.inputValue = this.value;
          this.hue = newColor.hsva.h;
          this.saturation = newColor.hsva.s;
          this.brightness = newColor.hsva.v;
          this.alpha = newColor.hsva.a * 100;
          this.syncValues();
        } else {
          this.inputValue = oldValue != null ? oldValue : "";
        }
      }
    }
    /** Sets focus on the color picker. */
    focus(options) {
      if (this.inline) {
        this.base.focus(options);
      } else {
        this.trigger.focus(options);
      }
    }
    /** Removes focus from the color picker. */
    blur() {
      var _a;
      const elementToBlur = this.inline ? this.base : this.trigger;
      if (this.hasFocus) {
        elementToBlur.focus({ preventScroll: true });
        elementToBlur.blur();
      }
      if ((_a = this.dropdown) == null ? void 0 : _a.open) {
        this.dropdown.hide();
      }
    }
    /** Returns the current value as a string in the specified format. */
    getFormattedValue(format = "hex") {
      const currentColor = this.parseColor(
        `hsva(${this.hue}, ${this.saturation}%, ${this.brightness}%, ${this.alpha / 100})`
      );
      if (currentColor === null) {
        return "";
      }
      switch (format) {
        case "hex":
          return currentColor.hex;
        case "hexa":
          return currentColor.hexa;
        case "rgb":
          return currentColor.rgb.string;
        case "rgba":
          return currentColor.rgba.string;
        case "hsl":
          return currentColor.hsl.string;
        case "hsla":
          return currentColor.hsla.string;
        case "hsv":
          return currentColor.hsv.string;
        case "hsva":
          return currentColor.hsva.string;
        default:
          return "";
      }
    }
    /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
    checkValidity() {
      return this.input.checkValidity();
    }
    /** Gets the associated form, if one exists. */
    getForm() {
      return this.formControlController.getForm();
    }
    /** Checks for validity and shows the browser's validation message if the control is invalid. */
    reportValidity() {
      if (!this.inline && !this.validity.valid) {
        this.dropdown.show();
        this.addEventListener("sl-after-show", () => this.input.reportValidity(), { once: true });
        if (!this.disabled) {
          this.formControlController.emitInvalidEvent();
        }
        return false;
      }
      return this.input.reportValidity();
    }
    /** Sets a custom validation message. Pass an empty string to restore validity. */
    setCustomValidity(message) {
      this.input.setCustomValidity(message);
      this.formControlController.updateValidity();
    }
    render() {
      const gridHandleX = this.saturation;
      const gridHandleY = 100 - this.brightness;
      const swatches = Array.isArray(this.swatches) ? this.swatches : this.swatches.split(";").filter((color) => color.trim() !== "");
      const colorPicker2 = x`
      <div
        part="base"
        class=${e10({
        "color-picker": true,
        "color-picker--inline": this.inline,
        "color-picker--disabled": this.disabled,
        "color-picker--focused": this.hasFocus
      })}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-labelledby="label"
        tabindex=${this.inline ? "0" : "-1"}
      >
        ${this.inline ? x`
              <sl-visually-hidden id="label">
                <slot name="label">${this.label}</slot>
              </sl-visually-hidden>
            ` : null}

        <div
          part="grid"
          class="color-picker__grid"
          style=${o12({ backgroundColor: this.getHexString(this.hue, 100, 100) })}
          @pointerdown=${this.handleGridDrag}
          @touchmove=${this.handleTouchMove}
        >
          <span
            part="grid-handle"
            class=${e10({
        "color-picker__grid-handle": true,
        "color-picker__grid-handle--dragging": this.isDraggingGridHandle
      })}
            style=${o12({
        top: `${gridHandleY}%`,
        left: `${gridHandleX}%`,
        backgroundColor: this.getHexString(this.hue, this.saturation, this.brightness, this.alpha)
      })}
            role="application"
            aria-label="HSV"
            tabindex=${o11(this.disabled ? void 0 : "0")}
            @keydown=${this.handleGridKeyDown}
          ></span>
        </div>

        <div class="color-picker__controls">
          <div class="color-picker__sliders">
            <div
              part="slider hue-slider"
              class="color-picker__hue color-picker__slider"
              @pointerdown=${this.handleHueDrag}
              @touchmove=${this.handleTouchMove}
            >
              <span
                part="slider-handle hue-slider-handle"
                class="color-picker__slider-handle"
                style=${o12({
        left: `${this.hue === 0 ? 0 : 100 / (360 / this.hue)}%`
      })}
                role="slider"
                aria-label="hue"
                aria-orientation="horizontal"
                aria-valuemin="0"
                aria-valuemax="360"
                aria-valuenow=${`${Math.round(this.hue)}`}
                tabindex=${o11(this.disabled ? void 0 : "0")}
                @keydown=${this.handleHueKeyDown}
              ></span>
            </div>

            ${this.opacity ? x`
                  <div
                    part="slider opacity-slider"
                    class="color-picker__alpha color-picker__slider color-picker__transparent-bg"
                    @pointerdown="${this.handleAlphaDrag}"
                    @touchmove=${this.handleTouchMove}
                  >
                    <div
                      class="color-picker__alpha-gradient"
                      style=${o12({
        backgroundImage: `linear-gradient(
                          to right,
                          ${this.getHexString(this.hue, this.saturation, this.brightness, 0)} 0%,
                          ${this.getHexString(this.hue, this.saturation, this.brightness, 100)} 100%
                        )`
      })}
                    ></div>
                    <span
                      part="slider-handle opacity-slider-handle"
                      class="color-picker__slider-handle"
                      style=${o12({
        left: `${this.alpha}%`
      })}
                      role="slider"
                      aria-label="alpha"
                      aria-orientation="horizontal"
                      aria-valuemin="0"
                      aria-valuemax="100"
                      aria-valuenow=${Math.round(this.alpha)}
                      tabindex=${o11(this.disabled ? void 0 : "0")}
                      @keydown=${this.handleAlphaKeyDown}
                    ></span>
                  </div>
                ` : ""}
          </div>

          <button
            type="button"
            part="preview"
            class="color-picker__preview color-picker__transparent-bg"
            aria-label=${this.localize.term("copy")}
            style=${o12({
        "--preview-color": this.getHexString(this.hue, this.saturation, this.brightness, this.alpha)
      })}
            @click=${this.handleCopy}
          ></button>
        </div>

        <div class="color-picker__user-input" aria-live="polite">
          <sl-input
            part="input"
            type="text"
            name=${this.name}
            autocomplete="off"
            autocorrect="off"
            autocapitalize="off"
            spellcheck="false"
            value=${this.isEmpty ? "" : this.inputValue}
            ?required=${this.required}
            ?disabled=${this.disabled}
            aria-label=${this.localize.term("currentValue")}
            @keydown=${this.handleInputKeyDown}
            @sl-change=${this.handleInputChange}
            @sl-input=${this.handleInputInput}
            @sl-invalid=${this.handleInputInvalid}
            @sl-blur=${this.stopNestedEventPropagation}
            @sl-focus=${this.stopNestedEventPropagation}
          ></sl-input>

          <sl-button-group>
            ${!this.noFormatToggle ? x`
                  <sl-button
                    part="format-button"
                    aria-label=${this.localize.term("toggleColorFormat")}
                    exportparts="
                      base:format-button__base,
                      prefix:format-button__prefix,
                      label:format-button__label,
                      suffix:format-button__suffix,
                      caret:format-button__caret
                    "
                    @click=${this.handleFormatToggle}
                    @sl-blur=${this.stopNestedEventPropagation}
                    @sl-focus=${this.stopNestedEventPropagation}
                  >
                    ${this.setLetterCase(this.format)}
                  </sl-button>
                ` : ""}
            ${hasEyeDropper ? x`
                  <sl-button
                    part="eye-dropper-button"
                    exportparts="
                      base:eye-dropper-button__base,
                      prefix:eye-dropper-button__prefix,
                      label:eye-dropper-button__label,
                      suffix:eye-dropper-button__suffix,
                      caret:eye-dropper-button__caret
                    "
                    @click=${this.handleEyeDropper}
                    @sl-blur=${this.stopNestedEventPropagation}
                    @sl-focus=${this.stopNestedEventPropagation}
                  >
                    <sl-icon
                      library="system"
                      name="eyedropper"
                      label=${this.localize.term("selectAColorFromTheScreen")}
                    ></sl-icon>
                  </sl-button>
                ` : ""}
          </sl-button-group>
        </div>

        ${swatches.length > 0 ? x`
              <div part="swatches" class="color-picker__swatches">
                ${swatches.map((swatch) => {
        const parsedColor = this.parseColor(swatch);
        if (!parsedColor) {
          console.error(`Unable to parse swatch color: "${swatch}"`, this);
          return "";
        }
        return x`
                    <div
                      part="swatch"
                      class="color-picker__swatch color-picker__transparent-bg"
                      tabindex=${o11(this.disabled ? void 0 : "0")}
                      role="button"
                      aria-label=${swatch}
                      @click=${() => this.selectSwatch(swatch)}
                      @keydown=${(event) => !this.disabled && event.key === "Enter" && this.setColor(parsedColor.hexa)}
                    >
                      <div
                        class="color-picker__swatch-color"
                        style=${o12({ backgroundColor: parsedColor.hexa })}
                      ></div>
                    </div>
                  `;
      })}
              </div>
            ` : ""}
      </div>
    `;
      if (this.inline) {
        return colorPicker2;
      }
      return x`
      <sl-dropdown
        class="color-dropdown"
        aria-disabled=${this.disabled ? "true" : "false"}
        .containingElement=${this}
        ?disabled=${this.disabled}
        ?hoist=${this.hoist}
        @sl-after-hide=${this.handleAfterHide}
      >
        <button
          part="trigger"
          slot="trigger"
          class=${e10({
        "color-dropdown__trigger": true,
        "color-dropdown__trigger--disabled": this.disabled,
        "color-dropdown__trigger--small": this.size === "small",
        "color-dropdown__trigger--medium": this.size === "medium",
        "color-dropdown__trigger--large": this.size === "large",
        "color-dropdown__trigger--empty": this.isEmpty,
        "color-dropdown__trigger--focused": this.hasFocus,
        "color-picker__transparent-bg": true
      })}
          style=${o12({
        color: this.getHexString(this.hue, this.saturation, this.brightness, this.alpha)
      })}
          type="button"
        >
          <sl-visually-hidden>
            <slot name="label">${this.label}</slot>
          </sl-visually-hidden>
        </button>
        ${colorPicker2}
      </sl-dropdown>
    `;
    }
  };
  SlColorPicker.styles = [component_styles_default, color_picker_styles_default];
  SlColorPicker.dependencies = {
    "sl-button-group": SlButtonGroup,
    "sl-button": SlButton,
    "sl-dropdown": SlDropdown,
    "sl-icon": SlIcon,
    "sl-input": SlInput,
    "sl-visually-hidden": SlVisuallyHidden
  };
  __decorateClass2([
    e6('[part~="base"]')
  ], SlColorPicker.prototype, "base", 2);
  __decorateClass2([
    e6('[part~="input"]')
  ], SlColorPicker.prototype, "input", 2);
  __decorateClass2([
    e6(".color-dropdown")
  ], SlColorPicker.prototype, "dropdown", 2);
  __decorateClass2([
    e6('[part~="preview"]')
  ], SlColorPicker.prototype, "previewButton", 2);
  __decorateClass2([
    e6('[part~="trigger"]')
  ], SlColorPicker.prototype, "trigger", 2);
  __decorateClass2([
    r6()
  ], SlColorPicker.prototype, "hasFocus", 2);
  __decorateClass2([
    r6()
  ], SlColorPicker.prototype, "isDraggingGridHandle", 2);
  __decorateClass2([
    r6()
  ], SlColorPicker.prototype, "isEmpty", 2);
  __decorateClass2([
    r6()
  ], SlColorPicker.prototype, "inputValue", 2);
  __decorateClass2([
    r6()
  ], SlColorPicker.prototype, "hue", 2);
  __decorateClass2([
    r6()
  ], SlColorPicker.prototype, "saturation", 2);
  __decorateClass2([
    r6()
  ], SlColorPicker.prototype, "brightness", 2);
  __decorateClass2([
    r6()
  ], SlColorPicker.prototype, "alpha", 2);
  __decorateClass2([
    n5()
  ], SlColorPicker.prototype, "value", 2);
  __decorateClass2([
    defaultValue()
  ], SlColorPicker.prototype, "defaultValue", 2);
  __decorateClass2([
    n5()
  ], SlColorPicker.prototype, "label", 2);
  __decorateClass2([
    n5()
  ], SlColorPicker.prototype, "format", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlColorPicker.prototype, "inline", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlColorPicker.prototype, "size", 2);
  __decorateClass2([
    n5({ attribute: "no-format-toggle", type: Boolean })
  ], SlColorPicker.prototype, "noFormatToggle", 2);
  __decorateClass2([
    n5()
  ], SlColorPicker.prototype, "name", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlColorPicker.prototype, "disabled", 2);
  __decorateClass2([
    n5({ type: Boolean })
  ], SlColorPicker.prototype, "hoist", 2);
  __decorateClass2([
    n5({ type: Boolean })
  ], SlColorPicker.prototype, "opacity", 2);
  __decorateClass2([
    n5({ type: Boolean })
  ], SlColorPicker.prototype, "uppercase", 2);
  __decorateClass2([
    n5()
  ], SlColorPicker.prototype, "swatches", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlColorPicker.prototype, "form", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlColorPicker.prototype, "required", 2);
  __decorateClass2([
    t4({ passive: false })
  ], SlColorPicker.prototype, "handleTouchMove", 1);
  __decorateClass2([
    watch("format", { waitUntilFirstUpdate: true })
  ], SlColorPicker.prototype, "handleFormatChange", 1);
  __decorateClass2([
    watch("opacity", { waitUntilFirstUpdate: true })
  ], SlColorPicker.prototype, "handleOpacityChange", 1);
  __decorateClass2([
    watch("value")
  ], SlColorPicker.prototype, "handleValueChange", 1);

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.BQVAQ53I.js
  SlColorPicker.define("sl-color-picker");

  // node_modules/@jsfe/shoelace/dist/esm/widgets/color-picker.js
  var colorPicker = (options) => x`
	<div class="theme-shoelace widget-color-picker">
		<label>${options.label}</label>
		<sl-color-picker
			.label=${options.label ?? ""}
			value=${options.value ? String(options.value) : ""}
			@sl-change=${(event) => {
    const newValue = event.target.value;
    options.valueChangedCallback?.(newValue);
  }}
			.disabled=${options.disabled}
		></sl-color-picker>

		<div class="widget-color-picker__description">${options.helpText}</div>
	</div>
`;

  // node_modules/@jsfe/shoelace/dist/esm/widgets/date.js
  var date = (options) => x`
	<sl-input
		type=${options.type}
		.label=${options.label ?? ""}
		.helpText=${options.helpText ?? ""}
		value=${options.value ? options.value : ""}
		.name=${options.id}
		.id=${options.id}
		.required=${options.required ?? false}
		@sl-input=${(event) => {
    let { value: value2 } = event.target;
    if (options.type === "datetime-local") {
      value2 = new Date(value2);
    }
    options.valueChangedCallback?.(value2);
  }}
		.disabled=${options.disabled}
		.readonly=${options.readonly}
	>
	</sl-input>
`;

  // node_modules/@jsfe/shoelace/dist/esm/widgets/number.js
  var number = (options) => x` <!--  -->
		<sl-input
			type="number"
			value=${o11(options.value)}
			step=${o11(options.step)}
			min=${o11(options.min)}
			max=${o11(options.max)}
			.label=${options.label}
			.helpText=${options.helpText}
			placeholder=${options.placeholder}
			.name=${options.id}
			.id=${options.id}
			.required=${options.required}
			@sl-input=${(event) => {
    const newValue = event.target.valueAsNumber;
    console.log(newValue);
    options.valueChangedCallback?.(newValue);
  }}
			.disabled=${options.disabled}
			.readonly=${options.readonly}
		></sl-input>`;

  // node_modules/@jsfe/shoelace/dist/esm/widgets/object.js
  var object = (options) => x`
	<fieldset
		id=${options.id}
		class="theme-shoelace widget-object widget-fieldset level-${options.level}"
		part="object"
	>
		${options.label ? x`<legend>${options.label}</legend>` : ``}
		<!-- -->
		${options.helpText ? x`<div class="widget-fieldset__description">
					${options.helpText}
			  </div>` : E2}
		<!--  -->
		${options.children}
	</fieldset>
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.FKMWLPHV.js
  var radio_styles_default = i3`
  :host {
    display: block;
  }

  :host(:focus-visible) {
    outline: 0px;
  }

  .radio {
    display: inline-flex;
    align-items: top;
    font-family: var(--sl-input-font-family);
    font-size: var(--sl-input-font-size-medium);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .radio--small {
    --toggle-size: var(--sl-toggle-size-small);
    font-size: var(--sl-input-font-size-small);
  }

  .radio--medium {
    --toggle-size: var(--sl-toggle-size-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .radio--large {
    --toggle-size: var(--sl-toggle-size-large);
    font-size: var(--sl-input-font-size-large);
  }

  .radio__checked-icon {
    display: inline-flex;
    width: var(--toggle-size);
    height: var(--toggle-size);
  }

  .radio__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--toggle-size);
    height: var(--toggle-size);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
    border-radius: 50%;
    background-color: var(--sl-input-background-color);
    color: transparent;
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
  }

  .radio__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  /* Hover */
  .radio:not(.radio--checked):not(.radio--disabled) .radio__control:hover {
    border-color: var(--sl-input-border-color-hover);
    background-color: var(--sl-input-background-color-hover);
  }

  /* Checked */
  .radio--checked .radio__control {
    color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
  }

  /* Checked + hover */
  .radio.radio--checked:not(.radio--disabled) .radio__control:hover {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
  }

  /* Checked + focus */
  :host(:focus-visible) .radio__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .radio--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When the control isn't checked, hide the circle for Windows High Contrast mode a11y */
  .radio:not(.radio--checked) svg circle {
    opacity: 0;
  }

  .radio__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    line-height: var(--toggle-size);
    margin-inline-start: 0.5em;
    user-select: none;
    -webkit-user-select: none;
  }
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.ZSG32LO3.js
  var SlRadio = class extends ShoelaceElement {
    constructor() {
      super();
      this.checked = false;
      this.hasFocus = false;
      this.size = "medium";
      this.disabled = false;
      this.handleBlur = () => {
        this.hasFocus = false;
        this.emit("sl-blur");
      };
      this.handleClick = () => {
        if (!this.disabled) {
          this.checked = true;
        }
      };
      this.handleFocus = () => {
        this.hasFocus = true;
        this.emit("sl-focus");
      };
      this.addEventListener("blur", this.handleBlur);
      this.addEventListener("click", this.handleClick);
      this.addEventListener("focus", this.handleFocus);
    }
    connectedCallback() {
      super.connectedCallback();
      this.setInitialAttributes();
    }
    setInitialAttributes() {
      this.setAttribute("role", "radio");
      this.setAttribute("tabindex", "-1");
      this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
    }
    handleCheckedChange() {
      this.setAttribute("aria-checked", this.checked ? "true" : "false");
      this.setAttribute("tabindex", this.checked ? "0" : "-1");
    }
    handleDisabledChange() {
      this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
    }
    render() {
      return x`
      <span
        part="base"
        class=${e10({
        radio: true,
        "radio--checked": this.checked,
        "radio--disabled": this.disabled,
        "radio--focused": this.hasFocus,
        "radio--small": this.size === "small",
        "radio--medium": this.size === "medium",
        "radio--large": this.size === "large"
      })}
      >
        <span part="${`control${this.checked ? " control--checked" : ""}`}" class="radio__control">
          ${this.checked ? x` <sl-icon part="checked-icon" class="radio__checked-icon" library="system" name="radio"></sl-icon> ` : ""}
        </span>

        <slot part="label" class="radio__label"></slot>
      </span>
    `;
    }
  };
  SlRadio.styles = [component_styles_default, radio_styles_default];
  SlRadio.dependencies = { "sl-icon": SlIcon };
  __decorateClass2([
    r6()
  ], SlRadio.prototype, "checked", 2);
  __decorateClass2([
    r6()
  ], SlRadio.prototype, "hasFocus", 2);
  __decorateClass2([
    n5()
  ], SlRadio.prototype, "value", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlRadio.prototype, "size", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlRadio.prototype, "disabled", 2);
  __decorateClass2([
    watch("checked")
  ], SlRadio.prototype, "handleCheckedChange", 1);
  __decorateClass2([
    watch("disabled", { waitUntilFirstUpdate: true })
  ], SlRadio.prototype, "handleDisabledChange", 1);

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.MSKEYBDI.js
  SlRadio.define("sl-radio");

  // node_modules/@jsfe/shoelace/dist/esm/widgets/radio-group.js
  var radioGroup = (options) => x`
	<sl-radio-group
		class="theme-shoelace widget-radio-group"
		size="medium"
		.label=${options.label ?? ""}
		.helpText=${options.helpText ?? ""}
		value=${typeof options.value !== "undefined" ? String(options.value) : ""}
		.name=${options.id}
		.required=${options.required ?? false}
		@sl-change=${(event) => {
    let newValue = event.target.value;
    if (options.type === "number") {
      newValue = Number(newValue);
    }
    options.valueChangedCallback?.(newValue);
  }}
	>
		${options.enum?.map((enumVal) => x`<sl-radio .disabled=${options.disabled} value=${String(enumVal)}
					>${enumVal}</sl-radio
				>`)}
	</sl-radio-group>
`;

  // node_modules/@jsfe/shoelace/dist/esm/widgets/radio-group-boolean.js
  var radioGroupBoolean = (options) => x`
	<!-- TODO: Disabled state (not supported by Shoelace for this specific field despite the docs?) -->
	<sl-radio-group
		class="theme-shoelace widget-radio-group-boolean"
		size="medium"
		.label=${options.label ?? ""}
		.helpText=${options.helpText ?? ""}
		value=${typeof options.value !== "undefined" ? String(options.value) : ""}
		.name=${options.id}
		.required=${options.required ?? false}
		@sl-change=${(event) => {
    const newValue = event.target.value;
    options.valueChangedCallback?.(newValue === "true");
  }}
	>
		<sl-radio .disabled=${options.disabled} value="true"
			>${options.trueLabel ?? "Yes"}</sl-radio
		>
		<sl-radio .disabled=${options.disabled} value="false"
			>${options.falseLabel ?? "No"}</sl-radio
		>
	</sl-radio-group>
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.5D6IT2SR.js
  var range_styles_default = i3`
  :host {
    --thumb-size: 20px;
    --tooltip-offset: 10px;
    --track-color-active: var(--sl-color-neutral-200);
    --track-color-inactive: var(--sl-color-neutral-200);
    --track-active-offset: 0%;
    --track-height: 6px;

    display: block;
  }

  .range {
    position: relative;
  }

  .range__control {
    --percent: 0%;
    -webkit-appearance: none;
    border-radius: 3px;
    width: 100%;
    height: var(--track-height);
    background: transparent;
    line-height: var(--sl-input-height-medium);
    vertical-align: middle;
    margin: 0;

    background-image: linear-gradient(
      to right,
      var(--track-color-inactive) 0%,
      var(--track-color-inactive) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) 100%
    );
  }

  .range--rtl .range__control {
    background-image: linear-gradient(
      to left,
      var(--track-color-inactive) 0%,
      var(--track-color-inactive) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) min(var(--percent), var(--track-active-offset)),
      var(--track-color-active) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) max(var(--percent), var(--track-active-offset)),
      var(--track-color-inactive) 100%
    );
  }

  /* Webkit */
  .range__control::-webkit-slider-runnable-track {
    width: 100%;
    height: var(--track-height);
    border-radius: 3px;
    border: none;
  }

  .range__control::-webkit-slider-thumb {
    border: none;
    width: var(--thumb-size);
    height: var(--thumb-size);
    border-radius: 50%;
    background-color: var(--sl-color-primary-600);
    border: solid var(--sl-input-border-width) var(--sl-color-primary-600);
    -webkit-appearance: none;
    margin-top: calc(var(--thumb-size) / -2 + var(--track-height) / 2);
    cursor: pointer;
  }

  .range__control:enabled::-webkit-slider-thumb:hover {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
  }

  .range__control:enabled:focus-visible::-webkit-slider-thumb {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .range__control:enabled::-webkit-slider-thumb:active {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    cursor: grabbing;
  }

  /* Firefox */
  .range__control::-moz-focus-outer {
    border: 0;
  }

  .range__control::-moz-range-progress {
    background-color: var(--track-color-active);
    border-radius: 3px;
    height: var(--track-height);
  }

  .range__control::-moz-range-track {
    width: 100%;
    height: var(--track-height);
    background-color: var(--track-color-inactive);
    border-radius: 3px;
    border: none;
  }

  .range__control::-moz-range-thumb {
    border: none;
    height: var(--thumb-size);
    width: var(--thumb-size);
    border-radius: 50%;
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
    cursor: pointer;
  }

  .range__control:enabled::-moz-range-thumb:hover {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
  }

  .range__control:enabled:focus-visible::-moz-range-thumb {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .range__control:enabled::-moz-range-thumb:active {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    cursor: grabbing;
  }

  /* States */
  .range__control:focus-visible {
    outline: none;
  }

  .range__control:disabled {
    opacity: 0.5;
  }

  .range__control:disabled::-webkit-slider-thumb {
    cursor: not-allowed;
  }

  .range__control:disabled::-moz-range-thumb {
    cursor: not-allowed;
  }

  /* Tooltip output */
  .range__tooltip {
    position: absolute;
    z-index: var(--sl-z-index-tooltip);
    left: 0;
    border-radius: var(--sl-tooltip-border-radius);
    background-color: var(--sl-tooltip-background-color);
    font-family: var(--sl-tooltip-font-family);
    font-size: var(--sl-tooltip-font-size);
    font-weight: var(--sl-tooltip-font-weight);
    line-height: var(--sl-tooltip-line-height);
    color: var(--sl-tooltip-color);
    opacity: 0;
    padding: var(--sl-tooltip-padding);
    transition: var(--sl-transition-fast) opacity;
    pointer-events: none;
  }

  .range__tooltip:after {
    content: '';
    position: absolute;
    width: 0;
    height: 0;
    left: 50%;
    translate: calc(-1 * var(--sl-tooltip-arrow-size));
  }

  .range--tooltip-visible .range__tooltip {
    opacity: 1;
  }

  /* Tooltip on top */
  .range--tooltip-top .range__tooltip {
    top: calc(-1 * var(--thumb-size) - var(--tooltip-offset));
  }

  .range--tooltip-top .range__tooltip:after {
    border-top: var(--sl-tooltip-arrow-size) solid var(--sl-tooltip-background-color);
    border-left: var(--sl-tooltip-arrow-size) solid transparent;
    border-right: var(--sl-tooltip-arrow-size) solid transparent;
    top: 100%;
  }

  /* Tooltip on bottom */
  .range--tooltip-bottom .range__tooltip {
    bottom: calc(-1 * var(--thumb-size) - var(--tooltip-offset));
  }

  .range--tooltip-bottom .range__tooltip:after {
    border-bottom: var(--sl-tooltip-arrow-size) solid var(--sl-tooltip-background-color);
    border-left: var(--sl-tooltip-arrow-size) solid transparent;
    border-right: var(--sl-tooltip-arrow-size) solid transparent;
    bottom: 100%;
  }

  @media (forced-colors: active) {
    .range__control,
    .range__tooltip {
      border: solid 1px transparent;
    }

    .range__control::-webkit-slider-thumb {
      border: solid 1px transparent;
    }

    .range__control::-moz-range-thumb {
      border: solid 1px transparent;
    }

    .range__tooltip:after {
      display: none;
    }
  }
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.HRYVEIKV.js
  var SlRange = class extends ShoelaceElement {
    constructor() {
      super(...arguments);
      this.formControlController = new FormControlController(this);
      this.hasSlotController = new HasSlotController(this, "help-text", "label");
      this.localize = new LocalizeController2(this);
      this.hasFocus = false;
      this.hasTooltip = false;
      this.title = "";
      this.name = "";
      this.value = 0;
      this.label = "";
      this.helpText = "";
      this.disabled = false;
      this.min = 0;
      this.max = 100;
      this.step = 1;
      this.tooltip = "top";
      this.tooltipFormatter = (value2) => value2.toString();
      this.form = "";
      this.defaultValue = 0;
    }
    /** Gets the validity state object */
    get validity() {
      return this.input.validity;
    }
    /** Gets the validation message */
    get validationMessage() {
      return this.input.validationMessage;
    }
    connectedCallback() {
      super.connectedCallback();
      this.resizeObserver = new ResizeObserver(() => this.syncRange());
      if (this.value < this.min) {
        this.value = this.min;
      }
      if (this.value > this.max) {
        this.value = this.max;
      }
      this.updateComplete.then(() => {
        this.syncRange();
        this.resizeObserver.observe(this.input);
      });
    }
    disconnectedCallback() {
      var _a;
      super.disconnectedCallback();
      (_a = this.resizeObserver) == null ? void 0 : _a.unobserve(this.input);
    }
    handleChange() {
      this.emit("sl-change");
    }
    handleInput() {
      this.value = parseFloat(this.input.value);
      this.emit("sl-input");
      this.syncRange();
    }
    handleBlur() {
      this.hasFocus = false;
      this.hasTooltip = false;
      this.emit("sl-blur");
    }
    handleFocus() {
      this.hasFocus = true;
      this.hasTooltip = true;
      this.emit("sl-focus");
    }
    handleThumbDragStart() {
      this.hasTooltip = true;
    }
    handleThumbDragEnd() {
      this.hasTooltip = false;
    }
    syncProgress(percent) {
      this.input.style.setProperty("--percent", `${percent * 100}%`);
    }
    syncTooltip(percent) {
      if (this.output !== null) {
        const inputWidth = this.input.offsetWidth;
        const tooltipWidth = this.output.offsetWidth;
        const thumbSize = getComputedStyle(this.input).getPropertyValue("--thumb-size");
        const isRtl = this.localize.dir() === "rtl";
        const percentAsWidth = inputWidth * percent;
        if (isRtl) {
          const x2 = `${inputWidth - percentAsWidth}px + ${percent} * ${thumbSize}`;
          this.output.style.translate = `calc((${x2} - ${tooltipWidth / 2}px - ${thumbSize} / 2))`;
        } else {
          const x2 = `${percentAsWidth}px - ${percent} * ${thumbSize}`;
          this.output.style.translate = `calc(${x2} - ${tooltipWidth / 2}px + ${thumbSize} / 2)`;
        }
      }
    }
    handleValueChange() {
      this.formControlController.updateValidity();
      this.input.value = this.value.toString();
      this.value = parseFloat(this.input.value);
      this.syncRange();
    }
    handleDisabledChange() {
      this.formControlController.setValidity(this.disabled);
    }
    syncRange() {
      const percent = Math.max(0, (this.value - this.min) / (this.max - this.min));
      this.syncProgress(percent);
      if (this.tooltip !== "none" && this.hasTooltip) {
        this.updateComplete.then(() => this.syncTooltip(percent));
      }
    }
    handleInvalid(event) {
      this.formControlController.setValidity(false);
      this.formControlController.emitInvalidEvent(event);
    }
    /** Sets focus on the range. */
    focus(options) {
      this.input.focus(options);
    }
    /** Removes focus from the range. */
    blur() {
      this.input.blur();
    }
    /** Increments the value of the range by the value of the step attribute. */
    stepUp() {
      this.input.stepUp();
      if (this.value !== Number(this.input.value)) {
        this.value = Number(this.input.value);
      }
    }
    /** Decrements the value of the range by the value of the step attribute. */
    stepDown() {
      this.input.stepDown();
      if (this.value !== Number(this.input.value)) {
        this.value = Number(this.input.value);
      }
    }
    /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
    checkValidity() {
      return this.input.checkValidity();
    }
    /** Gets the associated form, if one exists. */
    getForm() {
      return this.formControlController.getForm();
    }
    /** Checks for validity and shows the browser's validation message if the control is invalid. */
    reportValidity() {
      return this.input.reportValidity();
    }
    /** Sets a custom validation message. Pass an empty string to restore validity. */
    setCustomValidity(message) {
      this.input.setCustomValidity(message);
      this.formControlController.updateValidity();
    }
    render() {
      const hasLabelSlot = this.hasSlotController.test("label");
      const hasHelpTextSlot = this.hasSlotController.test("help-text");
      const hasLabel = this.label ? true : !!hasLabelSlot;
      const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
      return x`
      <div
        part="form-control"
        class=${e10({
        "form-control": true,
        "form-control--medium": true,
        // range only has one size
        "form-control--has-label": hasLabel,
        "form-control--has-help-text": hasHelpText
      })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${hasLabel ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${e10({
        range: true,
        "range--disabled": this.disabled,
        "range--focused": this.hasFocus,
        "range--rtl": this.localize.dir() === "rtl",
        "range--tooltip-visible": this.hasTooltip,
        "range--tooltip-top": this.tooltip === "top",
        "range--tooltip-bottom": this.tooltip === "bottom"
      })}
            @mousedown=${this.handleThumbDragStart}
            @mouseup=${this.handleThumbDragEnd}
            @touchstart=${this.handleThumbDragStart}
            @touchend=${this.handleThumbDragEnd}
          >
            <input
              part="input"
              id="input"
              class="range__control"
              title=${this.title}
              type="range"
              name=${o11(this.name)}
              ?disabled=${this.disabled}
              min=${o11(this.min)}
              max=${o11(this.max)}
              step=${o11(this.step)}
              .value=${l5(this.value.toString())}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @focus=${this.handleFocus}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @blur=${this.handleBlur}
            />
            ${this.tooltip !== "none" && !this.disabled ? x`
                  <output part="tooltip" class="range__tooltip">
                    ${typeof this.tooltipFormatter === "function" ? this.tooltipFormatter(this.value) : this.value}
                  </output>
                ` : ""}
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
    }
  };
  SlRange.styles = [component_styles_default, form_control_styles_default, range_styles_default];
  __decorateClass2([
    e6(".range__control")
  ], SlRange.prototype, "input", 2);
  __decorateClass2([
    e6(".range__tooltip")
  ], SlRange.prototype, "output", 2);
  __decorateClass2([
    r6()
  ], SlRange.prototype, "hasFocus", 2);
  __decorateClass2([
    r6()
  ], SlRange.prototype, "hasTooltip", 2);
  __decorateClass2([
    n5()
  ], SlRange.prototype, "title", 2);
  __decorateClass2([
    n5()
  ], SlRange.prototype, "name", 2);
  __decorateClass2([
    n5({ type: Number })
  ], SlRange.prototype, "value", 2);
  __decorateClass2([
    n5()
  ], SlRange.prototype, "label", 2);
  __decorateClass2([
    n5({ attribute: "help-text" })
  ], SlRange.prototype, "helpText", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlRange.prototype, "disabled", 2);
  __decorateClass2([
    n5({ type: Number })
  ], SlRange.prototype, "min", 2);
  __decorateClass2([
    n5({ type: Number })
  ], SlRange.prototype, "max", 2);
  __decorateClass2([
    n5({ type: Number })
  ], SlRange.prototype, "step", 2);
  __decorateClass2([
    n5()
  ], SlRange.prototype, "tooltip", 2);
  __decorateClass2([
    n5({ attribute: false })
  ], SlRange.prototype, "tooltipFormatter", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlRange.prototype, "form", 2);
  __decorateClass2([
    defaultValue()
  ], SlRange.prototype, "defaultValue", 2);
  __decorateClass2([
    t4({ passive: true })
  ], SlRange.prototype, "handleThumbDragStart", 1);
  __decorateClass2([
    watch("value", { waitUntilFirstUpdate: true })
  ], SlRange.prototype, "handleValueChange", 1);
  __decorateClass2([
    watch("disabled", { waitUntilFirstUpdate: true })
  ], SlRange.prototype, "handleDisabledChange", 1);
  __decorateClass2([
    watch("hasTooltip", { waitUntilFirstUpdate: true })
  ], SlRange.prototype, "syncRange", 1);

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.CKH4GVK3.js
  SlRange.define("sl-range");

  // node_modules/@jsfe/shoelace/dist/esm/widgets/range.js
  var range = (options) => x` <!--  -->
		<sl-range
			value=${o11(options.value)}
			step=${o11(options.step)}
			min=${o11(options.min)}
			max=${o11(options.max)}
			.label=${options.label}
			.helpText=${options.helpText}
			placeholder=${options.placeholder}
			.name=${options.id}
			.id=${options.id}
			.required=${options.required}
			@sl-input=${(event) => {
    const newValue = event.target.value;
    console.log(newValue);
    options.valueChangedCallback?.(newValue);
  }}
			.disabled=${options.disabled}
		></sl-range>`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.X2WW2TWJ.js
  var rating_styles_default = i3`
  :host {
    --symbol-color: var(--sl-color-neutral-300);
    --symbol-color-active: var(--sl-color-amber-500);
    --symbol-size: 1.2rem;
    --symbol-spacing: var(--sl-spacing-3x-small);

    display: inline-flex;
  }

  .rating {
    position: relative;
    display: inline-flex;
    border-radius: var(--sl-border-radius-medium);
    vertical-align: middle;
  }

  .rating:focus {
    outline: none;
  }

  .rating:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .rating__symbols {
    display: inline-flex;
    position: relative;
    font-size: var(--symbol-size);
    line-height: 0;
    color: var(--symbol-color);
    white-space: nowrap;
    cursor: pointer;
  }

  .rating__symbols > * {
    padding: var(--symbol-spacing);
  }

  .rating__symbol--active,
  .rating__partial--filled {
    color: var(--symbol-color-active);
  }

  .rating__partial-symbol-container {
    position: relative;
  }

  .rating__partial--filled {
    position: absolute;
    top: var(--symbol-spacing);
    left: var(--symbol-spacing);
  }

  .rating__symbol {
    transition: var(--sl-transition-fast) scale;
    pointer-events: none;
  }

  .rating__symbol--hover {
    scale: 1.2;
  }

  .rating--disabled .rating__symbols,
  .rating--readonly .rating__symbols {
    cursor: default;
  }

  .rating--disabled .rating__symbol--hover,
  .rating--readonly .rating__symbol--hover {
    scale: none;
  }

  .rating--disabled {
    opacity: 0.5;
  }

  .rating--disabled .rating__symbols {
    cursor: not-allowed;
  }

  /* Forced colors mode */
  @media (forced-colors: active) {
    .rating__symbol--active {
      color: SelectedItem;
    }
  }
`;

  // node_modules/lit-html/directives/unsafe-html.js
  var e12 = class extends i7 {
    constructor(i11) {
      if (super(i11), this.it = E2, i11.type !== t6.CHILD)
        throw Error(this.constructor.directiveName + "() can only be used in child bindings");
    }
    render(r9) {
      if (r9 === E2 || null == r9)
        return this._t = void 0, this.it = r9;
      if (r9 === T2)
        return r9;
      if ("string" != typeof r9)
        throw Error(this.constructor.directiveName + "() called with a non-string value");
      if (r9 === this.it)
        return this._t;
      this.it = r9;
      const s6 = [r9];
      return s6.raw = s6, this._t = { _$litType$: this.constructor.resultType, strings: s6, values: [] };
    }
  };
  e12.directiveName = "unsafeHTML", e12.resultType = 1;
  var o13 = e8(e12);

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.EOSHXBLN.js
  var SlRating = class extends ShoelaceElement {
    constructor() {
      super(...arguments);
      this.localize = new LocalizeController2(this);
      this.hoverValue = 0;
      this.isHovering = false;
      this.label = "";
      this.value = 0;
      this.max = 5;
      this.precision = 1;
      this.readonly = false;
      this.disabled = false;
      this.getSymbol = () => '<sl-icon name="star-fill" library="system"></sl-icon>';
    }
    getValueFromMousePosition(event) {
      return this.getValueFromXCoordinate(event.clientX);
    }
    getValueFromTouchPosition(event) {
      return this.getValueFromXCoordinate(event.touches[0].clientX);
    }
    getValueFromXCoordinate(coordinate) {
      const isRtl = this.localize.dir() === "rtl";
      const { left, right, width } = this.rating.getBoundingClientRect();
      const value2 = isRtl ? this.roundToPrecision((right - coordinate) / width * this.max, this.precision) : this.roundToPrecision((coordinate - left) / width * this.max, this.precision);
      return clamp2(value2, 0, this.max);
    }
    handleClick(event) {
      if (this.disabled) {
        return;
      }
      this.setValue(this.getValueFromMousePosition(event));
      this.emit("sl-change");
    }
    setValue(newValue) {
      if (this.disabled || this.readonly) {
        return;
      }
      this.value = newValue === this.value ? 0 : newValue;
      this.isHovering = false;
    }
    handleKeyDown(event) {
      const isLtr = this.localize.dir() === "ltr";
      const isRtl = this.localize.dir() === "rtl";
      const oldValue = this.value;
      if (this.disabled || this.readonly) {
        return;
      }
      if (event.key === "ArrowDown" || isLtr && event.key === "ArrowLeft" || isRtl && event.key === "ArrowRight") {
        const decrement = event.shiftKey ? 1 : this.precision;
        this.value = Math.max(0, this.value - decrement);
        event.preventDefault();
      }
      if (event.key === "ArrowUp" || isLtr && event.key === "ArrowRight" || isRtl && event.key === "ArrowLeft") {
        const increment = event.shiftKey ? 1 : this.precision;
        this.value = Math.min(this.max, this.value + increment);
        event.preventDefault();
      }
      if (event.key === "Home") {
        this.value = 0;
        event.preventDefault();
      }
      if (event.key === "End") {
        this.value = this.max;
        event.preventDefault();
      }
      if (this.value !== oldValue) {
        this.emit("sl-change");
      }
    }
    handleMouseEnter(event) {
      this.isHovering = true;
      this.hoverValue = this.getValueFromMousePosition(event);
    }
    handleMouseMove(event) {
      this.hoverValue = this.getValueFromMousePosition(event);
    }
    handleMouseLeave() {
      this.isHovering = false;
    }
    handleTouchStart(event) {
      this.isHovering = true;
      this.hoverValue = this.getValueFromTouchPosition(event);
      event.preventDefault();
    }
    handleTouchMove(event) {
      this.hoverValue = this.getValueFromTouchPosition(event);
    }
    handleTouchEnd(event) {
      this.isHovering = false;
      this.setValue(this.hoverValue);
      this.emit("sl-change");
      event.preventDefault();
    }
    roundToPrecision(numberToRound, precision = 0.5) {
      const multiplier = 1 / precision;
      return Math.ceil(numberToRound * multiplier) / multiplier;
    }
    handleHoverValueChange() {
      this.emit("sl-hover", {
        detail: {
          phase: "move",
          value: this.hoverValue
        }
      });
    }
    handleIsHoveringChange() {
      this.emit("sl-hover", {
        detail: {
          phase: this.isHovering ? "start" : "end",
          value: this.hoverValue
        }
      });
    }
    /** Sets focus on the rating. */
    focus(options) {
      this.rating.focus(options);
    }
    /** Removes focus from the rating. */
    blur() {
      this.rating.blur();
    }
    render() {
      const isRtl = this.localize.dir() === "rtl";
      const counter = Array.from(Array(this.max).keys());
      let displayValue = 0;
      if (this.disabled || this.readonly) {
        displayValue = this.value;
      } else {
        displayValue = this.isHovering ? this.hoverValue : this.value;
      }
      return x`
      <div
        part="base"
        class=${e10({
        rating: true,
        "rating--readonly": this.readonly,
        "rating--disabled": this.disabled,
        "rating--rtl": isRtl
      })}
        role="slider"
        aria-label=${this.label}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-readonly=${this.readonly ? "true" : "false"}
        aria-valuenow=${this.value}
        aria-valuemin=${0}
        aria-valuemax=${this.max}
        tabindex=${this.disabled || this.readonly ? "-1" : "0"}
        @click=${this.handleClick}
        @keydown=${this.handleKeyDown}
        @mouseenter=${this.handleMouseEnter}
        @touchstart=${this.handleTouchStart}
        @mouseleave=${this.handleMouseLeave}
        @touchend=${this.handleTouchEnd}
        @mousemove=${this.handleMouseMove}
        @touchmove=${this.handleTouchMove}
      >
        <span class="rating__symbols">
          ${counter.map((index) => {
        if (displayValue > index && displayValue < index + 1) {
          return x`
                <span
                  class=${e10({
            rating__symbol: true,
            "rating__partial-symbol-container": true,
            "rating__symbol--hover": this.isHovering && Math.ceil(displayValue) === index + 1
          })}
                  role="presentation"
                >
                  <div
                    style=${o12({
            clipPath: isRtl ? `inset(0 ${(displayValue - index) * 100}% 0 0)` : `inset(0 0 0 ${(displayValue - index) * 100}%)`
          })}
                  >
                    ${o13(this.getSymbol(index + 1))}
                  </div>
                  <div
                    class="rating__partial--filled"
                    style=${o12({
            clipPath: isRtl ? `inset(0 0 0 ${100 - (displayValue - index) * 100}%)` : `inset(0 ${100 - (displayValue - index) * 100}% 0 0)`
          })}
                  >
                    ${o13(this.getSymbol(index + 1))}
                  </div>
                </span>
              `;
        }
        return x`
              <span
                class=${e10({
          rating__symbol: true,
          "rating__symbol--hover": this.isHovering && Math.ceil(displayValue) === index + 1,
          "rating__symbol--active": displayValue >= index + 1
        })}
                role="presentation"
              >
                ${o13(this.getSymbol(index + 1))}
              </span>
            `;
      })}
        </span>
      </div>
    `;
    }
  };
  SlRating.styles = [component_styles_default, rating_styles_default];
  SlRating.dependencies = { "sl-icon": SlIcon };
  __decorateClass2([
    e6(".rating")
  ], SlRating.prototype, "rating", 2);
  __decorateClass2([
    r6()
  ], SlRating.prototype, "hoverValue", 2);
  __decorateClass2([
    r6()
  ], SlRating.prototype, "isHovering", 2);
  __decorateClass2([
    n5()
  ], SlRating.prototype, "label", 2);
  __decorateClass2([
    n5({ type: Number })
  ], SlRating.prototype, "value", 2);
  __decorateClass2([
    n5({ type: Number })
  ], SlRating.prototype, "max", 2);
  __decorateClass2([
    n5({ type: Number })
  ], SlRating.prototype, "precision", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlRating.prototype, "readonly", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlRating.prototype, "disabled", 2);
  __decorateClass2([
    n5()
  ], SlRating.prototype, "getSymbol", 2);
  __decorateClass2([
    t4({ passive: true })
  ], SlRating.prototype, "handleTouchMove", 1);
  __decorateClass2([
    watch("hoverValue")
  ], SlRating.prototype, "handleHoverValueChange", 1);
  __decorateClass2([
    watch("isHovering")
  ], SlRating.prototype, "handleIsHoveringChange", 1);

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.SAJCVYYU.js
  SlRating.define("sl-rating");

  // node_modules/@jsfe/shoelace/dist/esm/widgets/rating.js
  var rating = (options) => x`<!--  -->
		<div class="theme-shoelace widget-rating" part="widget-rating">
			<label for=${options.id}>${options.label}</label>

			<sl-rating
				value=${o11(options.value)}
				precision=${o11(options.step)}
				min=${o11(options.min)}
				max=${o11(options.max)}
				.helpText=${options.helpText}
				.name=${options.id}
				.id=${options.id}
				.required=${options.required}
				@sl-change=${(event) => {
    const newValue = event.target.value;
    console.log(newValue);
    options.valueChangedCallback?.(newValue);
  }}
				.disabled=${options.disabled}
				.readonly=${options.readonly}
			></sl-rating>
		</div>`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.XNOUITPX.js
  var select_styles_default = i3`
  :host {
    display: block;
  }

  /** The popup */
  .select {
    flex: 1 1 auto;
    display: inline-flex;
    width: 100%;
    position: relative;
    vertical-align: middle;
  }

  .select::part(popup) {
    z-index: var(--sl-z-index-dropdown);
  }

  .select[data-current-placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .select[data-current-placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  /* Combobox */
  .select__combobox {
    flex: 1;
    display: flex;
    width: 100%;
    min-width: 0;
    position: relative;
    align-items: center;
    justify-content: start;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: pointer;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  .select__display-input {
    position: relative;
    width: 100%;
    font: inherit;
    border: none;
    background: none;
    color: var(--sl-input-color);
    cursor: inherit;
    overflow: hidden;
    padding: 0;
    margin: 0;
    -webkit-appearance: none;
  }

  .select__display-input::placeholder {
    color: var(--sl-input-placeholder-color);
  }

  .select:not(.select--disabled):hover .select__display-input {
    color: var(--sl-input-color-hover);
  }

  .select__display-input:focus {
    outline: none;
  }

  /* Visually hide the display input when multiple is enabled */
  .select--multiple:not(.select--placeholder-visible) .select__display-input {
    position: absolute;
    z-index: -1;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
  }

  .select__value-input {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    padding: 0;
    margin: 0;
    opacity: 0;
    z-index: -1;
  }

  .select__tags {
    display: flex;
    flex: 1;
    align-items: center;
    flex-wrap: wrap;
    margin-inline-start: var(--sl-spacing-2x-small);
  }

  .select__tags::slotted(sl-tag) {
    cursor: pointer !important;
  }

  .select--disabled .select__tags,
  .select--disabled .select__tags::slotted(sl-tag) {
    cursor: not-allowed !important;
  }

  /* Standard selects */
  .select--standard .select__combobox {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .select--standard.select--disabled .select__combobox {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    color: var(--sl-input-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
    outline: none;
  }

  .select--standard:not(.select--disabled).select--open .select__combobox,
  .select--standard:not(.select--disabled).select--focused .select__combobox {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  /* Filled selects */
  .select--filled .select__combobox {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .select--filled:hover:not(.select--disabled) .select__combobox {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .select--filled.select--disabled .select__combobox {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .select--filled:not(.select--disabled).select--open .select__combobox,
  .select--filled:not(.select--disabled).select--focused .select__combobox {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
  }

  /* Sizes */
  .select--small .select__combobox {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    min-height: var(--sl-input-height-small);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-small);
  }

  .select--small .select__clear {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .select--small .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .select--small.select--multiple:not(.select--placeholder-visible) .select__prefix::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .select--small.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-block: 2px;
    padding-inline-start: 0;
  }

  .select--small .select__tags {
    gap: 2px;
  }

  .select--medium .select__combobox {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    min-height: var(--sl-input-height-medium);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-medium);
  }

  .select--medium .select__clear {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .select--medium .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .select--medium.select--multiple:not(.select--placeholder-visible) .select__prefix::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .select--medium.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-inline-start: 0;
    padding-block: 3px;
  }

  .select--medium .select__tags {
    gap: 3px;
  }

  .select--large .select__combobox {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    min-height: var(--sl-input-height-large);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-large);
  }

  .select--large .select__clear {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .select--large .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  .select--large.select--multiple:not(.select--placeholder-visible) .select__prefix::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .select--large.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-inline-start: 0;
    padding-block: 4px;
  }

  .select--large .select__tags {
    gap: 4px;
  }

  /* Pills */
  .select--pill.select--small .select__combobox {
    border-radius: var(--sl-input-height-small);
  }

  .select--pill.select--medium .select__combobox {
    border-radius: var(--sl-input-height-medium);
  }

  .select--pill.select--large .select__combobox {
    border-radius: var(--sl-input-height-large);
  }

  /* Prefix and Suffix */
  .select__prefix,
  .select__suffix {
    flex: 0;
    display: inline-flex;
    align-items: center;
    color: var(--sl-input-placeholder-color);
  }

  .select__suffix::slotted(*) {
    margin-inline-start: var(--sl-spacing-small);
  }

  /* Clear button */
  .select__clear {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .select__clear:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .select__clear:focus {
    outline: none;
  }

  /* Expand icon */
  .select__expand-icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    transition: var(--sl-transition-medium) rotate ease;
    rotate: 0;
    margin-inline-start: var(--sl-spacing-small);
  }

  .select--open .select__expand-icon {
    rotate: -180deg;
  }

  /* Listbox */
  .select__listbox {
    display: block;
    position: relative;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    box-shadow: var(--sl-shadow-large);
    background: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    padding-block: var(--sl-spacing-x-small);
    padding-inline: 0;
    overflow: auto;
    overscroll-behavior: none;

    /* Make sure it adheres to the popup's auto size */
    max-width: var(--auto-size-available-width);
    max-height: var(--auto-size-available-height);
  }

  .select__listbox ::slotted(sl-divider) {
    --spacing: var(--sl-spacing-x-small);
  }

  .select__listbox ::slotted(small) {
    display: block;
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    color: var(--sl-color-neutral-500);
    padding-block: var(--sl-spacing-2x-small);
    padding-inline: var(--sl-spacing-x-large);
  }
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.RWUUFNUL.js
  function getOffset(element, parent) {
    return {
      top: Math.round(element.getBoundingClientRect().top - parent.getBoundingClientRect().top),
      left: Math.round(element.getBoundingClientRect().left - parent.getBoundingClientRect().left)
    };
  }
  function scrollIntoView(element, container, direction = "vertical", behavior = "smooth") {
    const offset3 = getOffset(element, container);
    const offsetTop = offset3.top + container.scrollTop;
    const offsetLeft = offset3.left + container.scrollLeft;
    const minX = container.scrollLeft;
    const maxX = container.scrollLeft + container.offsetWidth;
    const minY = container.scrollTop;
    const maxY = container.scrollTop + container.offsetHeight;
    if (direction === "horizontal" || direction === "both") {
      if (offsetLeft < minX) {
        container.scrollTo({ left: offsetLeft, behavior });
      } else if (offsetLeft + element.clientWidth > maxX) {
        container.scrollTo({ left: offsetLeft - container.offsetWidth + element.clientWidth, behavior });
      }
    }
    if (direction === "vertical" || direction === "both") {
      if (offsetTop < minY) {
        container.scrollTo({ top: offsetTop, behavior });
      } else if (offsetTop + element.clientHeight > maxY) {
        container.scrollTo({ top: offsetTop - container.offsetHeight + element.clientHeight, behavior });
      }
    }
  }

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.AILU2HNL.js
  var SlSelect = class extends ShoelaceElement {
    constructor() {
      super(...arguments);
      this.formControlController = new FormControlController(this, {
        assumeInteractionOn: ["sl-blur", "sl-input"]
      });
      this.hasSlotController = new HasSlotController(this, "help-text", "label");
      this.localize = new LocalizeController2(this);
      this.typeToSelectString = "";
      this.hasFocus = false;
      this.displayLabel = "";
      this.selectedOptions = [];
      this.valueHasChanged = false;
      this.name = "";
      this._value = "";
      this.defaultValue = "";
      this.size = "medium";
      this.placeholder = "";
      this.multiple = false;
      this.maxOptionsVisible = 3;
      this.disabled = false;
      this.clearable = false;
      this.open = false;
      this.hoist = false;
      this.filled = false;
      this.pill = false;
      this.label = "";
      this.placement = "bottom";
      this.helpText = "";
      this.form = "";
      this.required = false;
      this.getTag = (option) => {
        return x`
      <sl-tag
        part="tag"
        exportparts="
              base:tag__base,
              content:tag__content,
              remove-button:tag__remove-button,
              remove-button__base:tag__remove-button__base
            "
        ?pill=${this.pill}
        size=${this.size}
        removable
        @sl-remove=${(event) => this.handleTagRemove(event, option)}
      >
        ${option.getTextLabel()}
      </sl-tag>
    `;
      };
      this.handleDocumentFocusIn = (event) => {
        const path = event.composedPath();
        if (this && !path.includes(this)) {
          this.hide();
        }
      };
      this.handleDocumentKeyDown = (event) => {
        const target = event.target;
        const isClearButton = target.closest(".select__clear") !== null;
        const isIconButton = target.closest("sl-icon-button") !== null;
        if (isClearButton || isIconButton) {
          return;
        }
        if (event.key === "Escape" && this.open && !this.closeWatcher) {
          event.preventDefault();
          event.stopPropagation();
          this.hide();
          this.displayInput.focus({ preventScroll: true });
        }
        if (event.key === "Enter" || event.key === " " && this.typeToSelectString === "") {
          event.preventDefault();
          event.stopImmediatePropagation();
          if (!this.open) {
            this.show();
            return;
          }
          if (this.currentOption && !this.currentOption.disabled) {
            this.valueHasChanged = true;
            if (this.multiple) {
              this.toggleOptionSelection(this.currentOption);
            } else {
              this.setSelectedOptions(this.currentOption);
            }
            this.updateComplete.then(() => {
              this.emit("sl-input");
              this.emit("sl-change");
            });
            if (!this.multiple) {
              this.hide();
              this.displayInput.focus({ preventScroll: true });
            }
          }
          return;
        }
        if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
          const allOptions = this.getAllOptions();
          const currentIndex = allOptions.indexOf(this.currentOption);
          let newIndex = Math.max(0, currentIndex);
          event.preventDefault();
          if (!this.open) {
            this.show();
            if (this.currentOption) {
              return;
            }
          }
          if (event.key === "ArrowDown") {
            newIndex = currentIndex + 1;
            if (newIndex > allOptions.length - 1)
              newIndex = 0;
          } else if (event.key === "ArrowUp") {
            newIndex = currentIndex - 1;
            if (newIndex < 0)
              newIndex = allOptions.length - 1;
          } else if (event.key === "Home") {
            newIndex = 0;
          } else if (event.key === "End") {
            newIndex = allOptions.length - 1;
          }
          this.setCurrentOption(allOptions[newIndex]);
        }
        if (event.key && event.key.length === 1 || event.key === "Backspace") {
          const allOptions = this.getAllOptions();
          if (event.metaKey || event.ctrlKey || event.altKey) {
            return;
          }
          if (!this.open) {
            if (event.key === "Backspace") {
              return;
            }
            this.show();
          }
          event.stopPropagation();
          event.preventDefault();
          clearTimeout(this.typeToSelectTimeout);
          this.typeToSelectTimeout = window.setTimeout(() => this.typeToSelectString = "", 1e3);
          if (event.key === "Backspace") {
            this.typeToSelectString = this.typeToSelectString.slice(0, -1);
          } else {
            this.typeToSelectString += event.key.toLowerCase();
          }
          for (const option of allOptions) {
            const label = option.getTextLabel().toLowerCase();
            if (label.startsWith(this.typeToSelectString)) {
              this.setCurrentOption(option);
              break;
            }
          }
        }
      };
      this.handleDocumentMouseDown = (event) => {
        const path = event.composedPath();
        if (this && !path.includes(this)) {
          this.hide();
        }
      };
    }
    get value() {
      return this._value;
    }
    set value(val) {
      if (this.multiple) {
        val = Array.isArray(val) ? val : val.split(" ");
      } else {
        val = Array.isArray(val) ? val.join(" ") : val;
      }
      if (this._value === val) {
        return;
      }
      this.valueHasChanged = true;
      this._value = val;
    }
    /** Gets the validity state object */
    get validity() {
      return this.valueInput.validity;
    }
    /** Gets the validation message */
    get validationMessage() {
      return this.valueInput.validationMessage;
    }
    connectedCallback() {
      super.connectedCallback();
      setTimeout(() => {
        this.handleDefaultSlotChange();
      });
      this.open = false;
    }
    addOpenListeners() {
      var _a;
      document.addEventListener("focusin", this.handleDocumentFocusIn);
      document.addEventListener("keydown", this.handleDocumentKeyDown);
      document.addEventListener("mousedown", this.handleDocumentMouseDown);
      if (this.getRootNode() !== document) {
        this.getRootNode().addEventListener("focusin", this.handleDocumentFocusIn);
      }
      if ("CloseWatcher" in window) {
        (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
        this.closeWatcher = new CloseWatcher();
        this.closeWatcher.onclose = () => {
          if (this.open) {
            this.hide();
            this.displayInput.focus({ preventScroll: true });
          }
        };
      }
    }
    removeOpenListeners() {
      var _a;
      document.removeEventListener("focusin", this.handleDocumentFocusIn);
      document.removeEventListener("keydown", this.handleDocumentKeyDown);
      document.removeEventListener("mousedown", this.handleDocumentMouseDown);
      if (this.getRootNode() !== document) {
        this.getRootNode().removeEventListener("focusin", this.handleDocumentFocusIn);
      }
      (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
    }
    handleFocus() {
      this.hasFocus = true;
      this.displayInput.setSelectionRange(0, 0);
      this.emit("sl-focus");
    }
    handleBlur() {
      this.hasFocus = false;
      this.emit("sl-blur");
    }
    handleLabelClick() {
      this.displayInput.focus();
    }
    handleComboboxMouseDown(event) {
      const path = event.composedPath();
      const isIconButton = path.some((el) => el instanceof Element && el.tagName.toLowerCase() === "sl-icon-button");
      if (this.disabled || isIconButton) {
        return;
      }
      event.preventDefault();
      this.displayInput.focus({ preventScroll: true });
      this.open = !this.open;
    }
    handleComboboxKeyDown(event) {
      if (event.key === "Tab") {
        return;
      }
      event.stopPropagation();
      this.handleDocumentKeyDown(event);
    }
    handleClearClick(event) {
      event.stopPropagation();
      this.valueHasChanged = true;
      if (this.value !== "") {
        this.setSelectedOptions([]);
        this.displayInput.focus({ preventScroll: true });
        this.updateComplete.then(() => {
          this.emit("sl-clear");
          this.emit("sl-input");
          this.emit("sl-change");
        });
      }
    }
    handleClearMouseDown(event) {
      event.stopPropagation();
      event.preventDefault();
    }
    handleOptionClick(event) {
      const target = event.target;
      const option = target.closest("sl-option");
      const oldValue = this.value;
      if (option && !option.disabled) {
        this.valueHasChanged = true;
        if (this.multiple) {
          this.toggleOptionSelection(option);
        } else {
          this.setSelectedOptions(option);
        }
        this.updateComplete.then(() => this.displayInput.focus({ preventScroll: true }));
        if (this.value !== oldValue) {
          this.updateComplete.then(() => {
            this.emit("sl-input");
            this.emit("sl-change");
          });
        }
        if (!this.multiple) {
          this.hide();
          this.displayInput.focus({ preventScroll: true });
        }
      }
    }
    /* @internal - used by options to update labels */
    handleDefaultSlotChange() {
      if (!customElements.get("sl-option")) {
        customElements.whenDefined("sl-option").then(() => this.handleDefaultSlotChange());
      }
      const allOptions = this.getAllOptions();
      const val = this.valueHasChanged ? this.value : this.defaultValue;
      const value2 = Array.isArray(val) ? val : [val];
      const values = [];
      allOptions.forEach((option) => values.push(option.value));
      this.setSelectedOptions(allOptions.filter((el) => value2.includes(el.value)));
    }
    handleTagRemove(event, option) {
      event.stopPropagation();
      this.valueHasChanged = true;
      if (!this.disabled) {
        this.toggleOptionSelection(option, false);
        this.updateComplete.then(() => {
          this.emit("sl-input");
          this.emit("sl-change");
        });
      }
    }
    // Gets an array of all <sl-option> elements
    getAllOptions() {
      return [...this.querySelectorAll("sl-option")];
    }
    // Gets the first <sl-option> element
    getFirstOption() {
      return this.querySelector("sl-option");
    }
    // Sets the current option, which is the option the user is currently interacting with (e.g. via keyboard). Only one
    // option may be "current" at a time.
    setCurrentOption(option) {
      const allOptions = this.getAllOptions();
      allOptions.forEach((el) => {
        el.current = false;
        el.tabIndex = -1;
      });
      if (option) {
        this.currentOption = option;
        option.current = true;
        option.tabIndex = 0;
        option.focus();
      }
    }
    // Sets the selected option(s)
    setSelectedOptions(option) {
      const allOptions = this.getAllOptions();
      const newSelectedOptions = Array.isArray(option) ? option : [option];
      allOptions.forEach((el) => el.selected = false);
      if (newSelectedOptions.length) {
        newSelectedOptions.forEach((el) => el.selected = true);
      }
      this.selectionChanged();
    }
    // Toggles an option's selected state
    toggleOptionSelection(option, force) {
      if (force === true || force === false) {
        option.selected = force;
      } else {
        option.selected = !option.selected;
      }
      this.selectionChanged();
    }
    // This method must be called whenever the selection changes. It will update the selected options cache, the current
    // value, and the display value
    selectionChanged() {
      var _a, _b, _c;
      const options = this.getAllOptions();
      this.selectedOptions = options.filter((el) => el.selected);
      const cachedValueHasChanged = this.valueHasChanged;
      if (this.multiple) {
        this.value = this.selectedOptions.map((el) => el.value);
        if (this.placeholder && this.value.length === 0) {
          this.displayLabel = "";
        } else {
          this.displayLabel = this.localize.term("numOptionsSelected", this.selectedOptions.length);
        }
      } else {
        const selectedOption = this.selectedOptions[0];
        this.value = (_a = selectedOption == null ? void 0 : selectedOption.value) != null ? _a : "";
        this.displayLabel = (_c = (_b = selectedOption == null ? void 0 : selectedOption.getTextLabel) == null ? void 0 : _b.call(selectedOption)) != null ? _c : "";
      }
      this.valueHasChanged = cachedValueHasChanged;
      this.updateComplete.then(() => {
        this.formControlController.updateValidity();
      });
    }
    get tags() {
      return this.selectedOptions.map((option, index) => {
        if (index < this.maxOptionsVisible || this.maxOptionsVisible <= 0) {
          const tag = this.getTag(option, index);
          return x`<div @sl-remove=${(e13) => this.handleTagRemove(e13, option)}>
          ${typeof tag === "string" ? o13(tag) : tag}
        </div>`;
        } else if (index === this.maxOptionsVisible) {
          return x`<sl-tag size=${this.size}>+${this.selectedOptions.length - index}</sl-tag>`;
        }
        return x``;
      });
    }
    handleInvalid(event) {
      this.formControlController.setValidity(false);
      this.formControlController.emitInvalidEvent(event);
    }
    handleDisabledChange() {
      if (this.disabled) {
        this.open = false;
        this.handleOpenChange();
      }
    }
    attributeChangedCallback(name, oldVal, newVal) {
      super.attributeChangedCallback(name, oldVal, newVal);
      if (name === "value") {
        const cachedValueHasChanged = this.valueHasChanged;
        this.value = this.defaultValue;
        this.valueHasChanged = cachedValueHasChanged;
      }
    }
    handleValueChange() {
      if (!this.valueHasChanged) {
        const cachedValueHasChanged = this.valueHasChanged;
        this.value = this.defaultValue;
        this.valueHasChanged = cachedValueHasChanged;
      }
      const allOptions = this.getAllOptions();
      const value2 = Array.isArray(this.value) ? this.value : [this.value];
      this.setSelectedOptions(allOptions.filter((el) => value2.includes(el.value)));
    }
    async handleOpenChange() {
      if (this.open && !this.disabled) {
        this.setCurrentOption(this.selectedOptions[0] || this.getFirstOption());
        this.emit("sl-show");
        this.addOpenListeners();
        await stopAnimations(this);
        this.listbox.hidden = false;
        this.popup.active = true;
        requestAnimationFrame(() => {
          this.setCurrentOption(this.currentOption);
        });
        const { keyframes, options } = getAnimation(this, "select.show", { dir: this.localize.dir() });
        await animateTo(this.popup.popup, keyframes, options);
        if (this.currentOption) {
          scrollIntoView(this.currentOption, this.listbox, "vertical", "auto");
        }
        this.emit("sl-after-show");
      } else {
        this.emit("sl-hide");
        this.removeOpenListeners();
        await stopAnimations(this);
        const { keyframes, options } = getAnimation(this, "select.hide", { dir: this.localize.dir() });
        await animateTo(this.popup.popup, keyframes, options);
        this.listbox.hidden = true;
        this.popup.active = false;
        this.emit("sl-after-hide");
      }
    }
    /** Shows the listbox. */
    async show() {
      if (this.open || this.disabled) {
        this.open = false;
        return void 0;
      }
      this.open = true;
      return waitForEvent(this, "sl-after-show");
    }
    /** Hides the listbox. */
    async hide() {
      if (!this.open || this.disabled) {
        this.open = false;
        return void 0;
      }
      this.open = false;
      return waitForEvent(this, "sl-after-hide");
    }
    /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
    checkValidity() {
      return this.valueInput.checkValidity();
    }
    /** Gets the associated form, if one exists. */
    getForm() {
      return this.formControlController.getForm();
    }
    /** Checks for validity and shows the browser's validation message if the control is invalid. */
    reportValidity() {
      return this.valueInput.reportValidity();
    }
    /** Sets a custom validation message. Pass an empty string to restore validity. */
    setCustomValidity(message) {
      this.valueInput.setCustomValidity(message);
      this.formControlController.updateValidity();
    }
    /** Sets focus on the control. */
    focus(options) {
      this.displayInput.focus(options);
    }
    /** Removes focus from the control. */
    blur() {
      this.displayInput.blur();
    }
    render() {
      const hasLabelSlot = this.hasSlotController.test("label");
      const hasHelpTextSlot = this.hasSlotController.test("help-text");
      const hasLabel = this.label ? true : !!hasLabelSlot;
      const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
      const hasClearIcon = this.clearable && !this.disabled && this.value.length > 0;
      const isPlaceholderVisible = this.placeholder && this.value && this.value.length <= 0;
      return x`
      <div
        part="form-control"
        class=${e10({
        "form-control": true,
        "form-control--small": this.size === "small",
        "form-control--medium": this.size === "medium",
        "form-control--large": this.size === "large",
        "form-control--has-label": hasLabel,
        "form-control--has-help-text": hasHelpText
      })}
      >
        <label
          id="label"
          part="form-control-label"
          class="form-control__label"
          aria-hidden=${hasLabel ? "false" : "true"}
          @click=${this.handleLabelClick}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <sl-popup
            class=${e10({
        select: true,
        "select--standard": true,
        "select--filled": this.filled,
        "select--pill": this.pill,
        "select--open": this.open,
        "select--disabled": this.disabled,
        "select--multiple": this.multiple,
        "select--focused": this.hasFocus,
        "select--placeholder-visible": isPlaceholderVisible,
        "select--top": this.placement === "top",
        "select--bottom": this.placement === "bottom",
        "select--small": this.size === "small",
        "select--medium": this.size === "medium",
        "select--large": this.size === "large"
      })}
            placement=${this.placement}
            strategy=${this.hoist ? "fixed" : "absolute"}
            flip
            shift
            sync="width"
            auto-size="vertical"
            auto-size-padding="10"
          >
            <div
              part="combobox"
              class="select__combobox"
              slot="anchor"
              @keydown=${this.handleComboboxKeyDown}
              @mousedown=${this.handleComboboxMouseDown}
            >
              <slot part="prefix" name="prefix" class="select__prefix"></slot>

              <input
                part="display-input"
                class="select__display-input"
                type="text"
                placeholder=${this.placeholder}
                .disabled=${this.disabled}
                .value=${this.displayLabel}
                autocomplete="off"
                spellcheck="false"
                autocapitalize="off"
                readonly
                aria-controls="listbox"
                aria-expanded=${this.open ? "true" : "false"}
                aria-haspopup="listbox"
                aria-labelledby="label"
                aria-disabled=${this.disabled ? "true" : "false"}
                aria-describedby="help-text"
                role="combobox"
                tabindex="0"
                @focus=${this.handleFocus}
                @blur=${this.handleBlur}
              />

              ${this.multiple ? x`<div part="tags" class="select__tags">${this.tags}</div>` : ""}

              <input
                class="select__value-input"
                type="text"
                ?disabled=${this.disabled}
                ?required=${this.required}
                .value=${Array.isArray(this.value) ? this.value.join(", ") : this.value}
                tabindex="-1"
                aria-hidden="true"
                @focus=${() => this.focus()}
                @invalid=${this.handleInvalid}
              />

              ${hasClearIcon ? x`
                    <button
                      part="clear-button"
                      class="select__clear"
                      type="button"
                      aria-label=${this.localize.term("clearEntry")}
                      @mousedown=${this.handleClearMouseDown}
                      @click=${this.handleClearClick}
                      tabindex="-1"
                    >
                      <slot name="clear-icon">
                        <sl-icon name="x-circle-fill" library="system"></sl-icon>
                      </slot>
                    </button>
                  ` : ""}

              <slot name="suffix" part="suffix" class="select__suffix"></slot>

              <slot name="expand-icon" part="expand-icon" class="select__expand-icon">
                <sl-icon library="system" name="chevron-down"></sl-icon>
              </slot>
            </div>

            <div
              id="listbox"
              role="listbox"
              aria-expanded=${this.open ? "true" : "false"}
              aria-multiselectable=${this.multiple ? "true" : "false"}
              aria-labelledby="label"
              part="listbox"
              class="select__listbox"
              tabindex="-1"
              @mouseup=${this.handleOptionClick}
              @slotchange=${this.handleDefaultSlotChange}
            >
              <slot></slot>
            </div>
          </sl-popup>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
    }
  };
  SlSelect.styles = [component_styles_default, form_control_styles_default, select_styles_default];
  SlSelect.dependencies = {
    "sl-icon": SlIcon,
    "sl-popup": SlPopup,
    "sl-tag": SlTag
  };
  __decorateClass2([
    e6(".select")
  ], SlSelect.prototype, "popup", 2);
  __decorateClass2([
    e6(".select__combobox")
  ], SlSelect.prototype, "combobox", 2);
  __decorateClass2([
    e6(".select__display-input")
  ], SlSelect.prototype, "displayInput", 2);
  __decorateClass2([
    e6(".select__value-input")
  ], SlSelect.prototype, "valueInput", 2);
  __decorateClass2([
    e6(".select__listbox")
  ], SlSelect.prototype, "listbox", 2);
  __decorateClass2([
    r6()
  ], SlSelect.prototype, "hasFocus", 2);
  __decorateClass2([
    r6()
  ], SlSelect.prototype, "displayLabel", 2);
  __decorateClass2([
    r6()
  ], SlSelect.prototype, "currentOption", 2);
  __decorateClass2([
    r6()
  ], SlSelect.prototype, "selectedOptions", 2);
  __decorateClass2([
    r6()
  ], SlSelect.prototype, "valueHasChanged", 2);
  __decorateClass2([
    n5()
  ], SlSelect.prototype, "name", 2);
  __decorateClass2([
    r6()
  ], SlSelect.prototype, "value", 1);
  __decorateClass2([
    n5({ attribute: "value" })
  ], SlSelect.prototype, "defaultValue", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlSelect.prototype, "size", 2);
  __decorateClass2([
    n5()
  ], SlSelect.prototype, "placeholder", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlSelect.prototype, "multiple", 2);
  __decorateClass2([
    n5({ attribute: "max-options-visible", type: Number })
  ], SlSelect.prototype, "maxOptionsVisible", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlSelect.prototype, "disabled", 2);
  __decorateClass2([
    n5({ type: Boolean })
  ], SlSelect.prototype, "clearable", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlSelect.prototype, "open", 2);
  __decorateClass2([
    n5({ type: Boolean })
  ], SlSelect.prototype, "hoist", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlSelect.prototype, "filled", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlSelect.prototype, "pill", 2);
  __decorateClass2([
    n5()
  ], SlSelect.prototype, "label", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlSelect.prototype, "placement", 2);
  __decorateClass2([
    n5({ attribute: "help-text" })
  ], SlSelect.prototype, "helpText", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlSelect.prototype, "form", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlSelect.prototype, "required", 2);
  __decorateClass2([
    n5()
  ], SlSelect.prototype, "getTag", 2);
  __decorateClass2([
    watch("disabled", { waitUntilFirstUpdate: true })
  ], SlSelect.prototype, "handleDisabledChange", 1);
  __decorateClass2([
    watch(["defaultValue", "value"], { waitUntilFirstUpdate: true })
  ], SlSelect.prototype, "handleValueChange", 1);
  __decorateClass2([
    watch("open", { waitUntilFirstUpdate: true })
  ], SlSelect.prototype, "handleOpenChange", 1);
  setDefaultAnimation("select.show", {
    keyframes: [
      { opacity: 0, scale: 0.9 },
      { opacity: 1, scale: 1 }
    ],
    options: { duration: 100, easing: "ease" }
  });
  setDefaultAnimation("select.hide", {
    keyframes: [
      { opacity: 1, scale: 1 },
      { opacity: 0, scale: 0.9 }
    ],
    options: { duration: 100, easing: "ease" }
  });

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.TP2GB2HO.js
  SlSelect.define("sl-select");

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.FXXKMG2P.js
  var option_styles_default = i3`
  :host {
    display: block;
    user-select: none;
    -webkit-user-select: none;
  }

  :host(:focus) {
    outline: none;
  }

  .option {
    position: relative;
    display: flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-700);
    padding: var(--sl-spacing-x-small) var(--sl-spacing-medium) var(--sl-spacing-x-small) var(--sl-spacing-x-small);
    transition: var(--sl-transition-fast) fill;
    cursor: pointer;
  }

  .option--hover:not(.option--current):not(.option--disabled) {
    background-color: var(--sl-color-neutral-100);
    color: var(--sl-color-neutral-1000);
  }

  .option--current,
  .option--current.option--disabled {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
    opacity: 1;
  }

  .option--disabled {
    outline: none;
    opacity: 0.5;
    cursor: not-allowed;
  }

  .option__label {
    flex: 1 1 auto;
    display: inline-block;
    line-height: var(--sl-line-height-dense);
  }

  .option .option__check {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    visibility: hidden;
    padding-inline-end: var(--sl-spacing-2x-small);
  }

  .option--selected .option__check {
    visibility: visible;
  }

  .option__prefix,
  .option__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .option__prefix::slotted(*) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .option__suffix::slotted(*) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  @media (forced-colors: active) {
    :host(:hover:not([aria-disabled='true'])) .option {
      outline: dashed 1px SelectedItem;
      outline-offset: -1px;
    }
  }
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.BBCWSAUE.js
  var SlOption = class extends ShoelaceElement {
    constructor() {
      super(...arguments);
      this.localize = new LocalizeController2(this);
      this.isInitialized = false;
      this.current = false;
      this.selected = false;
      this.hasHover = false;
      this.value = "";
      this.disabled = false;
    }
    connectedCallback() {
      super.connectedCallback();
      this.setAttribute("role", "option");
      this.setAttribute("aria-selected", "false");
    }
    handleDefaultSlotChange() {
      if (this.isInitialized) {
        customElements.whenDefined("sl-select").then(() => {
          const controller = this.closest("sl-select");
          if (controller) {
            controller.handleDefaultSlotChange();
          }
        });
      } else {
        this.isInitialized = true;
      }
    }
    handleMouseEnter() {
      this.hasHover = true;
    }
    handleMouseLeave() {
      this.hasHover = false;
    }
    handleDisabledChange() {
      this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
    }
    handleSelectedChange() {
      this.setAttribute("aria-selected", this.selected ? "true" : "false");
    }
    handleValueChange() {
      if (typeof this.value !== "string") {
        this.value = String(this.value);
      }
      if (this.value.includes(" ")) {
        console.error(`Option values cannot include a space. All spaces have been replaced with underscores.`, this);
        this.value = this.value.replace(/ /g, "_");
      }
    }
    /** Returns a plain text label based on the option's content. */
    getTextLabel() {
      const nodes = this.childNodes;
      let label = "";
      [...nodes].forEach((node) => {
        if (node.nodeType === Node.ELEMENT_NODE) {
          if (!node.hasAttribute("slot")) {
            label += node.textContent;
          }
        }
        if (node.nodeType === Node.TEXT_NODE) {
          label += node.textContent;
        }
      });
      return label.trim();
    }
    render() {
      return x`
      <div
        part="base"
        class=${e10({
        option: true,
        "option--current": this.current,
        "option--disabled": this.disabled,
        "option--selected": this.selected,
        "option--hover": this.hasHover
      })}
        @mouseenter=${this.handleMouseEnter}
        @mouseleave=${this.handleMouseLeave}
      >
        <sl-icon part="checked-icon" class="option__check" name="check" library="system" aria-hidden="true"></sl-icon>
        <slot part="prefix" name="prefix" class="option__prefix"></slot>
        <slot part="label" class="option__label" @slotchange=${this.handleDefaultSlotChange}></slot>
        <slot part="suffix" name="suffix" class="option__suffix"></slot>
      </div>
    `;
    }
  };
  SlOption.styles = [component_styles_default, option_styles_default];
  SlOption.dependencies = { "sl-icon": SlIcon };
  __decorateClass2([
    e6(".option__label")
  ], SlOption.prototype, "defaultSlot", 2);
  __decorateClass2([
    r6()
  ], SlOption.prototype, "current", 2);
  __decorateClass2([
    r6()
  ], SlOption.prototype, "selected", 2);
  __decorateClass2([
    r6()
  ], SlOption.prototype, "hasHover", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlOption.prototype, "value", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlOption.prototype, "disabled", 2);
  __decorateClass2([
    watch("disabled")
  ], SlOption.prototype, "handleDisabledChange", 1);
  __decorateClass2([
    watch("selected")
  ], SlOption.prototype, "handleSelectedChange", 1);
  __decorateClass2([
    watch("value")
  ], SlOption.prototype, "handleValueChange", 1);

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.JXOKFADN.js
  SlOption.define("sl-option");

  // node_modules/@jsfe/shoelace/dist/esm/widgets/select.js
  var select = (options) => x`
	<sl-select
		value=${o11(options.value)}
		.required=${options.required}
		@sl-change=${(event) => {
    let newValue = event.target.value;
    if (Array.isArray(newValue))
      return;
    if (options.type === "number" || options.type === "integer") {
      newValue = Number(newValue);
    }
    options.valueChangedCallback?.(newValue);
  }}
		.disabled=${options.disabled}
		label=${o11(options.label)}
		.helpText=${options.helpText ?? ""}
		>${options.enum?.map((enumValue) => x` <sl-option .value=${String(enumValue)}>
					${enumValue}
				</sl-option>`)}</sl-select
	>
`;

  // node_modules/@jsfe/shoelace/dist/esm/widgets/select-multiple.js
  var selectMultiple = (options) => x`
	<sl-select
		class="theme-shoelace widget-select-multi level-${options.level}"
		part="widget-select-multi"
		.id=${options.id}
		.label=${options.label ?? ""}
		.value=${options.value}
		multiple
		clearable
		.disabled=${options.disabled}
		.helpText=${options.helpText ?? ""}
		@sl-change=${(event) => {
    const { value: value2 } = event.target;
    options.valueChangedCallback?.(value2);
  }}
	>
		${options?.enum?.map((enumValue) => {
    return x`<sl-option value=${enumValue}>${enumValue}</sl-option>`;
  })}
	</sl-select>
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.JCXLDPQF.js
  SlButton.define("sl-button");

  // node_modules/@jsfe/shoelace/dist/esm/widgets/submit.js
  var submit = (options) => x`
	<!--  -->
	<div id=${options.id} class="theme-shoelace widget-submit">
		<sl-button type="submit" size="large"
			>${options.label ?? "Submit"}</sl-button
		>
	</div>
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.EU44RQUN.js
  var switch_styles_default = i3`
  :host {
    display: inline-block;
  }

  :host([size='small']) {
    --height: var(--sl-toggle-size-small);
    --thumb-size: calc(var(--sl-toggle-size-small) + 4px);
    --width: calc(var(--height) * 2);

    font-size: var(--sl-input-font-size-small);
  }

  :host([size='medium']) {
    --height: var(--sl-toggle-size-medium);
    --thumb-size: calc(var(--sl-toggle-size-medium) + 4px);
    --width: calc(var(--height) * 2);

    font-size: var(--sl-input-font-size-medium);
  }

  :host([size='large']) {
    --height: var(--sl-toggle-size-large);
    --thumb-size: calc(var(--sl-toggle-size-large) + 4px);
    --width: calc(var(--height) * 2);

    font-size: var(--sl-input-font-size-large);
  }

  .switch {
    position: relative;
    display: inline-flex;
    align-items: center;
    font-family: var(--sl-input-font-family);
    font-size: inherit;
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .switch__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--width);
    height: var(--height);
    background-color: var(--sl-color-neutral-400);
    border: solid var(--sl-input-border-width) var(--sl-color-neutral-400);
    border-radius: var(--height);
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color;
  }

  .switch__control .switch__thumb {
    width: var(--thumb-size);
    height: var(--thumb-size);
    background-color: var(--sl-color-neutral-0);
    border-radius: 50%;
    border: solid var(--sl-input-border-width) var(--sl-color-neutral-400);
    translate: calc((var(--width) - var(--height)) / -2);
    transition:
      var(--sl-transition-fast) translate ease,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) box-shadow;
  }

  .switch__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  /* Hover */
  .switch:not(.switch--checked):not(.switch--disabled) .switch__control:hover {
    background-color: var(--sl-color-neutral-400);
    border-color: var(--sl-color-neutral-400);
  }

  .switch:not(.switch--checked):not(.switch--disabled) .switch__control:hover .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-neutral-400);
  }

  /* Focus */
  .switch:not(.switch--checked):not(.switch--disabled) .switch__input:focus-visible ~ .switch__control {
    background-color: var(--sl-color-neutral-400);
    border-color: var(--sl-color-neutral-400);
  }

  .switch:not(.switch--checked):not(.switch--disabled) .switch__input:focus-visible ~ .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Checked */
  .switch--checked .switch__control {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch--checked .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    translate: calc((var(--width) - var(--height)) / 2);
  }

  /* Checked + hover */
  .switch.switch--checked:not(.switch--disabled) .switch__control:hover {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch.switch--checked:not(.switch--disabled) .switch__control:hover .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
  }

  /* Checked + focus */
  .switch.switch--checked:not(.switch--disabled) .switch__input:focus-visible ~ .switch__control {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
  }

  .switch.switch--checked:not(.switch--disabled) .switch__input:focus-visible ~ .switch__control .switch__thumb {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-primary-600);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .switch--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .switch__label {
    display: inline-block;
    line-height: var(--height);
    margin-inline-start: 0.5em;
    user-select: none;
    -webkit-user-select: none;
  }

  :host([required]) .switch__label::after {
    content: var(--sl-input-required-content);
    color: var(--sl-input-required-content-color);
    margin-inline-start: var(--sl-input-required-content-offset);
  }

  @media (forced-colors: active) {
    .switch.switch--checked:not(.switch--disabled) .switch__control:hover .switch__thumb,
    .switch--checked .switch__control .switch__thumb {
      background-color: ButtonText;
    }
  }
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.TSAI7XEG.js
  var SlSwitch = class extends ShoelaceElement {
    constructor() {
      super(...arguments);
      this.formControlController = new FormControlController(this, {
        value: (control) => control.checked ? control.value || "on" : void 0,
        defaultValue: (control) => control.defaultChecked,
        setValue: (control, checked) => control.checked = checked
      });
      this.hasSlotController = new HasSlotController(this, "help-text");
      this.hasFocus = false;
      this.title = "";
      this.name = "";
      this.size = "medium";
      this.disabled = false;
      this.checked = false;
      this.defaultChecked = false;
      this.form = "";
      this.required = false;
      this.helpText = "";
    }
    /** Gets the validity state object */
    get validity() {
      return this.input.validity;
    }
    /** Gets the validation message */
    get validationMessage() {
      return this.input.validationMessage;
    }
    firstUpdated() {
      this.formControlController.updateValidity();
    }
    handleBlur() {
      this.hasFocus = false;
      this.emit("sl-blur");
    }
    handleInput() {
      this.emit("sl-input");
    }
    handleInvalid(event) {
      this.formControlController.setValidity(false);
      this.formControlController.emitInvalidEvent(event);
    }
    handleClick() {
      this.checked = !this.checked;
      this.emit("sl-change");
    }
    handleFocus() {
      this.hasFocus = true;
      this.emit("sl-focus");
    }
    handleKeyDown(event) {
      if (event.key === "ArrowLeft") {
        event.preventDefault();
        this.checked = false;
        this.emit("sl-change");
        this.emit("sl-input");
      }
      if (event.key === "ArrowRight") {
        event.preventDefault();
        this.checked = true;
        this.emit("sl-change");
        this.emit("sl-input");
      }
    }
    handleCheckedChange() {
      this.input.checked = this.checked;
      this.formControlController.updateValidity();
    }
    handleDisabledChange() {
      this.formControlController.setValidity(true);
    }
    /** Simulates a click on the switch. */
    click() {
      this.input.click();
    }
    /** Sets focus on the switch. */
    focus(options) {
      this.input.focus(options);
    }
    /** Removes focus from the switch. */
    blur() {
      this.input.blur();
    }
    /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
    checkValidity() {
      return this.input.checkValidity();
    }
    /** Gets the associated form, if one exists. */
    getForm() {
      return this.formControlController.getForm();
    }
    /** Checks for validity and shows the browser's validation message if the control is invalid. */
    reportValidity() {
      return this.input.reportValidity();
    }
    /** Sets a custom validation message. Pass an empty string to restore validity. */
    setCustomValidity(message) {
      this.input.setCustomValidity(message);
      this.formControlController.updateValidity();
    }
    render() {
      const hasHelpTextSlot = this.hasSlotController.test("help-text");
      const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
      return x`
      <div
        class=${e10({
        "form-control": true,
        "form-control--small": this.size === "small",
        "form-control--medium": this.size === "medium",
        "form-control--large": this.size === "large",
        "form-control--has-help-text": hasHelpText
      })}
      >
        <label
          part="base"
          class=${e10({
        switch: true,
        "switch--checked": this.checked,
        "switch--disabled": this.disabled,
        "switch--focused": this.hasFocus,
        "switch--small": this.size === "small",
        "switch--medium": this.size === "medium",
        "switch--large": this.size === "large"
      })}
        >
          <input
            class="switch__input"
            type="checkbox"
            title=${this.title}
            name=${this.name}
            value=${o11(this.value)}
            .checked=${l5(this.checked)}
            .disabled=${this.disabled}
            .required=${this.required}
            role="switch"
            aria-checked=${this.checked ? "true" : "false"}
            aria-describedby="help-text"
            @click=${this.handleClick}
            @input=${this.handleInput}
            @invalid=${this.handleInvalid}
            @blur=${this.handleBlur}
            @focus=${this.handleFocus}
            @keydown=${this.handleKeyDown}
          />

          <span part="control" class="switch__control">
            <span part="thumb" class="switch__thumb"></span>
          </span>

          <div part="label" class="switch__label">
            <slot></slot>
          </div>
        </label>

        <div
          aria-hidden=${hasHelpText ? "false" : "true"}
          class="form-control__help-text"
          id="help-text"
          part="form-control-help-text"
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
    }
  };
  SlSwitch.styles = [component_styles_default, form_control_styles_default, switch_styles_default];
  __decorateClass2([
    e6('input[type="checkbox"]')
  ], SlSwitch.prototype, "input", 2);
  __decorateClass2([
    r6()
  ], SlSwitch.prototype, "hasFocus", 2);
  __decorateClass2([
    n5()
  ], SlSwitch.prototype, "title", 2);
  __decorateClass2([
    n5()
  ], SlSwitch.prototype, "name", 2);
  __decorateClass2([
    n5()
  ], SlSwitch.prototype, "value", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlSwitch.prototype, "size", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlSwitch.prototype, "disabled", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlSwitch.prototype, "checked", 2);
  __decorateClass2([
    defaultValue("checked")
  ], SlSwitch.prototype, "defaultChecked", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlSwitch.prototype, "form", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlSwitch.prototype, "required", 2);
  __decorateClass2([
    n5({ attribute: "help-text" })
  ], SlSwitch.prototype, "helpText", 2);
  __decorateClass2([
    watch("checked", { waitUntilFirstUpdate: true })
  ], SlSwitch.prototype, "handleCheckedChange", 1);
  __decorateClass2([
    watch("disabled", { waitUntilFirstUpdate: true })
  ], SlSwitch.prototype, "handleDisabledChange", 1);

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.IADS735N.js
  SlSwitch.define("sl-switch");

  // node_modules/@jsfe/shoelace/dist/esm/widgets/switch.js
  var switchh = (options) => x`
	<sl-switch
		placeholder=${options.placeholder}
		.checked=${typeof options.value === "boolean" ? options.value : false}
		.name=${options.id}
		.id=${options.id}
		.required=${options.required}
		@sl-input=${(event) => {
    const { checked: newValue } = event.target;
    options.valueChangedCallback?.(newValue);
  }}
		.disabled=${options.disabled}
		>${options.label}
		${options.helpText ? x`<small> -&nbsp;${options.helpText}</small>` : E2}
	</sl-switch>
`;

  // node_modules/@jsfe/shoelace/dist/esm/widgets/text.js
  var text = (options) => x`
	<!-- ${options.pattern} -->
	<sl-input
		.type=${options.inputType}
		.label=${options.label}
		.helpText=${options.helpText}
		placeholder=${options.placeholder}
		value=${o11(options.value)}
		.name=${options.id}
		.id=${options.id}
		.required=${options.required}
		minLength=${o11(options.minLength)}
		maxLength=${o11(options.maxLength)}
		pattern=${o11(options.pattern)}
		@sl-input=${(event) => {
    const { value: newValue } = event.target;
    options.valueChangedCallback?.(newValue);
  }}
		.disabled=${options.disabled}
		.readonly=${options.readonly}
	>
	</sl-input>
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.6KE6SBMU.js
  var textarea_styles_default = i3`
  :host {
    display: block;
  }

  .textarea {
    display: grid;
    align-items: center;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
    cursor: text;
  }

  /* Standard textareas */
  .textarea--standard {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .textarea--standard:hover:not(.textarea--disabled) {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
  }
  .textarea--standard:hover:not(.textarea--disabled) .textarea__control {
    color: var(--sl-input-color-hover);
  }

  .textarea--standard.textarea--focused:not(.textarea--disabled) {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    color: var(--sl-input-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  .textarea--standard.textarea--focused:not(.textarea--disabled) .textarea__control {
    color: var(--sl-input-color-focus);
  }

  .textarea--standard.textarea--disabled {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .textarea__control,
  .textarea__size-adjuster {
    grid-area: 1 / 1 / 2 / 2;
  }

  .textarea__size-adjuster {
    visibility: hidden;
    pointer-events: none;
    opacity: 0;
  }

  .textarea--standard.textarea--disabled .textarea__control {
    color: var(--sl-input-color-disabled);
  }

  .textarea--standard.textarea--disabled .textarea__control::placeholder {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Filled textareas */
  .textarea--filled {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .textarea--filled:hover:not(.textarea--disabled) {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .textarea--filled.textarea--focused:not(.textarea--disabled) {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .textarea--filled.textarea--disabled {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .textarea__control {
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    line-height: 1.4;
    color: var(--sl-input-color);
    border: none;
    background: none;
    box-shadow: none;
    cursor: inherit;
    -webkit-appearance: none;
  }

  .textarea__control::-webkit-search-decoration,
  .textarea__control::-webkit-search-cancel-button,
  .textarea__control::-webkit-search-results-button,
  .textarea__control::-webkit-search-results-decoration {
    -webkit-appearance: none;
  }

  .textarea__control::placeholder {
    color: var(--sl-input-placeholder-color);
    user-select: none;
    -webkit-user-select: none;
  }

  .textarea__control:focus {
    outline: none;
  }

  /*
   * Size modifiers
   */

  .textarea--small {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
  }

  .textarea--small .textarea__control {
    padding: 0.5em var(--sl-input-spacing-small);
  }

  .textarea--medium {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .textarea--medium .textarea__control {
    padding: 0.5em var(--sl-input-spacing-medium);
  }

  .textarea--large {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
  }

  .textarea--large .textarea__control {
    padding: 0.5em var(--sl-input-spacing-large);
  }

  /*
   * Resize types
   */

  .textarea--resize-none .textarea__control {
    resize: none;
  }

  .textarea--resize-vertical .textarea__control {
    resize: vertical;
  }

  .textarea--resize-auto .textarea__control {
    height: auto;
    resize: none;
    overflow-y: hidden;
  }
`;

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.Q3IETUAU.js
  var SlTextarea = class extends ShoelaceElement {
    constructor() {
      super(...arguments);
      this.formControlController = new FormControlController(this, {
        assumeInteractionOn: ["sl-blur", "sl-input"]
      });
      this.hasSlotController = new HasSlotController(this, "help-text", "label");
      this.hasFocus = false;
      this.title = "";
      this.name = "";
      this.value = "";
      this.size = "medium";
      this.filled = false;
      this.label = "";
      this.helpText = "";
      this.placeholder = "";
      this.rows = 4;
      this.resize = "vertical";
      this.disabled = false;
      this.readonly = false;
      this.form = "";
      this.required = false;
      this.spellcheck = true;
      this.defaultValue = "";
    }
    /** Gets the validity state object */
    get validity() {
      return this.input.validity;
    }
    /** Gets the validation message */
    get validationMessage() {
      return this.input.validationMessage;
    }
    connectedCallback() {
      super.connectedCallback();
      this.resizeObserver = new ResizeObserver(() => this.setTextareaHeight());
      this.updateComplete.then(() => {
        this.setTextareaHeight();
        this.resizeObserver.observe(this.input);
      });
    }
    firstUpdated() {
      this.formControlController.updateValidity();
    }
    disconnectedCallback() {
      var _a;
      super.disconnectedCallback();
      if (this.input) {
        (_a = this.resizeObserver) == null ? void 0 : _a.unobserve(this.input);
      }
    }
    handleBlur() {
      this.hasFocus = false;
      this.emit("sl-blur");
    }
    handleChange() {
      this.value = this.input.value;
      this.setTextareaHeight();
      this.emit("sl-change");
    }
    handleFocus() {
      this.hasFocus = true;
      this.emit("sl-focus");
    }
    handleInput() {
      this.value = this.input.value;
      this.emit("sl-input");
    }
    handleInvalid(event) {
      this.formControlController.setValidity(false);
      this.formControlController.emitInvalidEvent(event);
    }
    setTextareaHeight() {
      if (this.resize === "auto") {
        this.sizeAdjuster.style.height = `${this.input.clientHeight}px`;
        this.input.style.height = "auto";
        this.input.style.height = `${this.input.scrollHeight}px`;
      } else {
        this.input.style.height = "";
      }
    }
    handleDisabledChange() {
      this.formControlController.setValidity(this.disabled);
    }
    handleRowsChange() {
      this.setTextareaHeight();
    }
    async handleValueChange() {
      await this.updateComplete;
      this.formControlController.updateValidity();
      this.setTextareaHeight();
    }
    /** Sets focus on the textarea. */
    focus(options) {
      this.input.focus(options);
    }
    /** Removes focus from the textarea. */
    blur() {
      this.input.blur();
    }
    /** Selects all the text in the textarea. */
    select() {
      this.input.select();
    }
    /** Gets or sets the textarea's scroll position. */
    scrollPosition(position) {
      if (position) {
        if (typeof position.top === "number")
          this.input.scrollTop = position.top;
        if (typeof position.left === "number")
          this.input.scrollLeft = position.left;
        return void 0;
      }
      return {
        top: this.input.scrollTop,
        left: this.input.scrollTop
      };
    }
    /** Sets the start and end positions of the text selection (0-based). */
    setSelectionRange(selectionStart, selectionEnd, selectionDirection = "none") {
      this.input.setSelectionRange(selectionStart, selectionEnd, selectionDirection);
    }
    /** Replaces a range of text with a new string. */
    setRangeText(replacement, start, end, selectMode = "preserve") {
      const selectionStart = start != null ? start : this.input.selectionStart;
      const selectionEnd = end != null ? end : this.input.selectionEnd;
      this.input.setRangeText(replacement, selectionStart, selectionEnd, selectMode);
      if (this.value !== this.input.value) {
        this.value = this.input.value;
        this.setTextareaHeight();
      }
    }
    /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
    checkValidity() {
      return this.input.checkValidity();
    }
    /** Gets the associated form, if one exists. */
    getForm() {
      return this.formControlController.getForm();
    }
    /** Checks for validity and shows the browser's validation message if the control is invalid. */
    reportValidity() {
      return this.input.reportValidity();
    }
    /** Sets a custom validation message. Pass an empty string to restore validity. */
    setCustomValidity(message) {
      this.input.setCustomValidity(message);
      this.formControlController.updateValidity();
    }
    render() {
      const hasLabelSlot = this.hasSlotController.test("label");
      const hasHelpTextSlot = this.hasSlotController.test("help-text");
      const hasLabel = this.label ? true : !!hasLabelSlot;
      const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
      return x`
      <div
        part="form-control"
        class=${e10({
        "form-control": true,
        "form-control--small": this.size === "small",
        "form-control--medium": this.size === "medium",
        "form-control--large": this.size === "large",
        "form-control--has-label": hasLabel,
        "form-control--has-help-text": hasHelpText
      })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${hasLabel ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${e10({
        textarea: true,
        "textarea--small": this.size === "small",
        "textarea--medium": this.size === "medium",
        "textarea--large": this.size === "large",
        "textarea--standard": !this.filled,
        "textarea--filled": this.filled,
        "textarea--disabled": this.disabled,
        "textarea--focused": this.hasFocus,
        "textarea--empty": !this.value,
        "textarea--resize-none": this.resize === "none",
        "textarea--resize-vertical": this.resize === "vertical",
        "textarea--resize-auto": this.resize === "auto"
      })}
          >
            <textarea
              part="textarea"
              id="input"
              class="textarea__control"
              title=${this.title}
              name=${o11(this.name)}
              .value=${l5(this.value)}
              ?disabled=${this.disabled}
              ?readonly=${this.readonly}
              ?required=${this.required}
              placeholder=${o11(this.placeholder)}
              rows=${o11(this.rows)}
              minlength=${o11(this.minlength)}
              maxlength=${o11(this.maxlength)}
              autocapitalize=${o11(this.autocapitalize)}
              autocorrect=${o11(this.autocorrect)}
              ?autofocus=${this.autofocus}
              spellcheck=${o11(this.spellcheck)}
              enterkeyhint=${o11(this.enterkeyhint)}
              inputmode=${o11(this.inputmode)}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @focus=${this.handleFocus}
              @blur=${this.handleBlur}
            ></textarea>
            <!-- This "adjuster" exists to prevent layout shifting. https://github.com/shoelace-style/shoelace/issues/2180 -->
            <div part="textarea-adjuster" class="textarea__size-adjuster" ?hidden=${this.resize !== "auto"}></div>
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
    }
  };
  SlTextarea.styles = [component_styles_default, form_control_styles_default, textarea_styles_default];
  __decorateClass2([
    e6(".textarea__control")
  ], SlTextarea.prototype, "input", 2);
  __decorateClass2([
    e6(".textarea__size-adjuster")
  ], SlTextarea.prototype, "sizeAdjuster", 2);
  __decorateClass2([
    r6()
  ], SlTextarea.prototype, "hasFocus", 2);
  __decorateClass2([
    n5()
  ], SlTextarea.prototype, "title", 2);
  __decorateClass2([
    n5()
  ], SlTextarea.prototype, "name", 2);
  __decorateClass2([
    n5()
  ], SlTextarea.prototype, "value", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlTextarea.prototype, "size", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlTextarea.prototype, "filled", 2);
  __decorateClass2([
    n5()
  ], SlTextarea.prototype, "label", 2);
  __decorateClass2([
    n5({ attribute: "help-text" })
  ], SlTextarea.prototype, "helpText", 2);
  __decorateClass2([
    n5()
  ], SlTextarea.prototype, "placeholder", 2);
  __decorateClass2([
    n5({ type: Number })
  ], SlTextarea.prototype, "rows", 2);
  __decorateClass2([
    n5()
  ], SlTextarea.prototype, "resize", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlTextarea.prototype, "disabled", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlTextarea.prototype, "readonly", 2);
  __decorateClass2([
    n5({ reflect: true })
  ], SlTextarea.prototype, "form", 2);
  __decorateClass2([
    n5({ type: Boolean, reflect: true })
  ], SlTextarea.prototype, "required", 2);
  __decorateClass2([
    n5({ type: Number })
  ], SlTextarea.prototype, "minlength", 2);
  __decorateClass2([
    n5({ type: Number })
  ], SlTextarea.prototype, "maxlength", 2);
  __decorateClass2([
    n5()
  ], SlTextarea.prototype, "autocapitalize", 2);
  __decorateClass2([
    n5()
  ], SlTextarea.prototype, "autocorrect", 2);
  __decorateClass2([
    n5()
  ], SlTextarea.prototype, "autocomplete", 2);
  __decorateClass2([
    n5({ type: Boolean })
  ], SlTextarea.prototype, "autofocus", 2);
  __decorateClass2([
    n5()
  ], SlTextarea.prototype, "enterkeyhint", 2);
  __decorateClass2([
    n5({
      type: Boolean,
      converter: {
        // Allow "true|false" attribute values but keep the property boolean
        fromAttribute: (value2) => !value2 || value2 === "false" ? false : true,
        toAttribute: (value2) => value2 ? "true" : "false"
      }
    })
  ], SlTextarea.prototype, "spellcheck", 2);
  __decorateClass2([
    n5()
  ], SlTextarea.prototype, "inputmode", 2);
  __decorateClass2([
    defaultValue()
  ], SlTextarea.prototype, "defaultValue", 2);
  __decorateClass2([
    watch("disabled", { waitUntilFirstUpdate: true })
  ], SlTextarea.prototype, "handleDisabledChange", 1);
  __decorateClass2([
    watch("rows", { waitUntilFirstUpdate: true })
  ], SlTextarea.prototype, "handleRowsChange", 1);
  __decorateClass2([
    watch("value", { waitUntilFirstUpdate: true })
  ], SlTextarea.prototype, "handleValueChange", 1);

  // node_modules/@shoelace-style/shoelace/dist/chunks/chunk.WMS2VUJ6.js
  SlTextarea.define("sl-textarea");

  // node_modules/@jsfe/shoelace/dist/esm/widgets/textarea.js
  var textarea = (options) => x`
	<!--  -->
	<sl-textarea
		.label=${options.label ?? ""}
		.helpText=${options.helpText ?? ""}
		placeholder=${options.placeholder ?? ""}
		value=${o11(options.value)}
		.name=${options.id}
		.id=${options.id}
		.required=${options.required ?? true}
		minLength=${o11(options.minLength)}
		maxLength=${o11(options.maxLength)}
		@sl-input=${(event) => {
    const { value: newValue } = event.target;
    options.valueChangedCallback?.(newValue);
  }}
		.disabled=${options.disabled}
		.readonly=${options.readonly}
	>
	</sl-textarea>
`;

  // node_modules/@jsfe/shoelace/dist/esm/styles.js
  var styles = i3`@charset "UTF-8";
:host {
  box-sizing: border-box;
  font: 16px var(--sl-font-sans);
  font-weight: var(--sl-font-weight-normal);
  line-height: var(--sl-line-height-normal);
  color: var(--sl-color-neutral-900);
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-smoothing: antialiased;
  --sl-input-focus-ring-color: var(--sl-color-primary-50);
}
:host *,
:host *::before,
:host *::after {
  box-sizing: inherit;
}

::selection {
  color: var(--sl-color-primary-300);
  background-color: var(--sl-color-primary-950);
}

sl-input,
sl-select,
sl-checkbox {
  display: block;
}

/* User invalid styles */
sl-input[data-user-invalid]::part(base),
sl-select[data-user-invalid]::part(combobox),
sl-checkbox[data-user-invalid]::part(control) {
  border-color: var(--sl-color-danger-600);
}

[data-user-invalid]::part(form-control-label),
[data-user-invalid]::part(form-control-help-text),
sl-checkbox[data-user-invalid]::part(label) {
  color: var(--sl-color-danger-700);
}

sl-checkbox[data-user-invalid]::part(control) {
  outline: none;
}

sl-input:focus-within[data-user-invalid]::part(base),
sl-select:focus-within[data-user-invalid]::part(combobox),
sl-checkbox:focus-within[data-user-invalid]::part(control) {
  border-color: var(--sl-color-danger-600);
  box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-color-danger-300);
}

.theme-shoelace.widget-fieldset {
  display: flex;
  flex-direction: column;
  gap: var(--sl-spacing-x-large) 0;
  padding: var(--sl-spacing-medium) var(--sl-spacing-small);
  margin: 0;
  font-weight: var(--sl-font-weight-semibold);
  border: 1px solid var(--sl-color-neutral-50);
  border-radius: var(--sl-border-radius-large);
}
.theme-shoelace.widget-fieldset .widget-fieldset__description {
  font-size: var(--sl-input-help-text-font-size-medium);
  color: var(--sl-input-help-text-color);
}
.theme-shoelace.widget-fieldset .theme-shoelace.widget-fieldset {
  transition: box-shadow var(--sl-transition-medium);
}
.theme-shoelace.widget-fieldset .theme-shoelace.widget-fieldset:hover {
  box-shadow: var(--sl-shadow-medium);
}
.theme-shoelace.widget-fieldset.level-0 legend {
  font-size: var(--sl-font-size-2x-large);
  font-weight: 200;
}
.theme-shoelace.widget-fieldset.level-1 legend {
  font-size: var(--sl-font-size-x-large);
  font-weight: var(--sl-font-weight-light);
}
.theme-shoelace.widget-fieldset.level-2 legend {
  font-size: var(--sl-font-size-large);
  font-weight: var(--sl-font-weight-light);
}
.theme-shoelace.widget-fieldset.level-3 legend {
  font-size: var(--sl-font-size-medium);
  font-weight: var(--sl-font-weight-bold);
}
.theme-shoelace.widget-array .widget-array__card {
  transition: box-shadow var(--sl-transition-medium);
}
.theme-shoelace.widget-array .widget-array__card:hover {
  box-shadow: var(--sl-shadow-medium);
}
.theme-shoelace.widget-array .widget-array__card[data-dropzone] {
  border-radius: var(--sl-border-radius-medium);
  outline: 1px solid var(--sl-color-primary-500);
}
.theme-shoelace.widget-array .widget-array__card[data-dropzone] * {
  pointer-events: none;
}
.theme-shoelace.widget-array sl-card::part(body) {
  padding: var(--sl-spacing-medium) var(--sl-spacing-small);
}
.theme-shoelace.widget-array .widget-array__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  font-size: 0.8em;
  user-select: none;
}
.theme-shoelace.widget-array .widget-array__header sl-tag::part(base) {
  background: var(--sl-color-neutral-100);
}
.theme-shoelace.widget-array .widget-array__handle {
  display: flex;
  flex-grow: 1;
  align-items: center;
  justify-content: space-between;
  height: 2rem;
  padding-left: var(--sl-spacing-2x-small);
  margin: 0 var(--sl-spacing-medium) 0 0;
  font-size: 1.25em;
  color: var(--sl-color-neutral-500);
  cursor: move;
  transition: opacity, var(--sl-transition-fast);
}
.theme-shoelace.widget-array .widget-array__handle:hover {
  color: var(--sl-color-neutral-600);
  background: var(--sl-color-neutral-100);
  border-radius: var(--sl-border-radius-x-large);
  transition: var(--sl-transition-medium);
}
.theme-shoelace.widget-array .widget-array__handle:active {
  user-select: none;
}
.theme-shoelace.widget-array .widget-array__handle .widget-array__handle-grip {
  display: flex;
  flex-grow: 1;
  justify-content: center;
}
.theme-shoelace.widget-array .widget-array__add-zone {
  display: flex;
  padding: var(--sl-spacing-2x-large) var(--sl-spacing-2x-large);
  border: 2px dashed var(--sl-color-gray-100);
  border-radius: var(--sl-border-radius-large);
  box-shadow: var(--sl-shadow-large) inset;
}
.theme-shoelace.widget-array .widget-array__add-zone > sl-button {
  width: 100%;
}

/* Callouts */
.theme-shoelace.widget-callout {
  position: relative;
  padding: 1rem 1.5rem 1rem 2rem;
  margin: var(--sl-spacing-x-large) var(--sl-spacing-large);
  color: var(--sl-color-neutral-800);
  background-color: var(--sl-color-neutral-100);
  border-left: solid 4px var(--sl-color-neutral-500);
  border-radius: var(--sl-border-radius-medium);
}
.theme-shoelace.widget-callout > :first-child {
  margin-top: 0;
}
.theme-shoelace.widget-callout > :last-child {
  margin-bottom: 0;
}
.theme-shoelace.widget-callout.callout--tip {
  color: var(--sl-color-primary-800);
  background-color: var(--sl-color-primary-100);
  border-left-color: var(--sl-color-primary-600);
}
.theme-shoelace.widget-callout::before {
  position: absolute;
  top: calc(50% - 0.8rem);
  left: calc(-0.8rem - 2px);
  display: flex;
  align-items: center;
  justify-content: center;
  width: 1.6rem;
  height: 1.6rem;
  clip-path: circle(50% at 50% 50%);
  font-family: var(--sl-font-serif);
  font-weight: var(--sl-font-weight-bold);
  color: var(--sl-color-neutral-0);
  content: "";
}
.theme-shoelace.widget-callout.callout--tip::before {
  font-style: italic;
  content: "i";
  background-color: var(--sl-color-primary-600);
}
.theme-shoelace.widget-callout.callout--warning {
  color: var(--sl-color-warning-800);
  background-color: var(--sl-color-warning-100);
  border-left-color: var(--sl-color-warning-600);
}
.theme-shoelace.widget-callout.callout--warning::before {
  content: "!";
  background-color: var(--sl-color-warning-600);
}
.theme-shoelace.widget-callout.callout--danger {
  color: var(--sl-color-danger-800);
  background-color: var(--sl-color-danger-100);
  border-left-color: var(--sl-color-danger-600);
}
.theme-shoelace.widget-callout.callout--danger::before {
  content: "";
  background-color: var(--sl-color-danger-600);
}
.theme-shoelace.widget-callout + .theme-shoelace.widget-callout {
  margin-top: calc(-0.5 * var(--sl-spacing-medium));
}
.theme-shoelace.widget-callout a {
  color: inherit;
}

.theme-shoelace.widget-checkbox-group .help-text {
  font-size: var(--sl-input-help-text-font-size-medium);
  color: var(--sl-input-help-text-color);
}
.theme-shoelace.widget-checkbox-group .widget-checkbox-group__list {
  display: flex;
  flex-wrap: wrap;
  gap: var(--sl-spacing-large) var(--sl-spacing-4x-large);
  justify-content: space-evenly;
  padding: var(--sl-spacing-medium) var(--sl-spacing-x-large);
}

.theme-shoelace.widget-checkbox {
  display: flex;
  flex-wrap: wrap;
  gap: var(--sl-spacing-small);
}
.theme-shoelace.widget-checkbox label {
  cursor: pointer;
}
.theme-shoelace.widget-checkbox .widget-checkbox__description {
  width: 100%;
  font-size: var(--sl-input-help-text-font-size-medium);
  color: var(--sl-input-help-text-color);
}
.theme-shoelace.widget-checkbox .widget-checkbox__label {
  width: 100%;
}

.theme-shoelace.widget-color-picker {
  display: flex;
  flex-wrap: wrap;
  gap: var(--sl-spacing-large);
  align-items: center;
}
.theme-shoelace.widget-color-picker .widget-color-picker__description {
  font-size: var(--sl-input-help-text-font-size-medium);
  color: var(--sl-input-help-text-color);
}

.theme-shoelace.widget-radio-group-boolean::part(form-control-input) {
  display: flex;
  gap: 1rem;
}

.theme-shoelace.widget-radio-group::part(form-control-input) {
  display: flex;
  flex-wrap: wrap;
  gap: var(--sl-spacing-small) var(--sl-spacing-x-large);
}

.theme-shoelace.widget-rating label {
  display: block;
  margin-bottom: 0.5em;
}

.theme-shoelace.widget-submit {
  display: flex;
  justify-content: center;
  margin: var(--sl-spacing-2x-large) 0;
}
`;

  // node_modules/@jsfe/shoelace/dist/esm/form.js
  var JsfShoelace = class extends Jsf {
    constructor() {
      super(...arguments);
      this.widgets = widgets_exports;
      this.styleSheets = [styles];
    }
  };

  // node_modules/@jsfe/shoelace/dist/esm/form.def.js
  customElements.define("jsf-shoelace", JsfShoelace);

  // src/stops.js
  async function initStops(container) {
    container.innerHTML = `
    <h2>Stops</h2>
    <div id="stops-table">
    </div>
    <div id="stops-form">
    </div>
  `;
    const formSchema = {
      title: "",
      description: "Add new bus stop",
      properties: {
        Location: {
          type: "string"
        }
      }
    };
    const formEl = document.createElement("jsf-shoelace");
    formEl.schema = formSchema;
    formEl.submitCallback = async (newData, valid) => {
      console.info({ newData, valid });
      try {
        await createStop(newData.Location);
        i.success({ title: "Success", description: "Stop created successfully", duration: 1e4 });
        await renderTable();
      } catch (err) {
        i.error({ title: "Error", description: err.message, duration: 1e4 });
      }
    };
    formEl.data = {
      Location: "Stop location"
    };
    document.getElementById("stops-form").appendChild(formEl);
    async function renderTable() {
      const stops = await getStops();
      const table = document.createElement("active-table");
      table.isCellTextEditable = false;
      table.displayAddNewColumn = false;
      table.displayAddNewRow = false;
      table.columnDropdown = {
        displaySettings: { "isAvailable": true },
        isSortAvailable: true,
        isDeleteAvailable: false,
        isInsertLeftAvailable: false,
        isInsertRightAvailable: false,
        isMoveAvailable: false
      };
      table.rowDropdown = {
        displaySettings: { "isAvailable": true },
        isInsertUpAvailable: false,
        isInsertDownAvailable: false,
        isMoveAvailable: false,
        isDeleteAvailable: true,
        canEditHeaderRow: false
      };
      table.frameComponentsStyles = { "style": { "hoverColors": { "backgroundColor": "white" } } };
      table.headerStyles = { "hoverColors": { "backgroundColor": "white" } };
      table.tableStyle = { "borderRadius": "2px", "width": "100%" };
      table.data = [
        ["ID", "Location"],
        ...stops.map((s6) => [String(s6.id), s6.location])
      ];
      let lastIDs = [];
      table.onDataUpdate = async (dataUpdate) => {
        console.log(dataUpdate);
        let IDs = [];
        dataUpdate.forEach((x2) => IDs.push(x2[0]));
        lastIDs.forEach(async (x2) => {
          if (!IDs.includes(x2)) {
            try {
              await removeStop(x2);
              i.success({ title: "Success", description: "Stop removed successfully", duration: 1e4 });
            } catch (err) {
              i.error({ title: "Error", description: err.message, duration: 1e4 });
            }
          }
        });
        lastIDs = [];
        dataUpdate.forEach((x2) => lastIDs.push(x2[0]));
      };
      const tableContainer = document.getElementById("stops-table");
      tableContainer.innerHTML = "";
      tableContainer.appendChild(table);
    }
    await renderTable();
  }

  // src/routes.js
  async function initRoutes(container) {
    container.innerHTML = `
    <h2>Routes</h2>
    <div id="routes-table">
    </div>
    <div id="routes-form">
    </div>
  `;
    const formSchema = {
      title: "",
      description: "Add new bus route",
      properties: {
        "Route ID": {
          type: "number"
        },
        Time: {
          type: "string"
        },
        "Stop ID": {
          type: "string"
        }
      }
    };
    const formEl = document.createElement("jsf-shoelace");
    formEl.schema = formSchema;
    formEl.submitCallback = async (newData, valid) => {
      console.info({ newData, valid });
      try {
        await createRoute(newData["Route ID"], newData["Time"], newData["Stop ID"]);
        i.success({ title: "Success", description: "Route created successfully", duration: 1e4 });
        await renderTable();
      } catch (err) {
        i.error({ title: "Error", description: err.message, duration: 1e4 });
      }
    };
    document.getElementById("routes-form").appendChild(formEl);
    async function renderTable() {
      const routes = await getRoutes();
      const table = document.createElement("active-table");
      table.isCellTextEditable = false;
      table.displayAddNewColumn = false;
      table.displayAddNewRow = false;
      table.columnDropdown = {
        displaySettings: { "isAvailable": true },
        isSortAvailable: true,
        isDeleteAvailable: false,
        isInsertLeftAvailable: false,
        isInsertRightAvailable: false,
        isMoveAvailable: false
      };
      table.rowDropdown = {
        displaySettings: { "isAvailable": true },
        isInsertUpAvailable: false,
        isInsertDownAvailable: false,
        isMoveAvailable: false,
        isDeleteAvailable: true,
        canEditHeaderRow: false
      };
      table.frameComponentsStyles = { "style": { "hoverColors": { "backgroundColor": "white" } } };
      table.headerStyles = { "hoverColors": { "backgroundColor": "white" } };
      table.tableStyle = { "borderRadius": "2px", "width": "100%" };
      table.data = [
        ["ID", "Route ID", "Time", "Stop ID"],
        ...routes.map((s6) => [String(s6.id), String(s6.route_id), s6.time, String(s6.stop_id)])
      ];
      let lastIDs = [];
      table.onDataUpdate = async (dataUpdate) => {
        console.log(dataUpdate);
        let IDs = [];
        dataUpdate.forEach((x2) => IDs.push(x2[0]));
        lastIDs.forEach(async (x2) => {
          if (!IDs.includes(x2)) {
            try {
              await removeRoute(x2);
              i.success({ title: "Success", description: "Route removed successfully", duration: 1e4 });
            } catch (err) {
              i.error({ title: "Error", description: err.message, duration: 1e4 });
            }
          }
        });
        lastIDs = [];
        dataUpdate.forEach((x2) => lastIDs.push(x2[0]));
      };
      const tableContainer = document.getElementById("routes-table");
      tableContainer.innerHTML = "";
      tableContainer.appendChild(table);
    }
    await renderTable();
  }

  // src/lines.js
  async function initLines(container) {
    container.innerHTML = `
    <h2>Lines</h2>
    <div id="lines-container"></div>
  `;
    async function renderTables() {
      const lines = await getLines();
      const containerEl = document.getElementById("lines-container");
      containerEl.innerHTML = "";
      lines.forEach((line) => {
        const wrapper = document.createElement("div");
        wrapper.classList.add("line-wrapper");
        wrapper.style.marginBottom = "2rem";
        const heading = document.createElement("h3");
        heading.textContent = `Line ${line.id}`;
        wrapper.appendChild(heading);
        const table = document.createElement("active-table");
        table.isCellTextEditable = false;
        table.displayAddNewColumn = false;
        table.displayAddNewRow = false;
        table.columnDropdown = {
          displaySettings: { isAvailable: true },
          isSortAvailable: true,
          isDeleteAvailable: false,
          isInsertLeftAvailable: false,
          isInsertRightAvailable: false,
          isMoveAvailable: false
        };
        table.rowDropdown = { displaySettings: { isAvailable: false } };
        table.frameComponentsStyles = { style: { hoverColors: { backgroundColor: "white" } } };
        table.headerStyles = { hoverColors: { backgroundColor: "white" } };
        table.tableStyle = { borderRadius: "2px", width: "100%" };
        const rows = [];
        line.stops.forEach((stop) => {
          stop.times.forEach((time) => {
            rows.push([String(stop.id), stop.location, time]);
          });
        });
        table.data = [
          ["Stop ID", "Location", "Time"],
          ...rows
        ];
        wrapper.appendChild(table);
        containerEl.appendChild(wrapper);
      });
    }
    await renderTables();
  }

  // src/register.js
  async function initRegister(container) {
    container.style.marginLeft = "auto";
    container.style.marginRight = "auto";
    container.style.marginTop = "100px";
    container.style.maxWidth = "500px";
    container.innerHTML = `
    <div id="register-form">
    </div>
  `;
    const formSchema = {
      title: "",
      description: "Register",
      properties: {
        Name: {
          type: "string"
        },
        Password: {
          type: "string"
        },
        "Password (Repeat)": {
          type: "string"
        }
      }
    };
    const uiSchema = {
      "Password": {
        "ui:widget": "password"
      },
      "Password (Repeat)": {
        "ui:widget": "password"
      }
    };
    const formEl = document.createElement("jsf-shoelace");
    formEl.schema = formSchema;
    formEl.uiSchema = uiSchema;
    formEl.submitButtonLabel = "Register";
    formEl.submitCallback = async (newData, valid) => {
      console.info({ newData, valid });
      if (newData["Password"] !== newData["Password (Repeat)"]) {
        i.error({ title: "Error", description: "Error: Passwords do not match!", duration: 1e4 });
        return;
      }
      try {
        await createUser(newData.Name, newData.Password);
        i.success({ title: "Success", description: "Registration completed successfully", duration: 1e4 });
        location.reload();
      } catch (err) {
        i.error({ title: "Error", description: err.message, duration: 1e4 });
      }
    };
    const hint = document.createElement("div");
    hint.innerHTML = `
  Don't have an account? Register <a href='#register'>here</a>.
  `;
    hint.onclick = () => document.getElementById("register-form").remove();
    document.getElementById("register-form").appendChild(formEl);
    document.getElementById("register-form").appendChild(hint);
  }

  // src/login.js
  async function initLogin(container) {
    container.style.marginLeft = "auto";
    container.style.marginRight = "auto";
    container.style.marginTop = "100px";
    container.style.maxWidth = "500px";
    container.innerHTML = `
    <div id="login-form">
    </div>
  `;
    const formSchema = {
      title: "Fleet Manager \u{1F68C}",
      description: "",
      properties: {
        Name: {
          type: "string"
        },
        Password: {
          type: "string"
        }
      }
    };
    const uiSchema = {
      "Password": {
        "ui:widget": "password"
      }
    };
    const formEl = document.createElement("jsf-shoelace");
    formEl.schema = formSchema;
    formEl.uiSchema = uiSchema;
    formEl.submitButtonLabel = "Login";
    formEl.submitCallback = async (newData, valid) => {
      console.info({ newData, valid });
      try {
        const resp = await login(newData.Name, newData.Password);
        localStorage.setItem("sessionToken", resp?.token);
        i.success({ title: "Success", description: "Logged in successfully", duration: 1e4 });
        location.reload();
      } catch (err) {
        i.error({ title: "Error", description: err.message, duration: 1e4 });
      }
    };
    const hint = document.createElement("div");
    hint.innerHTML = `
  Don't have an account? Register <a href='#'>here</a>.
  `;
    hint.onclick = () => {
      document.getElementById("login-form").remove();
      initRegister(container);
    };
    document.getElementById("login-form").appendChild(formEl);
    document.getElementById("login-form").appendChild(hint);
  }

  // src/home.js
  async function initHome(container) {
    container.innerHTML = `
    <h2>Welcome to Fleet Manager</h2>
    <h3 id="user-info"></h3>
    <div id="home-form"></div>
    <div id="driver-routes"></div>
  `;
    let userData = await checkUser();
    if (!userData?.logged_in) {
      location.reload();
      return;
    }
    userData = userData.user;
    userData.role = userData.roles[0];
    document.getElementById("user-info").innerText = `You are logged in as ${userData.username} (${userData.role})`;
    if (userData.role === "admin") {
      let [users, routes] = await Promise.all([getUsers(), getRoutes()]);
      if (users.length == 1) {
        document.getElementById("home-form").innerText = `Please add at least one driver to configure duties.`;
        return;
      }
      const formSchema = {
        title: "Assign Routes to Drivers",
        type: "object",
        properties: {}
      };
      for (const user of users) {
        if (!user.roles.includes("driver"))
          continue;
        const duties = await getUserDuties(user.id);
        formSchema.properties[user.username] = {
          title: user.username,
          description: "Assign routes to this driver",
          type: "object",
          properties: {
            Routes: {
              title: "Routes",
              type: "array",
              uniqueItems: true,
              default: duties,
              items: {
                type: "string",
                enum: [...new Set(routes.map((r9) => r9.route_id))]
              }
            }
          }
        };
      }
      const uiSchema = {};
      for (const user of users) {
        if (!user.roles.includes("driver"))
          continue;
        uiSchema[user.username] = { Routes: { "ui:widget": "select" } };
      }
      const formEl = document.createElement("jsf-shoelace");
      formEl.schema = formSchema;
      formEl.uiSchema = uiSchema;
      formEl.submitButtonLabel = "Save";
      formEl.submitCallback = async (newData, valid) => {
        if (!valid) {
          i.error({ title: "Invalid", description: "Please fix the errors", duration: 1e4 });
          return;
        }
        try {
          for (const [username, userObj] of Object.entries(newData)) {
            console.log(username, userObj);
            const driver = users.find((u6) => u6.username === username);
            if (!driver)
              continue;
            const current = await getUserDuties(driver.id);
            console.log("current", current);
            for (const d4 of current) {
              if (!userObj.Routes.includes(d4)) {
                await assignDuty(driver.id, d4, "delete");
              }
            }
            for (const r9 of userObj.Routes) {
              if (!current.some((d4) => d4.route_id === r9)) {
                await assignDuty(driver.id, r9, "post");
              }
            }
          }
          i.success({ title: "Success", description: "Assignments saved", duration: 1e4 });
        } catch (err) {
          i.error({ title: "Error", description: err.message, duration: 1e4 });
        }
      };
      document.getElementById("home-form").appendChild(formEl);
    } else if (userData.role === "driver") {
      const [duties, routes, stops] = await Promise.all([
        getUserDuties(userData.id),
        getRoutes(),
        getStops()
      ]);
      const assigned = routes.filter((r9) => duties.some((d4) => d4 === r9.route_id)).map((r9) => {
        r9.location = stops.find((s6) => s6.id == r9.stop_id).location;
        return r9;
      });
      console.log(assigned);
      const div = document.getElementById("driver-routes");
      div.innerHTML = `
      <h3>Your Assigned Routes</h3>
      <ul>
        ${assigned.map((r9) => `<li>Route ${r9.route_id} at ${r9.time} (${r9.location}) </li>`).join("")}
      </ul>
    `;
    }
  }

  // node_modules/@moaqzdev/toast/dist/index.mjs
  var TOAST_EVENT = "@moaqzdev/toast";
  var Toaster = class _Toaster extends HTMLElement {
    constructor() {
      super(), this.attachShadow({ mode: "open" });
    }
    async createToast({ title: o14, type: r9, description: c7, onConfirm: v3, onCancel: f6, confirmText: b4 = "\u2705", cancelText: h6 = "\u274C", duration: d4 = 3e3 }) {
      const a5 = this.shadowRoot.querySelector("#toast-tmpl").content.cloneNode(true), t7 = { container: a5.querySelector("[data-toast]"), title: a5.querySelector("[data-title]"), description: a5.querySelector("[data-description]"), actions: a5.querySelector("[data-actions]"), confirmBtn: a5.querySelector("button[data-action-type='confirm']"), cancelBtn: a5.querySelector("button[data-action-type='cancel']"), closeBtn: a5.querySelector("[data-close-button]") };
      t7.title.textContent = o14 || "", t7.container.setAttribute("data-type", r9), c7 == null ? t7.description?.remove() : t7.description.textContent = c7;
      const n10 = () => this.removeToast(t7.container);
      if (r9 === "confirm" ? (t7.confirmBtn.textContent = b4, t7.confirmBtn.addEventListener("click", () => {
        v3?.(), n10();
      }, { once: true }), t7.cancelBtn.textContent = h6, t7.cancelBtn.addEventListener("click", () => {
        f6?.(), n10();
      }, { once: true })) : t7.actions?.remove(), this.hasAttribute("dismissable") ? t7.closeBtn.addEventListener("click", n10, { once: true }) : t7.closeBtn?.remove(), this.shadowRoot.querySelector("[data-toaster]").appendChild(a5), d4 !== "none") {
        const l6 = Math.max(Number.parseInt(d4, 10) || 0, 3e3), i11 = new AbortController(), g3 = Date.now();
        let e13 = null, p4 = 0;
        const u6 = () => {
          i11.abort(), n10();
        };
        let m4 = setTimeout(u6, l6);
        const y4 = () => {
          e13 == null && (clearTimeout(m4), e13 = Date.now());
        }, _3 = () => {
          e13 != null && (p4 = e13 - g3, e13 = null, m4 = setTimeout(u6, Math.max(l6 - p4, 0)));
        };
        ["focusin", "pointerenter", "mouseenter"].forEach((s6) => {
          t7.container.addEventListener(s6, y4, { signal: i11.signal });
        }), ["focusout", "pointerleave", "mouseleave"].forEach((s6) => {
          t7.container.addEventListener(s6, _3, { signal: i11.signal });
        });
      }
    }
    removeToast(o14) {
      o14.animate([{ opacity: 1 }, { opacity: 0 }], { duration: 300, easing: "ease", fill: "forwards" }).finished.then(() => o14.remove());
    }
    handleEvent(o14) {
      if (o14 instanceof CustomEvent && o14.type === TOAST_EVENT) {
        const r9 = o14.detail;
        this.createToast(r9);
      }
    }
    connectedCallback() {
      this.render(), document.addEventListener(TOAST_EVENT, this);
    }
    disconnectedCallback() {
      document.removeEventListener(TOAST_EVENT, this);
    }
    render() {
      this.shadowRoot.innerHTML = `
    <style>${_Toaster.STYLES}</style>

    <template id="toast-tmpl">
      <li data-toast tabindex="0">
        <button data-close-button aria-label="Close">
          <svg 
            xmlns="http://www.w3.org/2000/svg" 
            width="14" 
            height="14" 
            viewBox="0 0 24 24" 
            fill="none" 
            stroke="currentColor" 
            stroke-width="2" 
            stroke-linecap="round" 
            stroke-linejoin="round"
            aria-hidden="true"
          >
            <path d="M18 6 6 18"/><path d="m6 6 12 12"/>
          </svg>
        </button>
        <p data-title></p>
        <p data-description></p>
        <div data-actions>
          <button type="button" data-action-type="confirm"></button>
          <button type="button" data-action-type="cancel"></button>
        </div>
      </li>
    </template>

    <ol data-toaster tabindex="-1"></ol>`;
    }
    static STYLES = `
  * {
    box-sizing: border-box;
  }

  :host {
    --_travel-distance: var(--toast-travel-distance, 5vh);

    --_toast-background: var(--toast-background, #FCFCFC);
    --_toast-border: var(--toast-border, #00000026);
    --_toast-title: var(--toast-title, #000000DF);
    --_toast-description: var(--toast-description, #0000009B);

    --_toast-success: var(--toast-success, #00924BA4);
    --_toast-error: var(--toast-error, #D2000571);
    --_toast-warning: var(--toast-warning, #E35F00AA);
    --_toast-info: var(--toast-info, #0084E6A1);
    --_toast-confirm: var(--toast-confirm, #6600C06C);

    --_toast-actions-direction: var(--toast-actions-direction, row);
    --_toast-actions-justify: var(--toast-actions-justify, flex-end);
    --_toast-actions-gap: var(--toast-actions-gap, 0.25rem);

    --_toast-actions-confirm-text-color: var(--toast-actions-confirm-text-color, white);
    --_toast-actions-confirm-background-color: var(--toast-actions-confirm-background-color, #00713FDE);
    --_toast-actions-cancel-text-color: var(--toast-actions-cancel-text-color, white);
    --_toast-actions-cancel-background-color: var(--toast-actions-cancel-background-color, #C40006D3);
  }

  @media (prefers-color-scheme: dark) {
    :host {
      --_toast-background: var(--toast-background, #111111);
      --_toast-border: var(--toast-border,  #FFFFFF2C);
      --_toast-title: var(--toast-title, #FFFFFFED);
      --_toast-description: var(--toast-description, #FFFFFFAF);
  
      --_toast-success: var(--toast-success, #54FFAD73);
      --_toast-error: var(--toast-error, #FF5D61B0);
      --_toast-warning: var(--toast-warning, #FE84389D);
      --_toast-info: var(--toast-info, #3094FEB9);
      --_toast-confirm: var(--toast-confirm, #C47EFFA4);

      --_toast-actions-confirm-text-color: var(--toast-actions-confirm-text-color, white);
      --_toast-actions-confirm-background-color: var(--toast-actions-confirm-background-color, #54FFAD73);
      --_toast-actions-cancel-text-color: var(--toast-actions-cancel-text-color, white);
      --_toast-actions-cancel-background-color: var(--toast-actions-cancel-background-color, #FF5D61B0);
    }
  }

  @keyframes slide-in {
    from { 
      transform: translateY(var(--_travel-distance)) 
    }
  }

  @keyframes fade-in {
    from { opacity: 0 }
    to { opacity: 1 }
  }

  [data-toaster] {
    --container-width: 20rem;

    position: fixed;
    z-index: 999;
    width: var(--container-width);
    height: 100dvh;
    max-height: 100dvh;
    overflow: hidden;
    top: 0;
    right: 0;
    pointer-events: none;
    margin: 0;
    padding: 1rem;
    display: flex;
    flex-direction: column-reverse;
    gap: 0.5rem;
  }

  :host([position="bottom-right"]) [data-toaster] {
    top: 0;
    right: 0;
  }
  
  :host([position="bottom-left"]) [data-toaster] {
    top: 0;
    left: 0;
  }

  :host([position="bottom-center"]) [data-toaster] {
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
  }
  
  :host([position="top-right"]) [data-toaster] {
    top: 0;
    right: 0;
    flex-direction: column;
  }
  
  :host([position="top-left"]) [data-toaster] {
    top: 0;
    left: 0;
    flex-direction: column;
  }

  :host([position="top-center"]) [data-toaster] {
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    flex-direction: column;
  }

  [data-toast] {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    position: relative;

    pointer-events: none;
    user-select: none;

    list-style: none;
    background-color: var(--_toast-background);
    padding: 1rem;
    border: 1px solid var(--_toast-border);
    border-radius: 0.25rem;
    pointer-events: all;

    will-change: transform;
    animation: fade-in .3s ease, slide-in .3s ease;

    @media (prefers-reduced-motion: reduce){
      --_travel-distance: 0;
    }
  
    &[data-type="success"] {
      border-top: 4px solid var(--_toast-success);
    }
  
    &[data-type="error"] {
      border-top: 4px solid var(--_toast-error);
    }
  
    &[data-type="info"] {
      border-top: 4px solid var(--_toast-info)
    }

    &[data-type="warning"] {
      border-top: 4px solid var(--_toast-warning)
    }

    &[data-type="confirm"] {
      border-top: 4px solid var(--_toast-confirm);
    }
  }

  [data-close-button] {
    --size: 1.5rem;
    display: flex;
    justify-content: center;
    align-items: center;
    width: var(--size);
    height: var(--size);
    position: absolute;
    top: 0;
    left: 0;
    color: var(--_toast-title);
    background-color: var(--_toast-background);
    border-radius: 50%;
    border: 1px solid var(--_toast-border);
    padding: 0.125rem;
    translate: -35% -35%;
    cursor: pointer;
  }

  [data-actions] {
    display: flex;
    flex-direction: var(--_toast-actions-direction);
    justify-content: var(--_toast-actions-justify);
    gap: var(--_toast-actions-gap);
    margin-top: 0.5rem;
  }

  button[data-action-type="confirm"],
  button[data-action-type="cancel"] {
    padding: 0.5rem;
    border: none;
    border-radius: 0.25rem;
    cursor: pointer;
    transition-property: opacity;
    transition-duration: 200ms;

    &:hover,
    &:focus {
      opacity: 0.8;
    }
  }
      
  button[data-action-type="confirm"] {
    color: var(--_toast-actions-confirm-text-color);
    font-weight: 600;
    background-color: var(--_toast-actions-confirm-background-color);
  }

  button[data-action-type="cancel"] {
    color: var(--_toast-actions-cancel-text-color);
    font-weight: 600;
    background-color:var(--_toast-actions-cancel-background-color);
  }
  
  [data-title], [data-description] {
    margin: 0;
    all: initial; 
    font-family: inherit;
    line-height: 1.5;
  }

  [data-title] {
    font-size: 1rem;
    font-weight: 600;
    color: var(--_toast-title);
  }

  [data-description] {
    font-size: 0.875rem;
    color: var(--_toast-description);
    text-wrap: pretty;
  }`;
  };
  customElements.define("moaqz-toaster", Toaster);

  // src/index.js
  var contentEl = document.querySelector(".content");
  var links = document.querySelectorAll(".sidebar a");
  var sidebar = document.querySelector(".sidebar");
  document.querySelector("#logout").onclick = () => {
    localStorage.setItem("sessionToken", null);
    location.reload();
  };
  function setActive(link) {
    links.forEach((l6) => l6.classList.remove("active"));
    link.classList.add("active");
  }
  function loadPage(hash) {
    switch (hash) {
      case "#stops":
        initStops(contentEl);
        break;
      case "#routes":
        initRoutes(contentEl);
        break;
      case "#lines":
        initLines(contentEl);
        break;
      case "#home":
      default:
        initHome(contentEl);
        break;
    }
  }
  function initialLoad(defaultHash) {
    const initialHash = window.location.hash || defaultHash;
    const activeLink = [...links].find((l6) => l6.getAttribute("href") === initialHash) || links[0];
    setActive(activeLink);
    loadPage(initialHash);
  }
  async function setupPage() {
    const userData = await checkUser();
    console.log(userData);
    if (!userData?.logged_in) {
      sidebar?.remove();
      initLogin(contentEl);
    } else {
      links.forEach((link) => {
        link.addEventListener("click", (e13) => {
          e13.preventDefault();
          const hash = link.getAttribute("href");
          setActive(link);
          loadPage(hash);
          window.location.hash = hash;
        });
      });
      initialLoad("#home");
    }
  }
  var toastEl = document.createElement("moaqz-toaster");
  toastEl.setAttribute("dismissable", "");
  document.querySelector("body").appendChild(toastEl);
  window.addEventListener("popstate", async () => {
    const currentHash = window.location.hash;
    console.log(currentHash);
    const currentLink = [...links].find((l6) => l6.classList.contains("active"));
    if (currentLink?.getAttribute("href") != currentHash) {
      await setupPage();
    }
  });
  (async () => {
    await setupPage();
  })();
})();
/*! Bundled license information:

active-table/dist/activeTable.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/async-directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/ref.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/class-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/static.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/if-defined.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/live.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/style-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/unsafe-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=bundle.js.map
